<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.8.dev">
<meta name="description" content="可爱的 Raku">
<meta name="keywords" content="raku, lovely, lovely-raku">
<meta name="author" content="Raku 之美 - &lt;https://rakulang.github.io&gt;">
<title>Raku 介绍</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Raku 介绍</h1>
<div class="details">
<span id="author" class="author">Raku 之美 - &lt;https://rakulang.github.io&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#trueraku-介绍">1. Raku 介绍</a>
<ul class="sectlevel2">
<li><a href="#true安装">1.1. 安装</a></li>
<li><a href="#truedocker">1.2. Docker</a></li>
<li><a href="#truerepl">1.3. REPL</a></li>
<li><a href="#trueide">1.4. IDE</a></li>
</ul>
</li>
<li><a href="#true字符串">2. 字符串</a>
<ul class="sectlevel2">
<li><a href="#truechars">2.1. chars</a></li>
<li><a href="#trueord">2.2. ord</a></li>
<li><a href="#truecomb">2.3. comb</a></li>
<li><a href="#true字符串截取">2.4. 字符串截取</a></li>
<li><a href="#true字符串替换">2.5. 字符串替换</a></li>
<li><a href="#true字符串操作">2.6. 字符串操作</a></li>
<li><a href="#true字符串位置">2.7. 字符串位置</a></li>
<li><a href="#true字符串转换">2.8. 字符串转换</a></li>
<li><a href="#true字符串引用插值">2.9. 字符串引用/插值</a></li>
</ul>
</li>
<li><a href="#true数字">3. 数字</a>
<ul class="sectlevel2">
<li><a href="#true有理数">3.1. 有理数</a></li>
<li><a href="#trueint">3.2. Int</a></li>
<li><a href="#truenum">3.3. Num</a></li>
<li><a href="#truebigint">3.4. BigInt</a></li>
<li><a href="#truefat">3.5. Fat</a></li>
<li><a href="#truefatrat">3.6. FatRat</a></li>
</ul>
</li>
<li><a href="#true数组">4. 数组</a>
<ul class="sectlevel2">
<li><a href="#true数组字面量">4.1. 数组字面量</a></li>
<li><a href="#true数组切片">4.2. 数组切片</a></li>
<li><a href="#true禅切">4.3. 禅切</a></li>
<li><a href="#true多维数组">4.4. 多维数组</a></li>
<li><a href="#truemap">4.5. map</a></li>
<li><a href="#trueclassify">4.6. classify</a></li>
<li><a href="#true找出列表中最大值的索引">4.7. 找出列表中最大值的索引</a></li>
<li><a href="#true比较字符串长度">4.8. 比较字符串长度</a></li>
<li><a href="#true副词">4.9. 副词</a></li>
<li><a href="#true-rotor-强大的列表操作工具">4.10. <code>.rotor</code> - 强大的列表操作工具</a></li>
</ul>
</li>
<li><a href="#true散列">5. 散列</a>
<ul class="sectlevel2">
<li><a href="#true散列操作">5.1. 散列操作</a></li>
<li><a href="#true散列解构">5.2. 散列解构</a></li>
<li><a href="#true散列副词">5.3. 散列副词</a></li>
</ul>
</li>
<li><a href="#true控制语句">6. 控制语句</a>
<ul class="sectlevel2">
<li><a href="#truefor">6.1. for</a></li>
<li><a href="#truewhen">6.2. when</a></li>
<li><a href="#truegathertake">6.3. gather/take</a></li>
<li><a href="#truegatherfor">6.4. gather/for</a></li>
<li><a href="#trueuntil">6.5. until</a></li>
<li><a href="#truerepeat">6.6. repeat</a></li>
<li><a href="#truedo">6.7. do</a></li>
<li><a href="#trueif">6.8. if</a></li>
<li><a href="#trueunless">6.9. unless</a></li>
</ul>
</li>
<li><a href="#trueraku-中的函数">7. Raku 中的函数</a>
<ul class="sectlevel2">
<li><a href="#true子例程">7.1. 子例程</a></li>
<li><a href="#trueblocks-和-lambdas">7.2. Blocks 和 Lambdas</a></li>
<li><a href="#true签名">7.3. 签名</a></li>
<li><a href="#true返回值">7.4. 返回值</a></li>
<li><a href="#true返回类型约束">7.5. 返回类型约束</a></li>
<li><a href="#true多重分派">7.6. 多重分派</a></li>
<li><a href="#trueproto">7.7. proto</a></li>
<li><a href="#true约定和惯用法">7.8. 约定和惯用法</a></li>
<li><a href="#true强制类型">7.9. 强制类型</a></li>
<li><a href="#truesub-main">7.10. sub MAIN</a></li>
<li><a href="#truesub-usage">7.11. sub USAGE</a></li>
</ul>
</li>
<li><a href="#true副词-2">8. 副词</a>
<ul class="sectlevel2">
<li><a href="#true副词的-pair-形式">8.1. 副词的 Pair 形式</a></li>
<li><a href="#true下标副词">8.2. 下标副词</a></li>
<li><a href="#true组合下标副词">8.3. 组合下标副词</a></li>
</ul>
</li>
<li><a href="#true类">9. 类</a>
<ul class="sectlevel2">
<li><a href="#true从类开始">9.1. 从类开始</a></li>
<li><a href="#true状态">9.2. 状态</a></li>
<li><a href="#true静态字段">9.3. 静态字段</a></li>
<li><a href="#true方法">9.4. 方法</a></li>
<li><a href="#true私有方法">9.5. 私有方法</a></li>
<li><a href="#true构造函数">9.6. 构造函数</a></li>
<li><a href="#true消费我们的类">9.7. 消费我们的类</a></li>
<li><a href="#true继承">9.8. 继承</a></li>
<li><a href="#true重写继承到的方法">9.9. 重写继承到的方法</a></li>
<li><a href="#true多重继承">9.10. 多重继承</a></li>
<li><a href="#truealso-声明符">9.11. also 声明符</a></li>
<li><a href="#true自省">9.12. 自省</a></li>
<li><a href="#true重写默认的-gist-方法">9.13. 重写默认的 gist 方法</a></li>
</ul>
</li>
<li><a href="#true角色">10. 角色</a>
<ul class="sectlevel2">
<li><a href="#true角色声明">10.1. 角色声明</a></li>
<li><a href="#true角色组合">10.2. 角色组合</a></li>
<li><a href="#true角色冲突">10.3. 角色冲突</a></li>
<li><a href="#true匿名角色">10.4. 匿名角色</a></li>
<li><a href="#true实例化角色">10.5. 实例化角色</a></li>
</ul>
</li>
<li><a href="#truejunction">11. Junction</a>
<ul class="sectlevel2">
<li><a href="#trueall">11.1. all</a></li>
<li><a href="#trueany">11.2. any</a></li>
<li><a href="#truenone">11.3. none</a></li>
<li><a href="#trueone">11.4. one</a></li>
<li><a href="#trueany-2">11.5. any</a></li>
<li><a href="#trueall-for-one-and-any-for-none">11.6. All for One and Any for None</a></li>
<li><a href="#truecall-me-baby">11.7. Call Me, Baby</a></li>
<li><a href="#true我们一直在期盼你-请坐">11.8. 我们一直在期盼你, 请坐。</a></li>
<li><a href="#true结论">11.9. 结论</a></li>
</ul>
</li>
<li><a href="#true正则表达式">12. 正则表达式</a>
<ul class="sectlevel2">
<li><a href="#true词法约定">12.1. 词法约定</a></li>
<li><a href="#true字面值">12.2. 字面值</a></li>
<li><a href="#true通配符和字符类">12.3. 通配符和字符类</a></li>
<li><a href="#true量词">12.4. 量词</a></li>
<li><a href="#truealternation">12.5. Alternation: ||</a></li>
<li><a href="#truelongest-alternation">12.6. Longest Alternation: |</a></li>
<li><a href="#true锚点">12.7. 锚点</a></li>
<li><a href="#true分组和捕获">12.8. 分组和捕获</a></li>
<li><a href="#true替换">12.9. 替换</a></li>
<li><a href="#true词汇约定">12.10. 词汇约定</a></li>
<li><a href="#true替换字符串字面值">12.11. 替换字符串字面值</a></li>
<li><a href="#true通配符和字符类-2">12.12. 通配符和字符类</a></li>
<li><a href="#true捕获组">12.13. 捕获组</a></li>
<li><a href="#true用于嵌套结构的波浪号">12.14. 用于嵌套结构的波浪号</a></li>
<li><a href="#truesubrules">12.15. Subrules</a></li>
<li><a href="#true副词-3">12.16. 副词</a></li>
<li><a href="#true正则表达式副词">12.17. 正则表达式副词</a></li>
<li><a href="#truematching-adverbs">12.18. Matching adverbs</a></li>
<li><a href="#true环视断言">12.19. 环视断言</a></li>
<li><a href="#true最佳实践和陷阱">12.20. 最佳实践和陷阱</a></li>
</ul>
</li>
<li><a href="#truegrammar">13. Grammar</a>
<ul class="sectlevel2">
<li><a href="#true具名正则">13.1. 具名正则</a></li>
<li><a href="#true创建-grammar">13.2. 创建 Grammar</a></li>
<li><a href="#trueproto-regexes">13.3. Proto regexes</a></li>
<li><a href="#true特殊的-tokens">13.4. 特殊的 Tokens</a></li>
<li><a href="#truegrammar-中的方法">13.5. Grammar 中的方法</a></li>
<li><a href="#trueaction-object">13.6. Action Object</a></li>
<li><a href="#truegrammar-with-action">13.7. Grammar with Action</a></li>
<li><a href="#true解析售票数据">13.8. 解析售票数据</a></li>
</ul>
</li>
<li><a href="#true并发">14. 并发</a>
<ul class="sectlevel2">
<li><a href="#truesluppy">14.1. Sluppy</a></li>
<li><a href="#truechannel">14.2. Channel</a></li>
<li><a href="#truereactwhenever">14.3. react/whenever</a></li>
<li><a href="#truerace">14.4. race</a></li>
<li><a href="#truehyper">14.5. hyper</a></li>
</ul>
</li>
<li><a href="#true异常">15. 异常</a>
<ul class="sectlevel2">
<li><a href="#truedie">15.1. die</a></li>
<li><a href="#truewarn">15.2. warn</a></li>
<li><a href="#truenote">15.3. note</a></li>
</ul>
</li>
<li><a href="#true标准输入和标准输出">16. 标准输入和标准输出</a>
<ul class="sectlevel2">
<li><a href="#true标准输入">16.1. 标准输入</a></li>
<li><a href="#true标准输出">16.2. 标准输出</a></li>
<li><a href="#trueio-对象">16.3. IO 对象</a></li>
<li><a href="#trueget">16.4. get</a></li>
<li><a href="#true文件句柄">16.5. 文件句柄</a></li>
<li><a href="#truein">16.6. $*IN</a></li>
<li><a href="#trueout">16.7. $*OUT</a></li>
<li><a href="#trueargv">16.8. $*ARGV</a></li>
<li><a href="#trueargvfiles">16.9. $*ARGVFILES?</a></li>
</ul>
</li>
<li><a href="#truewhatever-star">17. Whatever Star</a>
<ul class="sectlevel2">
<li><a href="#true动态变量">17.1. 动态变量</a></li>
<li><a href="#truewhatever-star-2">17.2. Whatever Star</a></li>
</ul>
</li>
<li><a href="#true主题变量">18. 主题变量</a>
<ul class="sectlevel2">
<li><a href="#truefor-2">18.1. for</a></li>
<li><a href="#truegiven">18.2. given</a></li>
<li><a href="#trueregex">18.3. regex</a></li>
<li><a href="#truewithwithout">18.4. with/without</a></li>
<li><a href="#truewhen-2">18.5. when</a></li>
<li><a href="#truewhen-和-if">18.6. when 和 if</a></li>
<li><a href="#true签名-2">18.7. 签名</a></li>
</ul>
</li>
<li><a href="#true模式匹配">19. 模式匹配</a>
<ul class="sectlevel2">
<li><a href="#true同时检查名字和密码">19.1. 同时检查名字和密码</a></li>
<li><a href="#true使用单个元组">19.2. 使用单个元组</a></li>
<li><a href="#true部分匹配">19.3. 部分匹配</a></li>
<li><a href="#true只匹配元组的一部分">19.4. 只匹配元组的一部分</a></li>
<li><a href="#true匹配计算型元组">19.5. 匹配计算型元组</a></li>
<li><a href="#true遍历元组">19.6. 遍历元组</a></li>
<li><a href="#true使用-when-匹配元组中的指定值">19.7. 使用 when 匹配元组中的指定值</a></li>
<li><a href="#true匹配范围">19.8. 匹配范围</a></li>
<li><a href="#truewhen-可以配合智能匹配操作符-单独使用">19.9. when 可以配合智能匹配操作符 ~~ 单独使用</a></li>
<li><a href="#true使用-contains-方法">19.10. 使用 contains 方法</a></li>
<li><a href="#true匹配元组中的范围">19.11. 匹配元组中的范围</a></li>
<li><a href="#true枚举">19.12. 枚举</a></li>
<li><a href="#true使用-if-语句">19.13. 使用 if 语句</a></li>
<li><a href="#true关联值">19.14. 关联值</a></li>
<li><a href="#truewhen-从句">19.15. when 从句</a></li>
</ul>
</li>
<li><a href="#true解构">20. 解构</a>
<ul class="sectlevel2">
<li><a href="#true解构和赋值">20.1. 解构和赋值</a></li>
<li><a href="#true使用签名解构参数">20.2. 使用签名解构参数</a></li>
<li><a href="#true列表解构">20.3. 列表解构</a></li>
<li><a href="#true散列解构-2">20.4. 散列解构</a></li>
<li><a href="#true解构-json">20.5. 解构 JSON</a></li>
<li><a href="#true在块儿中使用签名">20.6. 在块儿中使用签名</a></li>
<li><a href="#true解构对象">20.7. 解构对象</a></li>
</ul>
</li>
<li><a href="#true模块">21. 模块</a>
<ul class="sectlevel2">
<li><a href="#true模块结构">21.1. 模块结构</a></li>
<li><a href="#true模块创建">21.2. 模块创建</a></li>
<li><a href="#true模块调试">21.3. 模块调试</a></li>
<li><a href="#true模块打包">21.4. 模块打包</a></li>
<li><a href="#true导出和选择性导出">21.5. 导出和选择性导出</a></li>
<li><a href="#true发布模块">21.6. 发布模块</a></li>
</ul>
</li>
<li><a href="#true排序">22. 排序</a>
<ul class="sectlevel2">
<li><a href="#true数组排序">22.1. 数组排序</a></li>
<li><a href="#true散列排序">22.2. 散列排序</a></li>
<li><a href="#true对象排序">22.3. 对象排序</a></li>
<li><a href="#true列表排序">22.4. 列表排序</a></li>
<li><a href="#true排序列表的列表">22.5. 排序列表的列表</a></li>
</ul>
</li>
<li><a href="#true签名-3">23. 签名</a>
<ul class="sectlevel2">
<li><a href="#true签名字面量">23.1. 签名字面量</a></li>
<li><a href="#true参数分隔符">23.2. 参数分隔符</a></li>
<li><a href="#true类型约束">23.3. 类型约束</a></li>
<li><a href="#true吞噬参数或长度可变参数">23.4. 吞噬参数(或长度可变参数)</a></li>
<li><a href="#true类型捕获">23.5. 类型捕获</a></li>
<li><a href="#true位置参数-vs-命名参数">23.6. 位置参数 vs. 命名参数</a></li>
<li><a href="#true可选参数和强制参数">23.7. 可选参数和强制参数</a></li>
<li><a href="#true解构参数">23.8. 解构参数</a></li>
<li><a href="#true捕获参数">23.9. 捕获参数</a></li>
<li><a href="#true参数特性和修饰符">23.10. 参数特性和修饰符</a></li>
<li><a href="#true签名方法">23.11. 签名方法</a></li>
</ul>
</li>
<li><a href="#true命令行工具">24. 命令行工具</a>
<ul class="sectlevel2">
<li><a href="#truemain">24.1. MAIN</a></li>
<li><a href="#truezef">24.2. zef</a></li>
</ul>
</li>
<li><a href="#truesubset">25. Subset</a></li>
<li><a href="#true最佳特性">26. 最佳特性</a>
<ul class="sectlevel2">
<li><a href="#truewhatever-star-3">26.1. Whatever Star</a></li>
<li><a href="#true隐式链接">26.2. 隐式链接</a></li>
<li><a href="#true可重新定义的运算符">26.3. 可重新定义的运算符</a></li>
<li><a href="#true元方法">26.4. 元方法</a></li>
<li><a href="#truetraits-2">26.5. traits</a></li>
<li><a href="#true智能匹配">26.6. 智能匹配</a></li>
<li><a href="#truegivenwhen">26.7. given/when</a></li>
<li><a href="#true类型签名">26.8. 类型签名</a></li>
<li><a href="#true元运算符">26.9. 元运算符</a></li>
</ul>
</li>
<li><a href="#true空白格">27. 空白格</a>
<ul class="sectlevel2">
<li><a href="#true关键字">27.1. 关键字</a></li>
<li><a href="#true中缀运算符">27.2. 中缀运算符</a></li>
<li><a href="#true链式调用">27.3. 链式调用</a></li>
<li><a href="#true名词和后缀运算符">27.4. 名词和后缀运算符</a></li>
<li><a href="#true">27.5. [+]</a></li>
<li><a href="#trueunspace">27.6. unspace</a></li>
<li><a href="#true正则中的空白">27.7. 正则中的空白</a></li>
<li><a href="#true原子与空白">27.8. 原子与空白</a></li>
<li><a href="#truesigspace-修饰符">27.9. :sigspace 修饰符</a></li>
<li><a href="#true字符类中的空白">27.10. 字符类中的空白</a></li>
<li><a href="#truegrammar-中的空白">27.11. grammar 中的空白</a></li>
</ul>
</li>
<li><a href="#true欧拉项目">28. 欧拉项目</a>
<ul class="sectlevel2">
<li><a href="#true3-和-5-的倍数">28.1. 3 和 5 的倍数</a></li>
<li><a href="#true偶数斐波那契数">28.2. 偶数斐波那契数</a></li>
<li><a href="#trueeuler003">28.3. Euler003</a></li>
<li><a href="#trueeuler004">28.4. Euler004</a></li>
<li><a href="#trueeuler005">28.5. Euler005</a></li>
<li><a href="#trueeuler006">28.6. Euler006</a></li>
<li><a href="#trueeuler007">28.7. Euler007</a></li>
<li><a href="#trueeuler008">28.8. Euler008</a></li>
</ul>
</li>
<li><a href="#true运算符">29. 运算符</a>
<ul class="sectlevel2">
<li><a href="#truezip">29.1. zip</a></li>
<li><a href="#true-2">29.2. «</a></li>
<li><a href="#truefeed">29.3. feed</a></li>
<li><a href="#true超运算符">29.4. 超运算符</a></li>
<li><a href="#truez">29.5. Z</a></li>
<li><a href="#truex">29.6. X</a></li>
<li><a href="#trueinfix-3">29.7. infix &#8230;&#8203;</a></li>
<li><a href="#true-3">29.8. &#8230;&#8203;</a></li>
</ul>
</li>
<li><a href="#true集合">30. 集合</a>
<ul class="sectlevel2">
<li><a href="#true集合运算">30.1. 集合运算</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Perl 6 的设计进程是从 2000 年开始的。在2000年7月19号 <a href="http://en.wikipedia.org/wiki/O%27Reilly_Open_Source_Convention">Perl大会</a>  的第四天, Larry Wall 首次宣布了 Perl 6 的设计进度。</p>
</div>
<div class="paragraph">
<p>Perl 6 可以有多个实现, 其中第一个完成度最高的实现是开始于 2005 年的 <a href="https://github.com/raku/Pugs.hs">Pugs</a>, Pugs 解释器是用 <a href="https://www.haskell.org">Haskell</a> 实现的, 2015 年以后就没再更新, 但是 Perl 6 设计团队吸收了很多函数式编程的思想。</p>
</div>
<div class="paragraph">
<p>2015 年12月25日, Perl 6 的第一个稳定的规范发布了。现在完成度最高的 Perl 6 实现是 <a href="https://rakudo.org">Rakudo</a>, 其使用 <a href="http://moarvm.org">MoarVM</a> 或 Java 虚拟机作为运行时环境。</p>
</div>
<div class="paragraph">
<p>2019 年10月12日, Larry Wall 宣布支持把 Perl 6 <a href="https://github.com/Raku/problem-solving/pull/89#pullrequestreview-300789072">更名</a>为 <a href="https://raku.org">Raku</a>。</p>
</div>
<div class="paragraph">
<p>2020 年6月24日, Perl 5 社区宣布将发布 <a href="https://www.perl.com/article/announcing-perl-7/">Perl 7</a>。所以, Perl 6 现在就是 Raku 了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="trueraku-介绍"><a class="anchor" href="#trueraku-介绍"></a>1. Raku 介绍</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true安装"><a class="anchor" href="#true安装"></a>1.1. 安装</h3>
<div class="paragraph">
<p><a href="https://rakudo.org/files">Rakudo Star</a> 是 Raku 的一个发行版, 由 Rakudo 编译器加上一些包组成, 可以直接下载对应平台的安装包, 按照说明文档进行安装.</p>
</div>
<div class="paragraph">
<p>如果想体验最新的 Raku 特性, 请自行编译 <a href="https://github.com/rakudo/rakudo">rakudo</a>:</p>
</div>
<div class="listingblock">
<div class="title">编译 Raku</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">git clone https://github.com/rakudo/rakudo.git
cd rakudo
perl Configure.pl --gen-moar --gen-nqp --backends=moar --prefix=/opt/rakudo
make
make install</code></pre>
</div>
</div>
<div class="paragraph">
<p>安装完 Rakudo Raku 编译器后, 使用自带的 <a href="https://github.com/ugexe/zef">zef</a> 安装 <code>Linenoise</code> 模块以获得简单的历史命令和自动补全功能.</p>
</div>
<div class="paragraph">
<p>Linux 用户还可以使用为 Rakudo 预编译好的系统包来安装 Rakudo Raku, 有关详细信息, 请参考 <a href="https://github.com/nxadm/rakudo-pkg">https://github.com/nxadm/rakudo-pkg</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="truedocker"><a class="anchor" href="#truedocker"></a>1.2. Docker</h3>
<div class="listingblock">
<div class="title">Docker</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker pull rakudo-star</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truerepl"><a class="anchor" href="#truerepl"></a>1.3. REPL</h3>
<div class="paragraph">
<p>Raku 自带了一个简陋的 REPL, 用于进行代码的快速测试. 打开系统的终端, 键入 <code>raku</code>, 即可进入 REPL, 键入一些 Raku 代码:</p>
</div>
<div class="listingblock">
<div class="title">Read,Evalute,Print,Loop</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs"># raku
To exit type 'exit' or '^D'
&gt; [+] 1,2,3
6
&gt; .say for 1..5
1
2
3
4
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前的 REPL 功能还很简陋, 如果要输入一些复杂的语句, 这个 REPL 就变得不太友好了.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueide"><a class="anchor" href="#trueide"></a>1.4. IDE</h3>
<div class="paragraph">
<p>2019 年3月份, <a href="https://commaide.com">comma</a>发布了第一个 Raku 编辑器社区版, 即逗号编辑器, 同时还有 Raku 的 IDEA 插件. 社区版的逗号编辑器功能已经基本够用, 如果你是资深 Raku 开发者或深度 Raku 爱好者, 建议购买完整版.</p>
</div>
<div class="paragraph">
<p>如果你使用 VSCode/Atom, 那么需要到应用商店安装 Raku 插件.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true字符串"><a class="anchor" href="#true字符串"></a>2. 字符串</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truechars"><a class="anchor" href="#truechars"></a>2.1. chars</h3>
<div class="listingblock">
<div class="title">字符个数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'楽土star'.chars # 6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueord"><a class="anchor" href="#trueord"></a>2.2. ord</h3>

</div>
<div class="sect2">
<h3 id="truecomb"><a class="anchor" href="#truecomb"></a>2.3. comb</h3>
<div class="sect3">
<h4 id="true普通字符"><a class="anchor" href="#true普通字符"></a>2.3.1. 普通字符</h4>
<div class="paragraph">
<p>你可以把 <a href="http://docs.raku.org/routine/comb">comb</a> 用作子例程或方法。在它的最基本的形式中， comb 会把字符串分解为字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'foobar moobar 駱駝道bar'.comb.join('|').say;
'foobar moobar 駱駝道bar'.comb(6).join('|').say;

# OUTPUT:
# f|o|o|b|a|r| |m|o|o|b|a|r| |駱|駝|道|b|a|r
# foobar| mooba|r 駱駝道b|ar</code></pre>
</div>
</div>
<div class="paragraph">
<p>不应用任何参数的 comb 你会得到各个单独的字符。给 comb 提供一个整数 <code>$n</code>, 那么你会得到长度至多为 <code>$n</code> 个字符的一个列表，并且如果没有剩下的字符不够的话，这个列表会接收较短的这个字符串。这个方法比使用正则表快了 30 倍。</p>
</div>
</div>
<div class="sect3">
<h4 id="true限制"><a class="anchor" href="#true限制"></a>2.3.2. 限制</h4>
<div class="paragraph">
<p>你也可以为 comb 提供第二个整数参数，即 <strong>limit</strong>，来标示每个列表中最多含有 limit 个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'foobar moobar 駱駝道bar'.comb(1, 5).join('|').say;
'foobar moobar 駱駝道bar'.comb(6, 2).join('|').say;

# OUTPUT:
# f|o|o|b|a
# foobar| mooba</code></pre>
</div>
</div>
<div class="paragraph">
<p>这适用于使用 comb 方法/函数的所有形式，而不仅仅是上面展示的那样。</p>
</div>
</div>
<div class="sect3">
<h4 id="true计数"><a class="anchor" href="#true计数"></a>2.3.3. 计数</h4>
<div class="paragraph">
<p>comb 也接收普通的 <a href="http://docs.raku.org/type/Str">Str</a> 作为参数，返回一个包含那个字符串的匹配的列表。所以这在计算子字符串在字符串中出现的次数时很有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'The 🐈 ran after a 🐁, but the 🐁 ran away'.comb('🐈').Int.say;
'The 🐈 ran after a 🐁, but the 🐁 ran away'.comb('ran').Int.say;

# OUTPUT:
# 1
# 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true简单的匹配"><a class="anchor" href="#true简单的匹配"></a>2.3.4. 简单的匹配</h4>
<div class="paragraph">
<p>comb 的参数也可以是一个正则表达式，整个匹配会作为一个标量被返回：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">foobar moobar 駱駝道bar'.comb(/&lt;[a..z]&gt;+ 'bar'/).join('|').say;

# OUTPUT:
# foobar|moobar</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true限制所匹配的东西"><a class="anchor" href="#true限制所匹配的东西"></a>2.3.5. 限制所匹配的东西</h4>
<div class="paragraph">
<p>你可以使用<a href="http://docs.raku.org/language/regexes#Look-around_assertions">环视断言</a>或者更简单的 <code>&lt;(</code> 和 <code>)&gt;</code> 正则表达式捕获记号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'moo=meow ping=pong'.comb(/\w+    '=' &lt;( \w**4/).join('|').say; # values
'moo=meow ping=pong'.comb(/\w+ )&gt; '='    \w**4/).join('|').say; # keys

# OUTPUT:
# meow|pong
# moo|ping</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用  <code>&lt;(</code> 和 <code>)&gt;</code> 两者之一或两者都使用。 <code>&lt;(</code> 从匹配中排除任何它之前的东西而 <code>)&gt;</code> 会排序之后的任何东西。即 <code>/'foo' &lt;('bar')&gt; 'ber'/</code> 会匹配包含 foobarber 的东西，但是从 comb 中返回的东西只会有 bar。</p>
</div>
</div>
<div class="sect3">
<h4 id="true多个捕获"><a class="anchor" href="#true多个捕获"></a>2.3.6. 多个捕获</h4>
<div class="paragraph">
<p>怎么样得出 Perl 5 那样的 键/值对儿呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %things = 'moo=meow ping=pong'.comb(/(\w+) '=' (\w+)/, :match)».Slip».Str;
say %things;

# OUTPUT:
# moo =&gt; meow, ping =&gt; pong</code></pre>
</div>
</div>
<div class="paragraph">
<p>圆括号用于捕获。<code>:match</code> 参数使 comb 返回一个 <strong>Match</strong> 对象的列表，而非返回一个字符串列表。下一步，我们使用两个 <strong>hyper</strong> 运算符把 Matches 转换为 <a href="http://docs.raku.org/type/Slip">Slips</a>，这会给我们一个捕获的列表，但是它们仍旧是 <strong>Match</strong> 对象，这就是为什么我们还要把它们转换为 <strong>Str</strong> 的原因。</p>
</div>
<div class="paragraph">
<p>我们还可以使用具名捕获使代码更清晰：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %things = 'moo=meow ping=pong'
    .comb(/$&lt;key&gt;=\w+ '=' $&lt;value&gt;=\w+/, :match)
    .map({ .&lt;key&gt; =&gt; .&lt;value&gt;.Str });
say %things;

# OUTPUT:
# moo =&gt; meow, ping =&gt; pong</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以把上面的代码写成这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %things = ('moo=meow ping=pong' ~~ m:g/(\w+) '=' (\w+)/)».Slip».Str;
say %things;

# OUTPUT:
# moo =&gt; meow, ping =&gt; pong</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：</p>
</div>
<div class="paragraph">
<p>代替使用带有 :match 参数的 .comb , 你最好就使用 .match 方法好了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'moo=meow ping=pong'.match(/(\w+) '=' (\w+)/, :g)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用正则表达式:</p>
</div>
<div class="listingblock">
<div class="title">comb</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = 'The quick brown fox jumps over the 100 lazy dog';
$str.comb: /&lt;:alpha&gt;+/
# (The quick brown fox jumps over the lazy dog)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>comb</code> 返回一个 Seq 序列。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符串截取"><a class="anchor" href="#true字符串截取"></a>2.4. 字符串截取</h3>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符串替换"><a class="anchor" href="#true字符串替换"></a>2.5. 字符串替换</h3>
<div class="sect3">
<h4 id="truesubst"><a class="anchor" href="#truesubst"></a>2.5.1. subst</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/subst">subst</a> 取的是单词 substitution(替换)的前5个字符, 意为替换之意。其签名为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi method subst(Str:D: $matcher, $replacement, *%opts)</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回被调用的那个字符串, 其中 <code>$matcher</code> 被 <code>$replacement</code> 给替换掉了(或者返回原来的字符串, 如果没有找到匹配的话)。</p>
</div>
<div class="paragraph">
<p><code>subst</code> 有一个「就地」替换的句法变体, 它被拼写为 <code>s/matcher/replacement/</code>。</p>
</div>
<div class="paragraph">
<p><code>$matcher</code> 可以是一个正则表达式, 或者一个字符串字面值。 Cool 类型的非字符串 matcher 会被强转为字符串以用于字面上的匹配。</p>
</div>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $some-string    = "Some foo";
my $another-string = $some-string.subst(/foo/, "string"); # gives 'Some string'
$some-string.=subst(/foo/, "string"); # 就地替换 $some-string 现在是 'Some string'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>replacement</code> 可以是一个闭包:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $i = 41;
my $str = "The answer is secret.";
my $real-answer = $str.subst(/secret/, {++$i}); # The answer is 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是 subst 其它用法的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = "Hey foo foo foo";
$str.subst(/foo/, "bar", :g);         # 全局替换 - 返回 Hey bar bar bar

$str.subst(/foo/, "no subst", :x(0)); # 有针对性的替换。要替换的次数. 返回未修改过的字符串.
$str.subst(/foo/, "bar", :x(1));      # 只替换第一次出现。

$str.subst(/foo/, "bar", :nth(3));    # 单独替换第 n 个匹配. 替换第三个 foo. 返回 Hey foo foo bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>第三个参数传递给散列, 例如 <code>:g</code> 被吞噬参数 <code>*%opts</code> 接收, 意为 <code>g &#8658; True</code>。
其中的 <code>:nth</code> 副词拥有可读的长得像英语那样的变体:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 'ooooo'.subst: 'o', 'x', :1st; # xoooo
say 'ooooo'.subst: 'o', 'x', :2nd; # oxooo
say 'ooooo'.subst: 'o', 'x', :3rd; # ooxoo
say 'ooooo'.subst: 'o', 'x', :4th; # oooxo</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.subst</code> 是 <strong>S</strong> 的方法形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 'meowmix'.subst: 'me', 'c';
say 'meowmix'.subst: /m./, 'c';

# OUTPUT:
# cowmix
# cowmix</code></pre>
</div>
</div>
<div class="paragraph">
<p>subst 还支持下面的副词:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Table subst</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>short</strong></th>
<th class="tableblock halign-left valign-top"><strong>long</strong></th>
<th class="tableblock halign-left valign-top"><strong>meaning</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:global</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尽可能多次地替换</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:nth(Int|Callable)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只替换第n次匹配; 别名: :st, :nd, :rd, 和 :th</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ss</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:samespace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">替换时保留空格</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ii</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:samecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">替换时保留大小写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:samemark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保留字符标记(例如,用 'o' 替换 'ü' 会导致 'ö')</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:x(Int|Callable)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">精确地替换 $x 次</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在方法形式中，你必须把这些副词应用到正则表达式自身身上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'Lorem Ipsum Dolor Sit Amet' {
    say .subst: /:i l/, 'b', :ii;
    say .subst: /:s Ipsum Dolor/, "Gipsum\nColor", :ss;
}

# OUTPUT:
# Borem Ipsum Dolor Sit Amet
# Lorem Gipsum Color Sit Amet</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法形式的捕获</p>
</div>
<div class="paragraph">
<p>捕获对于替换操作来说不陌生，所以我们来尝试捕获下方法调用形式的替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 'meowmix'.subst: /me (.+)/, "c$0";

# OUTPUT:
# Use of Nil in string context  in block &lt;unit&gt; at test.p6 line 1
# c</code></pre>
</div>
</div>
<div class="paragraph">
<p>不是我们要找的。我们的替换字符串构建在达到 <code>.subst</code> 方法之前，并且里面的 <code>$0</code> 变量实际上指向任何这个方法调用之前的东西，而不是 <code>.subst</code> 正则表达式中的捕获。所以我们怎么来修正它呢？</p>
</div>
<div class="paragraph">
<p><code>.subst</code> 方法的第二个参数也可以接受一个 <a href="http://docs.raku.org/type/Callable">Callable</a>。在它里面，你可以使用 <code>$0</code>, <code>$1</code>, &#8230;&#8203; <code>$n</code> 变量，直到你想要的编号，并从捕获中得到正确的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 'meowmix'.subst: /me (.+)/, -&gt; { "c$0" };

# OUTPUT:
# cowmix</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，我们为我们的 <strong>Callable</strong> 使用了 <code>&#8594; { &#8230;&#8203; }</code> 尖号块儿，但是 <strong>WhateverCode</strong> 和子例程也有效。每次替换都会调用这个 Callable，并且把 <a href="hhttp://docs.raku.org/type/Match">Match</a> 对象作为第一个位置参数传递给 Callable， 如果你需要访问它的话。</p>
</div>
</div>
<div class="sect3">
<h4 id="trues"><a class="anchor" href="#trues"></a>2.5.2. S///</h4>
<div class="paragraph">
<p><code>S///</code> 操作符在 Raku 中是 <code>s///</code> 操作符的战友，它不是修改原来的字符串，而是拷贝原来的字符串，修改，然后返回修改过的版本。</p>
</div>
<div class="paragraph">
<p>我们知道了 <code>S///</code> 总是作用在 <code>$<em></code> 上并且返回替换后的结果，很容易就想到几种方法把 <code>$</em></code> 设置为我们原来的字符串并把 <code>S///</code> 的返回值收集回来，我们来看几个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $orig = 'meowmix';
my $new  = S/me/c/ given $orig;
say $orig;
say $new;

my @orig = &lt;meow cow sow vow&gt;;
my @new  = do for @orig { S/\w+ &lt;?before 'ow'&gt;/w/ };
say @orig;
say @new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">meowmix
cowmix
[meow cow sow vow]
[wow wow wow wow]</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个作用在单个值上。我们使用后置形式的 <code>given</code> 块儿，这让我们避免了花括号（你可以使用 <code>with</code> 代替 <code>given</code> 得到同样的结果）。<code>given $orig</code> 会给 <code>$orig</code> 起个叫做 <code>$_</code> 的别名。从输出来看，原字符串没有被更改。</p>
</div>
<div class="paragraph">
<p>第二个例子作用在数组中的一堆字符串身上并且我们使用 <code>do</code> 关键字来执行常规的 <code>for</code> 循环(那种情况下，它把循环变量别名给 <code>$_</code> 了)并把结果赋值给 <code>@new</code> 数组。再次，输出显示原来的数组并没有发生改变。</p>
</div>
</div>
<div class="sect3">
<h4 id="true带副词的-s"><a class="anchor" href="#true带副词的-s"></a>2.5.3. 带副词的 S</h4>
<div class="paragraph">
<p><code>S///</code> 操作符&#8201;&#8212;&#8201;就像 <code>s///</code> 操作符和某些方法一样&#8201;&#8212;&#8201;允许你使用正则表达式副词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'Lörem Ipsum Dolor Sit Amet' {
    say S:g      /m/g/;  # Löreg Ipsug Dolor Sit Aget
    say S:i      /l/b/;  # börem Ipsum Dolor Sit Amet
    say S:ii     /l/b/;  # Börem Ipsum Dolor Sit Amet
    say S:mm     /o/u/;  # Lürem Ipsum Dolor Sit Amet
    say S:nth(2) /m /g/; # Lörem Ipsug Dolor Sit Amet
    say S:x(2)   /m /g/; # Löreg Ipsug Dolor Sit Amet
    say S:ss/Ipsum Dolor/Gipsum\nColor/; # Lörem Gipsum Color Sit Amet
    say S:g:ii:nth(2) /m/g/;             # Lörem Ipsug Dolor Sit Amet
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，它们以 <code>:foo</code> 的形式添加在操作符 <strong>S</strong> 这个部件的后面。你可以大大方方地使用空白符号并且几个副词可以同时使用。下面是它们的意义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>:g —(长形式：:global)全局匹配：替换掉所有的出现</p>
</li>
<li>
<p>:i —不区分大小写的匹配</p>
</li>
<li>
<p>:ii —(长形式： :samecase) 保留大小写：不管用作替换字母的大小写，使用原来被替换的字母的大小写</p>
</li>
<li>
<p>:mm —(长形式：:samemark) 保留重音符号：在上面的例子中，字母 o 上的分音符号被保留并被应用到替换字母 u 上</p>
</li>
<li>
<p>:nth(n) —只替换第 n 次出现的</p>
</li>
<li>
<p>:x(n) —至多替换 n 次（助记符: 'x' 作为及时）</p>
</li>
<li>
<p>:ss —(长形式：samespace)保留空白类型：空白字符的类型被保留，而不管替换字符串中使用的是什么空白字符。在上面的例子中，我们使用换行作为替换，但是原来的空白被保留了。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符串操作"><a class="anchor" href="#true字符串操作"></a>2.6. 字符串操作</h3>
<div class="sect3">
<h4 id="truesplit"><a class="anchor" href="#truesplit"></a>2.6.1. split</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'fun,handy,scalable'.split(',')</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truejoin"><a class="anchor" href="#truejoin"></a>2.6.2. join</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">["fun", "handy", "scalable"].join(",")</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">fun,handy,scalable</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truetrans"><a class="anchor" href="#truetrans"></a>2.6.3. trans</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.trans: 'ae' =&gt; 'AE' # lEArnAblE</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueflip"><a class="anchor" href="#trueflip"></a>2.6.4. flip</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.flip # elbanrael</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truetrim-chomp"><a class="anchor" href="#truetrim-chomp"></a>2.6.5. trim chomp</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'  learnable'.trim-leading.perl  # "learnable"
'learnable  '.trim-trailing.perl # "learnable"
'  learnable  '.trim.perl        # "learnable"
"learnable\n".chomp.perl         # "learnable"
"learnable".chop.perl            # "learnabl"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符串位置"><a class="anchor" href="#true字符串位置"></a>2.7. 字符串位置</h3>
<div class="sect3">
<h4 id="trueindices"><a class="anchor" href="#trueindices"></a>2.7.1. indices</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.indices('l') # (0 7)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueindex"><a class="anchor" href="#trueindex"></a>2.7.2. index</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.index('l') # 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truerindex"><a class="anchor" href="#truerindex"></a>2.7.3. rindex</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.rindex('l') # 7</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truestarts-with"><a class="anchor" href="#truestarts-with"></a>2.7.4. starts-with</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.starts-with('learn') # True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueends-with"><a class="anchor" href="#trueends-with"></a>2.7.5. ends-with</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.ends-with('able') # True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truepred-succ"><a class="anchor" href="#truepred-succ"></a>2.7.6. pred succ</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符串转换"><a class="anchor" href="#true字符串转换"></a>2.8. 字符串转换</h3>
<div class="sect3">
<h4 id="truelines"><a class="anchor" href="#truelines"></a>2.8.1. lines</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"fun\nhandy\nscalable\nlearnable".lines.perl</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">("fun", "handy", "scalable", "learnable").Seq</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truewords"><a class="anchor" href="#truewords"></a>2.8.2. words</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'fun handy scalable learnable'.words.perl</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">("fun", "handy", "scalable", "learnable").Seq</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truecontains"><a class="anchor" href="#truecontains"></a>2.8.3. contains</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.contains('able') # True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truematch"><a class="anchor" href="#truematch"></a>2.8.4. match</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'learnable'.match('able')
'learnable'.match(/able/)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueindent"><a class="anchor" href="#trueindent"></a>2.8.5. indent</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">('fun','handy','scalable','learnable')».indent(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">( fun  handy  scalable  learnable)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueuc-lc-tc-fc-tclc-wordcase"><a class="anchor" href="#trueuc-lc-tc-fc-tclc-wordcase"></a>2.8.6. uc lc tc fc tclc wordcase</h4>
<div class="listingblock">
<div class="title">script</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'fun'.uc
'FUN'.lc
'fun'.tc
'Fun'.fc
'fun Handy'.tclc
'fun Handy'.wordcase</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符串引用插值"><a class="anchor" href="#true字符串引用插值"></a>2.9. 字符串引用/插值</h3>
<div class="sect3">
<h4 id="true多行文本"><a class="anchor" href="#true多行文本"></a>2.9.1. 多行文本</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $string = q:to/THE END/;
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
THE END

say $str</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true数字"><a class="anchor" href="#true数字"></a>3. 数字</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true有理数"><a class="anchor" href="#true有理数"></a>3.1. 有理数</h3>

</div>
<div class="sect2">
<h3 id="trueint"><a class="anchor" href="#trueint"></a>3.2. Int</h3>

</div>
<div class="sect2">
<h3 id="truenum"><a class="anchor" href="#truenum"></a>3.3. Num</h3>

</div>
<div class="sect2">
<h3 id="truebigint"><a class="anchor" href="#truebigint"></a>3.4. BigInt</h3>

</div>
<div class="sect2">
<h3 id="truefat"><a class="anchor" href="#truefat"></a>3.5. Fat</h3>

</div>
<div class="sect2">
<h3 id="truefatrat"><a class="anchor" href="#truefatrat"></a>3.6. FatRat</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="true数组"><a class="anchor" href="#true数组"></a>4. 数组</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true数组字面量"><a class="anchor" href="#true数组字面量"></a>4.1. 数组字面量</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @primes = (2,3,5,7,11,13,17,19,23);   # an array gets filled like in Perl 5
my @primes =  2,3,5,7,11,13,17,19,23 ;   # 同样的事情, 不需要圆括号
my @primes = &lt;2 3 5 7 11 13 17 19 23&gt;;   # 同样, &lt;&gt; 等价于 qw()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true数组切片"><a class="anchor" href="#true数组切片"></a>4.2. 数组切片</h3>

</div>
<div class="sect2">
<h3 id="true禅切"><a class="anchor" href="#true禅切"></a>4.3. 禅切</h3>

</div>
<div class="sect2">
<h3 id="true多维数组"><a class="anchor" href="#true多维数组"></a>4.4. 多维数组</h3>

</div>
<div class="sect2">
<h3 id="truemap"><a class="anchor" href="#truemap"></a>4.5. map</h3>
<div class="listingblock">
<div class="title">map</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @array = 1,3,5,7,9;

my @arrayplus3 = map( *+3, @array);
say @arrayplus3;

my @arrayplusab = map( *+*+3, @array,11);
say @arrayplusab;</code></pre>
</div>
</div>
<div class="listingblock raku">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @rray=17,21,34,47,58,69;

say 'the array has element' if  ? @rray;   # boolean context, Bool::True if array has any value in it, even if its a 0
say 'the array has ',+ @rray ~' element';  # numeric context, number of elements (like in Perl 5 scalar @a)
say ~ @rray;              # string context, you get content of all cells, stringified and joined, same as "@primes[]"

say @rray.elems;          # same as + @rray
say @rray.end;            # number of the last element, equal to @rray.elems-1, # 5
# say @rray.cat;          # same ~ @rray
say @rray.join('-');      # also same result, you can put another string as parameter that gets between all values
say @rray.unshift(7);     # prepend one value to the array, # 7 1 2 3 4 5 6
say @rray.shift;          # remove the first value and return it # 7
say @rray.push(8);        # add one value on the end # 1 2 3 4 5 6 8
say @rray.pop;            # remove one value from the end and return it # 8

my $n=2;
my $pos=1;
my @ind=0..3;
say @rray.splice($pos,$n);# remove on $pos $n values and replace them with values that follow that two parameter
say @rray:delete(@ind);   # delete all cell with indecies of @ind # 1 4 5 6
say @rray:exists(@ind);   # Bool::True if all indecies of @ind have a value (can be 0 or '')

say '-' x 18;
say @rray;
say @rray.pick([$n]);     # return $n (default is 1) randomly selected values, without duplication
say @rray.roll([$n]);     # return $n (default is 1) randomly selected values, duplication possible (就像掷筛子)
say @rray.reverse;        # all elements in reversed order
say @rray.rotate(-$n);    # returns a list where $n times first item is taken to last position if $n is positive, if negative the other way around
# @rray.sort($coderef); # returns a sorted list by a userdefined criteria, default is alphanumerical sorting
say @rray.min;            # numerical smallest value of that array
say @rray.max;            # numerical largest value of that array
my ($a,$b)= @rray.minmax;  # both at once, like in .sort . min or .max a sorting algorith can be provided
say $a,"   $b";
# @rray.map($coderef);  # high oder map function, runs $coderef with every value as $_ and returns the list or results
# @rray.classify($cr);  # kind of map, but creates a hash, where keys are the results of $cr and values are from @rray
# @rray.categorize($cr);# kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values
say @rray.grep({$_&gt;40});   # high order grep, returns only these elements that pass a condition ($cr returns something positive)
# @rray.first($coder);  # kind of grep, return just the first matching value
# say @rray.zip;            # join arrays by picking first element left successively from here and then there</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my  @primes=&lt;1 3 5 7 9 11 13 15 17&gt;;
say @primes;                       # all values as list
say @primes.values;                # same thing
say @primes.keys;                  # list of all indices
say "@primes[]";                   # insert all values in a string, uses [] as distinction from mail adresses
my  $prime = @primes[0];           # get the first prime
say $prime;

my $last_prime = @primes[*-1];    # get the last one
say $last_prime;

my @some = @primes[2..5];         # get several
say @some;

my @data   = [1..5],[6..10],[11..15];  # Array of Arrays (AoA)
my $cell = @data[1][2];                # get 8, third value of second value (list)
say $cell;

my  $same_cell = @data[1,2];           # same thing, shorten syntax
say $same_cell;                        # 6 7 8 9 10 11 12 13 14 15

my @numbers = @data[1];                # get a copy of the second subarray (6..10)
say @numbers;
my @copy = @data;                      # copy the whole AoA, no more reference passing, use binding instead
say @copy.perl;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @original = [1,2],[3,4];
say @original.perl;
my $copy = @original[0]; # $copy points to [1,2]
say $copy;
@original[0][0] = 'fresh stuff'; # $copy[0] holds still 1
say @original;
say $copy;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueclassify"><a class="anchor" href="#trueclassify"></a>4.6. classify</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @names = &lt;Patrick Jonathan Larry Moritz Audrey&gt;;
say .key, "\t", ~.values
    for @names.classify( *.chars );  # 根据字符串的字符个数分类</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">7	Patrick
8	Jonathan
5	Larry
6	Moritz Audrey</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say @primes[];                           # 2 3 5 7 11 13 17 19 23
my $arrayref = [2,3,5,7,11,13,17,19,23]; # in scalar context you get automatically a reference
say @$arrayref;                          # 2 3 5 7 11 13 17 19 23

my $arrayref = item @primes;             # same thing, more explicit
say $arrayref;

my $arrayref = [13,];                    # comma is the new array generator
say $arrayref;

my @primes = 2;                          # array with one element
my @primes = [2,3,5,7,11,13,17,19,23];   # array with one element (arrayref)
say @primes;                             # 2 3 5 7 11 13 17 19 23

my @dev    = {'dan' =&gt; 'parrot'};        # array with one element (hashref)
say @dev;                                # ("dan" =&gt; "parrot").hash


my @data   = [1..5],[6..10],[11..15];    # Array of Arrays (AoA)
say @data.perl;                          # Array.new([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15])

# my @list   = lol @data;                # no change
# say @list.perl;
my @list   = flat @data;                 # returns 1..15
say @list;                               # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true找出列表中最大值的索引"><a class="anchor" href="#true找出列表中最大值的索引"></a>4.7. 找出列表中最大值的索引</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @list = 1,2,9,6,9,5;
@list.maxpairs; # [2 =&gt; 9 4 =&gt; 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@list.maxpairs</code> 用于获取索引和对应最大值的所有对儿。
<code>@list.pairs.max(*.value).key</code> 用于仅获取单个索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@list.pairs.max(*.value).key; # 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true比较字符串长度"><a class="anchor" href="#true比较字符串长度"></a>4.8. 比较字符串长度</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># quote words, but with quote protection!
my @strings = qww/
    "This is a line"
    short
    "A very very long string maybe, certainly the longest"
    other
    not
    this
    a
    one
    or
    even
    1
    /;

my $longest = @strings.max: *.chars ;
say $longest;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true副词"><a class="anchor" href="#true副词"></a>4.9. 副词</h3>

</div>
<div class="sect2">
<h3 id="true-rotor-强大的列表操作工具"><a class="anchor" href="#true-rotor-强大的列表操作工具"></a>4.10. <code>.rotor</code> - 强大的列表操作工具</h3>
<div class="sect3">
<h4 id="true分段"><a class="anchor" href="#true分段"></a>4.10.1. 分段</h4>
<div class="paragraph">
<p>最简单的, <code>.rotor</code> 接收一个整数<strong>$number</strong>并把列表分成多个子列表, 每个子列表含有 <strong>$number</strong> 个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say &lt;a b c d e f  g h&gt;.rotor: 3
# ((a b c) (d e f))</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有一个含有 8 个元素的列表, 我们在该列表上调用接收参数 3 的 <code>.rotor</code> 方法, 它返回 2 个列表, 每个列表中含有 3 个元素。不包括原列表中的最后 2 个元素, 因为它们没有组成一个完整的3个元素的列表。然而它们可以被包含进来, 使用 <code>:partial</code> 具名参数设置为 <strong>True</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say &lt;a b c  d e f  g h&gt;.rotor: 3, :partial
say &lt;a b c  d e f  g h&gt;.rotor: 3, :partial(True)
say &lt;a b c  d e f  g h&gt;.rotor: 3, :partial(False)</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">((a b c) (d e f) (g h))
((a b c) (d e f) (g h))
((a b c) (d e f))</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面应用一下我们刚刚学到的。把字符串分成列宽相等的几段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"foobarberboorboozebazmeow".comb.rotor(10, :partial)».join».say</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">foobarberb
oorboozeba
zmeow</code></pre>
</div>
</div>
<div class="paragraph">
<p>分行然后每行前面添加 4 个空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"foobarberboorboozebazmeow".comb.rotor(10, :partial)».join».indent(4)».say</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">    foobarberb
    oorboozeba
    zmeow</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是这最好被写为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"foobarberboorboozebazmeow".comb(10)».say</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true缝隙"><a class="anchor" href="#true缝隙"></a>4.10.2. 缝隙</h4>
<div class="paragraph">
<p>假设你正在接受输入: 你得到一个单词, 它的法语翻译和它的西班牙语翻译, 等一堆单词。你只想输出特定语言, 所以我们需要在我们的列表中跳过某些项。 <code>.rotor</code> 来拯救来了!</p>
</div>
<div class="paragraph">
<p>指定一对儿(Pair)整数作为 rotor 的参数会让每个列表中含有 <strong>$key</strong> 个元素, 每个列表之间有 <strong>$value</strong> 个空隙。看例子更简单一些:</p>
</div>
<div class="listingblock">
<div class="title">partial</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say ^10 .rotor: 3 =&gt; 1, :partial;
say ^10 .rotor: 2 =&gt; 2, :partial;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">((0 1 2) (4 5 6) (8 9))
((0 1) (4 5) (8 9))</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个例子我们把缝隙设置为 1, 第二个例子我们把缝隙增加为 2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">enum &lt;English French Spanish&gt;;
say join " ", &lt;Good Bon Buenos morning matin días&gt;[French..*].rotor: 1 =&gt; 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Bon matin</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>[French..<strong>]</code> 意思为 <code>[1..</strong>]</code>, 例子中 French 被枚举化为整数 1。</p>
</div>
</div>
<div class="sect3">
<h4 id="true重叠"><a class="anchor" href="#true重叠"></a>4.10.3. 重叠</h4>
<div class="paragraph">
<p>当我们让缝隙变为负数的时候, 分段的列表中就会有元素重叠:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say &lt;a a b c c c d&gt;.rotor: 2 =&gt; -1;
say &lt;a a b c c c d&gt;.rotor(2 =&gt; -1).map: {$_[0] eq $_[1] ?? "same" !! "different"};</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">((a a) (a b) (b c) (c c) (c c) (c d))
(same different different same same different)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true全力以赴"><a class="anchor" href="#true全力以赴"></a>4.10.4. 全力以赴</h4>
<div class="paragraph">
<p><code>.rotor</code> 不单单只能接受单个 <strong>Int</strong> 值或 <strong>Pair</strong>, 你可以指定额外的 <strong>Int</strong> 或 <strong>Pairs</strong> 位置参数来把列表分成不同尺寸大小的子列表, 列表之间的缝隙也不同。下面以一个日志文件为例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">IP: 198.0.1.22
Login: suser
Time: 1454017107
Resource: /report/accounting/x23gs
Input: x=42,y=32
Output: success
===================================================
IP: 198.0.1.23
Login: nanom
Time: 1454027106
Resource: /report/systems/boot
Input: mode=standard
Output: success</code></pre>
</div>
</div>
<div class="paragraph">
<p>每段之间有一行双划线。</p>
</div>
<div class="paragraph">
<p>我们想这样输出: <strong>Header</strong> 里包含 IP, Login, Time, Resource; <strong>Operation</strong> 里包含 Resource, Input, Output。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for 'report.txt'.IO.lines».indent(4).rotor( 4 =&gt; -1, 3 =&gt; 1 ) -&gt; $head, $op {
    .say for "Header:",    |$head,
             "Operation:", |$op, '';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Header:
    IP: 198.0.1.22
    Login: suser
    Time: 1454017107
    Resource: /report/accounting/x23gs
Operation:
    Resource: /report/accounting/x23gs
    Input: x=42,y=32
    Output: success

Header:
    IP: 198.0.1.23
    Login: nanom
    Time: 1454027106
    Resource: /report/systems/boot
Operation:
    Resource: /report/systems/boot
    Input: mode=standard
    Output: success</code></pre>
</div>
</div>
<div class="paragraph">
<p>先是 4 个元素一块, 缝隙为 -1(有重叠), 然后是 3 个元素一块, 缝隙为 1。这就在每个分段的列表中包含了 Resource 字段。因为 <code>$op</code> 和 <code>$head`是列表, 我们使用管道符号 `|</code> 来展平列表。</p>
</div>
<div class="paragraph">
<p>记住, 你提供给 <code>.rotor</code> 方法的模式可以动态地生成! 这儿我们使用 sin 函数来生成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say ^92 .rotor(
    (0.2, 0.4 ... 3).map: (10 * *.sin).Int # pattern we supply to .rotor
).join: "\n"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">0
1 2 3
4 5 6 7 8
9 10 11 12 13 14 15
16 17 18 19 20 21 22 23
24 25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40 41
42 43 44 45 46 47 48 49 50
51 52 53 54 55 56 57 58 59
60 61 62 63 64 65 66 67 68
69 70 71 72 73 74 75 76
77 78 79 80 81 82
83 84 85 86 87
88 89 90
91</code></pre>
</div>
</div>
<div class="paragraph">
<p>再举个例子:</p>
</div>
<div class="paragraph">
<p>我现在想要将同类的序列（字符串）进行合并，比如有这样一个文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">&gt;seq-1A
GACACAGTCACCCGAGCCT
&gt;seq-1B
TCAATCAATACTGAAGCGA
&gt;seq-1C
AAAACTAGTCGAGAAGAGAG
&gt;seq-1D
CGTGGAAAACTCCAG
&gt;seq-2A
TAAAAGGCGTTCATTGGATATTTC
&gt;seq-2B
ACTGGCAGTGCATCC</code></pre>
</div>
</div>
<div class="paragraph">
<p>我想要进行合并 得到这样的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">&gt;seq-1
GACACAGTCACCCGAGCCTTCAATCAATACTGAAGCGAAAAACTAGTCGAGAAGAGAGCGTGGAAAACTCCAG
&gt;seq-2
TAAAAGGCGTTCATTGGATATTTCACTGGCAGTGCATCC</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 rotor 来实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %re;
for 'input.txt'.IO.lines».rotor(2, :partial) -&gt; $header, $data {
    my $key = $header;
    $key ~~ s/&lt;upper&gt;$//;
    %re{$key} ~= $data;
}

for %re.kv -&gt; $key, $value {
    say "$key\n$value";
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true散列"><a class="anchor" href="#true散列"></a>5. 散列</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true散列操作"><a class="anchor" href="#true散列操作"></a>5.1. 散列操作</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %dev      = 'pugs'=&gt;'audreyt', 'pct'=&gt;'pm', "STD"=&gt;'larry';
my %same_dev = :rakudo('jnthn'), :testsuite('moritz');                      # 副词 (pair) 语法同样有效
my %too_dev  = ('audreyt', 'pugs', 'pm', 'pct', 'larry', "STD");            # 在散列上下文中列表被自动转换
my %compiler = Parrot =&gt; {Rakudo =&gt; 'jnthn'}, SMOP =&gt; {Mildew =&gt; 'ruoso'};  # 散列的散列 (HoH)

# 散列切片
my $name='pugs';
my $value  = %dev{'pugs'};      # just give me the value related to that key, like in P5
my $value1 = %dev&lt;STD&gt;;         # &lt;&gt; 自动引起
my $value2 = %dev&lt;&lt;$name&gt;&gt;;     # same thing, just with eval

my @values = %dev{'pugs', 'STD'};
my @values2 = %dev&lt;pugs STD&gt;;
my @values3 = %dev&lt;&lt;pugs STD $name&gt;&gt;;

say %compiler&lt;Parrot&gt;&lt;Rakudo&gt;; # 散列的散列中的值, 返回 'jnthn'
say %compiler&lt;SMOP&gt;;           # 返回 Pair: Mildew =&gt; 'ruoso'

# %dev   {'audrey'};        # 错误, 变量名和花括号(后环缀运算符)之间的空格不再被允许
say %dev\  {'pugs'};        # 有效, unspace the space
# %dev   .&lt;dukeleto&gt;;       # 错误
say %dev\ .{'pugs'};        # 也有效, "long dot style", because its its an object in truth
say %dev.{'pugs'};


# Hash 方法
say ? %dev;                    # bool 上下文, 如果该散列有任何 pair 对儿则为真
say  + %dev;                   # numeric  上下文, 返回 pair 对儿的个数
say ~ %dev;                    # string 上下文, 使用 \t 和 \n 格式化良好的含有2列的表



say %dev.pairs;                # "pugs" =&gt; "audreyt" "pct" =&gt; "pm" "STD" =&gt; "larry"
say %dev.antipairs;            # "larry" =&gt; "STD" "pm" =&gt; "pct" "audreyt" =&gt; "pugs"
say %dev.elems;                # 和 + %dev 或 + %dev.pairs 一样  # 3
say %dev.keys;                 # 返回一个包含所有键的列表
say %dev.values;               # 返回一个包含所有值的列表
say %dev.kv;                   # 展平为 key1, value1, key 2 ...
say %dev.invert;               # 反转所有键 =&gt; 值关系

my  @pairs = %dev;
say @pairs;                    # "pugs" =&gt; "audreyt" "pct" =&gt; "pm" "STD" =&gt; "larry"
say %dev.push(@pairs);         # 插入一组 pair 对儿, 如果某个键已经出现在了 %dev 里, 那么该键的俩个值都会被添加到数组里
# ("pugs" =&gt; ["audreyt", "audreyt"], "pct" =&gt; ["pm", "pm"], "STD" =&gt; ["larry", "larry"]).hash</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true散列解构"><a class="anchor" href="#true散列解构"></a>5.2. 散列解构</h3>
<div class="paragraph">
<p>你可以解构散列, 解构的语法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">%hash (:$key, :$value)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">%hash (:key($variable-to-store-value-in))</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你只对所要提取的值感兴趣, 那么散列甚至可以是匿名的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub key-of(% (:value($val), :qua($qua))) {
  say "Got val $val, $qua times.";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># Then call it with a hash: (you need to keep the brackets for it to be a hash)
key-of({value =&gt; 'foo', qua =&gt; 1});
my %hash = value =&gt; 'Raku', qua =&gt; '2019';
key-of(%hash); # the same (for an equivalent `%hash`);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true散列副词"><a class="anchor" href="#true散列副词"></a>5.3. 散列副词</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="true控制语句"><a class="anchor" href="#true控制语句"></a>6. 控制语句</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truefor"><a class="anchor" href="#truefor"></a>6.1. for</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">.say for @list</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewhen"><a class="anchor" href="#truewhen"></a>6.2. when</h3>

</div>
<div class="sect2">
<h3 id="truegathertake"><a class="anchor" href="#truegathertake"></a>6.3. gather/take</h3>
<div class="paragraph">
<p><code>gather</code> 是一个语句或者能返回一序列值的 block 前缀。该值来自于 gather 块中的动态作用域的 take 调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $a = gather {
    take 1;
    take 5;
    take 42;
}
say join ', ', @$a;          # 1, 5, 42</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gather/take</code> 能根据上下文按需(惰性地)生成值。如果你想强制惰性求值则使用 <code>lazy</code> 子例程或方法。绑定到一个标量或无符号的容器上也会强制惰性求值。
举个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @vals = lazy gather {
    take 1;
    say "Produced a value";
    take 2;
}
say @vals[0];
say 'between consumption of two values';
say @vals[1];

# OUTPUT:
# 1
# between consumption of two values
# Produced a value
# 2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gather/take</code> 是动态作用域的, 所以你可以从 gather 内部所调用的 subs 或方法中调用 take:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub weird(@elems, :$direction = 'forward') {
    my %direction = (
        forward  =&gt; sub { take $_ for @elems },
        backward =&gt; sub { take $_ for @elems.reverse },
        random   =&gt; sub { take $_ for @elems.pick(*) },
    );
    return gather %direction{$direction}();
}

say weird(&lt;a b c&gt;, :direction&lt;backward&gt; );          # (c b a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果值需要在调用者这边可变, 那么使用 <a href="https://docs.raku.org/type/Mu#routine_take-rw">take-rw</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a = 1...3;
sub f(@list){ gather for @list { take-rw $_ } };
for f(@a) { $_++ };
say @a; # OUTPUT«[2 3 4]»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truegatherfor"><a class="anchor" href="#truegatherfor"></a>6.4. gather/for</h3>
<div class="listingblock">
<div class="title">gather for</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"] ;
my @all = ["Mallard", "Hook Bill", "African", "Crested", "Pilgrim","Toulouse", "Blue Swedish"];
my @r = gather for @all -&gt; $a {
    take $a if $a !(elem) @geese;
}

say @r;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueuntil"><a class="anchor" href="#trueuntil"></a>6.5. until</h3>

</div>
<div class="sect2">
<h3 id="truerepeat"><a class="anchor" href="#truerepeat"></a>6.6. repeat</h3>

</div>
<div class="sect2">
<h3 id="truedo"><a class="anchor" href="#truedo"></a>6.7. do</h3>

</div>
<div class="sect2">
<h3 id="trueif"><a class="anchor" href="#trueif"></a>6.8. if</h3>

</div>
<div class="sect2">
<h3 id="trueunless"><a class="anchor" href="#trueunless"></a>6.9. unless</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="trueraku-中的函数"><a class="anchor" href="#trueraku-中的函数"></a>7. Raku 中的函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>例程（Routines）是 Raku 中代码重用的最小手段。它们有几种形式，最明显的是属于类和角色并与对象相关联的方法，还有<a href="https://docs.raku.org/language/functions">函数</a>, 也叫做子例程或短子程序，它们独立于对象而存在。</p>
</div>
<div class="paragraph">
<p>子例程默认是词法（<code>my</code>）作用域的，对它们的调用通常在编译时解析。</p>
</div>
<div class="paragraph">
<p>子例程可以具有<a href="https://docs.raku.org/type/Signature">签名</a>，也称为<strong>参数列表</strong>，其指定签名期望的参数（如果有的话）。 它可以指定（或保持打开）参数的数量和类型，以及返回值。</p>
</div>
<div class="paragraph">
<p>子例程的内省通过<a href="https://docs.raku.org/type/Routine">例程</a>提供。</p>
</div>
<div class="sect2">
<h3 id="true子例程"><a class="anchor" href="#true子例程"></a>7.1. 子例程</h3>
<div class="paragraph">
<p>创建子例程的基本方法是使用 <code>sub</code> 声明符，后跟可选<a href="https://docs.raku.org/language/syntax#Identifiers">标识符</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub my-func { say "Look ma, no args!" }
my-func;</code></pre>
</div>
</div>
<div class="paragraph">
<p>sub 声明符返回可以存储在任何容器中的  <a href="https://docs.raku.org/type/Sub">Sub</a> 类型的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my &amp;c = sub { say "Look ma, no name!" }
c;     # OUTPUT: «Look ma, no name!␤»

my Any:D $f = sub { say 'Still nameless...' }
$f();  # OUTPUT: «Still nameless...␤»

my Code \a = sub { say ‚raw containers don't implement postcircumfix:&lt;( )&gt;‘ };
a.();  # OUTPUT: «raw containers don't implement postcircumfix:&lt;( )&gt;␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sub</code> 声明符将在编译时在当前作用域内声明一个新名称。因此，任何间接性都必须在编译时解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">constant aname = 'foo';
sub ::(aname) { say 'oi‽' };
foo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦将宏添加到 Raku 中，这将变得更有用。</p>
</div>
<div class="paragraph">
<p>为了使子程序接受参数， <a href="https://docs.raku.org/type/Signature">签名</a>被放置在子例程名称和它的函数主体之间，在括号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub exclaim ($phrase) {
    say $phrase ~ "!!!!"
}
exclaim "Howdy, World";</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认地, 子例程是 <a href="https://docs.raku.org/syntax/my">词法作用域</a>的。即 <code>sub foo {&#8230;&#8203;}</code> 和 <code>my sub foo {&#8230;&#8203;}</code> 是相同的并且只被定义在当前作用域中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub escape($str) {
    # Puts a slash before non-alphanumeric characters
    S:g[&lt;-alpha -digit&gt;] = "\\$/" given $str
}

say escape 'foo#bar?'; # foo\#bar\?

{
    sub escape($str) {
        # Writes each non-alphanumeric character in its hexadecimal escape
        S:g[&lt;-alpha -digit&gt;] = "\\x[{ $/.ord.base(16) }]" given $str
    }

    say escape 'foo#bar?' # foo\x[23]bar\x[3F]
}

# Back to original escape function
say escape 'foo#bar?'; # foo\#bar\?</code></pre>
</div>
</div>
<div class="paragraph">
<p>子例程不必命名; 这种情况下, 它们被叫做匿名的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say sub ($a, $b) { $a ** 2 + $b ** 2 }(3, 4) # 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>但在这种情况下，通常希望使用更简洁的块语法。可以就地调用子例程和块，如上例所示。</p>
</div>
</div>
<div class="sect2">
<h3 id="trueblocks-和-lambdas"><a class="anchor" href="#trueblocks-和-lambdas"></a>7.2. Blocks 和 Lambdas</h3>
<div class="paragraph">
<p>每当你看到像</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">{ $_ + 42 }, -&gt; $a, $b { $a ** $b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">{ $^text.indent($:spaces) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么这是 <a href="https://docs.raku.org/type/Block">块</a>语法。 它在每个 <code>if</code>，<code>for</code>，<code>while</code> 等关键字之后使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for 1, 2, 3, 4 -&gt; $a, $b {
    say $a ~ $b;
}
# OUTPUT: «12␤34␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们也可以作为匿名代码块自己使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say { $^a ** 2 + $^b ** 2}(3, 4) # 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关块语法的详细信息，请参阅 <a href="https://docs.raku.org/type/Block">块</a>类型的文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="true签名"><a class="anchor" href="#true签名"></a>7.3. 签名</h3>
<div class="paragraph">
<p>函数接受的参数在其签名中有描述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub format(Str $s) { ... }
-&gt; $a, $b { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关签名的语法和使用的详细信息，请参阅  <a href="https://docs.raku.org/type/Signature">Signature</a> 类的文档。</p>
</div>
<div class="sect3">
<h4 id="true自动签名"><a class="anchor" href="#true自动签名"></a>7.3.1. 自动签名</h4>
<div class="paragraph">
<p>如果没有提供签名，但在函数体中使用了两个自动变量 <code>@_</code> 或 <code>%_</code> 中的任何一个，则将生成带有 <code>*@_</code> 或 <code>%_</code> 的签名。 两个自动变量可以同时使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub s { say @_, %_ };
dd &amp;s.signature # OUTPUT«:(*@_, *%_)␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true参数"><a class="anchor" href="#true参数"></a>7.3.2. 参数</h4>
<div class="paragraph">
<p>参数以逗号分隔列表的形式提供。 要消除嵌套调用的歧义, 可以使用圆括号或副词形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(&amp;c){ c() * 2 }; # call the function reference c with empty parameter list
sub g($p){ $p - 2 };
say(g(42)); # nest call to g in call to say
f: { say g(666) }; # call f with a block</code></pre>
</div>
</div>
<div class="paragraph">
<p>当调用函数时，位置参数应该以与函数签名相同的顺序提供。 命名参数可以以任何顺序提供，但是最好将命名参数放在位置参数之后。 在函数调用的参数列表中，支持一些特殊的语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(|c){};
f :named(35);     # 具名参数(in "adverb" form.)
f named =&gt; 35;    # 也是具名参数.
f :35named;       # 使用缩写的副词形式的具名参数
f 'named' =&gt; 35;  # 不是具名参数, 而是一个 Pair 位置参数
my \c = &lt;a b c&gt;.Capture;
f |c;             # Merge the contents of Capture $c as if they were supplied</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递给函数的参数在概念上首先被收集在 Capture 容器中。 关于这些容器的语法和使用的细节可以在  <a href="https://docs.raku.org/type/Capture">Capture</a> 类的文档中找到。</p>
</div>
<div class="paragraph">
<p>当使用命名参数时，请注意，正常的 List "pair-chaining" 允许在命名参数之间跳过逗号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(|c){};
f :dest&lt;/tmp/foo&gt; :src&lt;/tmp/bar&gt; :lines(512);
f :32x :50y :110z;   # This flavor of "adverb" works, too
f :a:b:c;            # The spaces are also optional.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true返回值"><a class="anchor" href="#true返回值"></a>7.4. 返回值</h3>
<div class="paragraph">
<p>任何块或例程将把它的最后一个表达式作为返回值提供给调用者。如果  <a href="https://docs.raku.org/language/control#return">return</a> 或 <a href="https://docs.raku.org/language/control#return-rw">return-rw</a> 被调用，它们的参数（如果有的话）将成为返回值。 默认返回值为 <a href="https://docs.raku.org/type/Nil">Nil</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub a { 42 };
sub b { say a };
b;
# OUTPUT«42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>多个返回值作为列表或通过创建 <a href="https://docs.raku.org/type/Capture">捕获</a>返回。 解构可以用于解开多个返回值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub a { 42, 'answer' };
put a.perl;
# OUTPUT«(42, "answer")␤»

my ($n, $s) = a;
put [$s, $n];
# OUTPUT«answer 42␤»

sub b { &lt;a b c&gt;.Capture };
put b.perl;
# OUTPUT«\("a", "b", "c")␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true返回类型约束"><a class="anchor" href="#true返回类型约束"></a>7.5. 返回类型约束</h3>
<div class="paragraph">
<p>Raku 有很多方式来指定函数的返回类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo(--&gt; Int)      {}; say &amp;foo.returns; # (Int)
sub foo() returns Int {}; say &amp;foo.returns; # (Int)
sub foo() of Int      {}; say &amp;foo.returns; # (Int)
my Int sub foo()      {}; say &amp;foo.returns; # (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试返回另外一种类型的值会引起编译错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo() returns Int { "a"; }; foo; # Type check fails</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，<code>Nil</code> 和 <code>Failure</code> 是免于返回类型约束，并且可以从任何子例程返回，而不管其约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo() returns Int { fail   }; foo; # Failure returned
sub bar() returns Int { return }; bar; # Nil returned</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true多重分派"><a class="anchor" href="#true多重分派"></a>7.6. 多重分派</h3>
<div class="paragraph">
<p>Raku 允许你使用同一个名字但是不同签名写出几个子例程。当子例程按名字被调用时, 运行时环境决定哪一个子例程是最佳匹配, 然后调用那个候选者。你使用 <code>multi</code> 声明符来声明每个候选者。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi congratulate($name) {
    say "祝你生日快乐, $name";
}

multi congratulate($name, $age) {
    say "祝 $age 岁生日快乐, $name";
}

congratulate 'Camelia'; # 祝你生日快乐, Camelia
congratulate 'Rakudo', 15; # 祝你 15 岁生日快乐, Rakudo</code></pre>
</div>
</div>
<div class="paragraph">
<p>分发/分派(dispatch) 可以发生在参数的数量(元数)上, 但是也能发生在类型上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi as-json(Bool $d) { $d ?? 'true' !! 'false' }
multi as-json(Real $d) { ~$d }
multi as-json(@d)      { sprintf '[%s]', @d.map(&amp;as-json).join(', ') }

say as-json([True, 42]); # [true, 42]</code></pre>
</div>
</div>
<div class="paragraph">
<p>不带任何指定例程类型的 <code>multi</code> 总是默认为 <code>sub</code>, 但是你也可以把 <code>multi</code> 用在方法(methods)上。那些候选者全都是对象的 <code>multi</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Congrats {
    multi method congratulate($reason, $name) {
        say "Hooray for your $reason, $name";
    }
}

role BirthdayCongrats {
    multi method congratulate('birthday', $name) {
        say "Happy birthday, $name";
    }
    multi method congratulate('birthday', $name, $age) {
        say "Happy {$age}th birthday, $name";
    }
}

my $congrats = Congrats.new does BirthdayCongrats;

$congrats.congratulate('升职', 'Cindy');   #-&gt; 恭喜你升职,Cindy
$congrats.congratulate('birthday', 'Bob'); #-&gt; Happy birthday, Bob</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueproto"><a class="anchor" href="#trueproto"></a>7.7. proto</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/syntax/proto">proto</a> 从形式上声明了 <code>multi</code> 候选者之间的 <code>共性</code>。 proto 充当作能检查但不会修改参数的包装器。看看这个基本的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">proto congratulate(Str $reason, Str $name, |) {*}
multi congratulate($reason, $name) {
   say "Hooray for your $reason, $name";
}
multi congratulate($reason, $name, Int $rank) {
   say "Hooray for your $reason, $name -- you got rank $rank!";
}

congratulate('being a cool number', 'Fred');     # OK
congratulate('being a cool number', 'Fred', 42); # OK
congratulate('being a cool number', 42);         # Proto match error</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的 <code>multi congratulate</code> 都会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 <code>|</code> 是一个未命名的 <code>Capture</code> 形参, 它允许 <code>multi</code> 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 <code>Str</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say &amp;congratulate.signature #-&gt; (Str $reason, Str $name, | is raw)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以给 <code>proto</code> 一个函数体, 并且在你想执行 dispatch 的地方放上一个 <code>{*}</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># attempts to notify someone -- returns False if unsuccessful
proto notify(Str $user,Str $msg) {
   my \hour = DateTime.now.hour;
   if hour &gt; 8 or hour &lt; 22 {
      return {*};
   } else {
      # we can't notify someone when they might be sleeping
      return False;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{*}</code> 总是分派给带有参数的候选者。默认参数和类型强制转换会起作用单不会传递。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">proto mistake-proto(Str() $str, Int $number = 42) {*}
multi mistake-proto($str,$number) { say $str.WHAT }
mistake-proto(7,42);   #-&gt; (Int) -- coercions not passed on
mistake-proto('test'); #!&gt; fails -- defaults not passed on</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true约定和惯用法"><a class="anchor" href="#true约定和惯用法"></a>7.8. 约定和惯用法</h3>
<div class="paragraph">
<p>虽然上面描述的调度系统提供了很多灵活性，但是存在一些大多数内部函数以及许多模块中的函数将遵循的约定。 这些将产生一致的外观和感觉。</p>
</div>
<div class="sect3">
<h4 id="true吞噬约定"><a class="anchor" href="#true吞噬约定"></a>7.8.1. 吞噬约定</h4>
<div class="paragraph">
<p>也许最重要的是处理 slurpy 列表参数的方式。 大多数时候，函数不会自动展平吞噬(slurpy)列表。 罕见的例外是在列表的列表上没有合理行为的那些函数（例如chrs），或者与已建立的习语有冲突的函数，例如  <a href="https://docs.raku.org/routine/pop">pop</a> 是 <a href="https://docs.raku.org/routine/push">push</a> 的逆操作。</p>
</div>
<div class="paragraph">
<p>如果你想匹配这个外观和感觉，任何可迭代(Iterable)参数必须使用 <code>**@slurpy</code> 逐个元素地打开，有两个细微差别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/containers#Scalar_containers">Scalar 容器</a>内的 Iterable 不计数。</p>
</li>
<li>
<p>在顶层使用 <code>,</code> 创建的列表只能计数为一个 Iterable。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可以通过使用带有 <code>+</code> 或 <code>+@</code> 而不是 <code>**</code> 的 slurpy 来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub grab(+@a) { "grab $_".say for @a }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这非常接近于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi sub grab(**@a) { "grab $_".say for @a }
multi sub grab(\a) {
    a ~~ Iterable and a.VAR !~~ Scalar ?? nextwith(|a) !! nextwith(a,)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致以下行为，称为「单参数规则」，并且理解什么时间调用 slurpy 函数很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grab(1, 2);      # grab 1 grab 2
grab((1, 2));    # grab 1 grab 2
grab($(1, 2));   # grab 1 2
grab((1, 2), 3); # grab 1 2 grab 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也使得用户请求的展平感觉一致，无论有没有子列表，或很多</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grab(flat (1, 2), (3, 4));   # grab 1 grab 2 grab 3 grab 4
grab(flat $(1, 2), $(3, 4)); # grab 1 2 grab 3 4
grab(flat (1, 2));           # grab 1 grab 2
grab(flat $(1, 2));          # grab 1 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，在这些情况下将绑定和无符号变量混合在一起需要一点技巧，因为在绑定期间没有使用 Scalar 中间人。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $a = (1, 2);  # Normal assignment, equivalent to $(1, 2)
grab($a);       # grab 1 2
my $b := (1, 2); # Binding, $b links directly to a bare (1, 2)
grab($b);       # grab 1 grab 2
my \c = (1, 2);  # Sigilless variables always bind, even with '='
grab(c);        # grab 1 grab 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true函数是一等对象"><a class="anchor" href="#true函数是一等对象"></a>7.8.2. 函数是一等对象</h4>
<div class="paragraph">
<p>函数和其他代码对象可以作为值传递，就像任何其他对象一样。</p>
</div>
<div class="paragraph">
<p>有几种方法来获取代码对象。 您可以在声明点将其赋值给变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $square = sub (Numeric $x) { $x * $x }
# and then use it:
say $square(6);    # 36</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以通过使用它前面的 <code>&amp;</code> 来引用现有的具名函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub square($x) { $x * $x };

# get hold of a reference to the function:
my $func = &amp;square</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于高阶函数非常有用，即，将其他函数作为输入的函数。 一个简单高阶函数的是  <a href="https://docs.raku.org/type/List#routine_map">map</a>，它对每个输入元素应用一个函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub square($x) { $x * $x };
my @squared = map &amp;square,  1..5;
say join ', ', @squared;        # 1, 4, 9, 16, 25</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true中缀形式"><a class="anchor" href="#true中缀形式"></a>7.8.3. 中缀形式</h4>
<div class="paragraph">
<p>要像中缀运算符那样调用具有2个参数的子例程，请使用由 <code>[</code> 和 <code>]</code> 包围的子例程引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub plus { $^a + $^b };
say 21 [&amp;plus] 21;
# OUTPUT«42␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true闭包"><a class="anchor" href="#true闭包"></a>7.8.4. 闭包</h4>
<div class="paragraph">
<p>Raku 中的所有代码对象都是闭包，这意味着它们可以从外部作用域引用词法变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub generate-sub($x) {
    my $y = 2 * $x;
    return sub { say $y };
    #      ^^^^^^^^^^^^^^  inner sub, uses $y
}
my $generated = generate-sub(21);
$generated(); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>$y</code> 是 <code>generate-sub</code> 中的词法变量，并且返回的内部子例程使用了 <code>$y</code>。 到内部 sub 被调用时，<code>generate-sub</code> 已经退出。 然而内部 sub 仍然可以使用 <code>$y</code>，因为它关闭了变量。</p>
</div>
<div class="paragraph">
<p>一个不太明显但有用的闭包示例是使用  <a href="https://docs.raku.org/type/List#routine_map">map</a> 乘以数字列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $multiply-by = 5;
say join ', ', map { $_ * $multiply-by }, 1..5;     # 5, 10, 15, 20, 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里传递给 <code>map</code> 的块从外部作用域引用变量 <code>$multiply-by</code>，使块成为闭包。</p>
</div>
<div class="paragraph">
<p>没有闭包的语言不能轻易地提供高阶函数，它们像 map 一样易于使用和强大。</p>
</div>
</div>
<div class="sect3">
<h4 id="trueroutines"><a class="anchor" href="#trueroutines"></a>7.8.5. Routines</h4>
<div class="paragraph">
<p>例程是遵守  <a href="https://docs.raku.org/type/Routine">Routine</a> 类型的代码对象，最明显的是  <a href="https://docs.raku.org/type/Sub">Sub</a>，<a href="https://docs.raku.org/type/Method">方法</a>，<a href="https://docs.raku.org/type/Regex">正则表达式</a>和 <a href="https://docs.raku.org/type/Submethod">Submethod</a>。</p>
</div>
<div class="paragraph">
<p>他们携带除了 <a href="https://docs.raku.org/type/Block">Block</a>提供的额外的功能：他们可以作为 <a href="https://docs.raku.org/language/functions#Multi-dispatch">multis</a>，你可以<a href="https://docs.raku.org/type/Routine#method_wrap">包装</a>它们，并使用 <code>return</code> 提前退出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $keywords = set &lt;if for unless while&gt;;

sub has-keyword(*@words) {
    for @words -&gt; $word {
        return True if $word (elem) $keywords;
    }
    False;
}

say has-keyword 'not', 'one', 'here';       # False
say has-keyword 'but', 'here', 'for';       # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>return</code> 不仅仅是将离开它所调用的块的内部，而是离开整个程序。 一般来说，块对于 <code>return</code> 是透明的，它们附加到外部程序。</p>
</div>
<div class="paragraph">
<p>例程(Routines)可以是内联的，并且因此为包装设置了障碍。 使用指令 <code>use soft;</code> 以防止内联在运行时允许包装。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub testee(Int $i, Str $s){
    rand.Rat * $i ~ $s;
}

sub wrap-to-debug(&amp;c){
    say "wrapping {&amp;c.name} with arguments {&amp;c.signature.perl}";
    &amp;c.wrap: sub (|args){
        note "calling {&amp;c.name} with {args.gist}";
        my \ret-val := callwith(|args);
        note "returned from {&amp;c.name} with return value {ret-val.perl}";
        ret-val
    }
}

my $testee-handler = wrap-to-debug(&amp;testee);
# OUTPUT«wrapping testee with arguments :(Int $i, Str $s)»

say testee(10, "ten");
# OUTPUT«calling testee with \(10, "ten")␤returned from testee with return value "6.151190ten"␤6.151190ten»
&amp;testee.unwrap($testee-handler);
say testee(10, "ten");
# OUTPUT«6.151190ten␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true定义操作符"><a class="anchor" href="#true定义操作符"></a>7.8.6. 定义操作符</h4>
<div class="paragraph">
<p>操作符只是有趣名字的子例程。 有趣的名称由类别名称（中缀，前缀，后缀，环缀，后环缀）组成，后面跟着冒号，以及一个或多个操作符名称的列表（在环缀和后环缀的情况下为两个组件）。</p>
</div>
<div class="paragraph">
<p>这既适用于向现有运算符添加多个候选项，也适用于定义新的运算符。 在后一种情况下，新子例程的定义自动将新运算符安装到 语法(grammar)中，但仅在当前词法作用域中。 通过 <code>use</code> 或 <code>import</code> 导入操作符也使其可用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># adding a multi candidate to an existing operator:
multi infix:&lt;+&gt;(Int $x, "same") { 2 * $x };
say 21 + "same";            # 42

# 定义一个新的操作符
sub postfix:&lt;!&gt;(Int $x where { $x &gt;= 0 }) { [*] 1..$x };
say 6!;                     # 720</code></pre>
</div>
</div>
<div class="paragraph">
<p>运算符声明变得尽快可用，因此您甚至可以递归到刚才定义的运算符中，如果您真的想要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub postfix:&lt;!&gt;(Int $x where { $x &gt;= 0 }) {
    $x == 0 ?? 1 !! $x * ($x - 1)!
}
say 6!;                     # 720</code></pre>
</div>
</div>
<div class="paragraph">
<p>环缀和后环缀操作符由两个分隔符组成，一个开口和一个闭合。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub circumfix:&lt;START END&gt;(*@elems) {
    "start", @elems, "end"
}

say START 'a', 'b', 'c' END;        # start a b c end</code></pre>
</div>
</div>
<div class="paragraph">
<p>后环缀也接收这个术语，在它们被作为参数解析之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub postcircumfix:&lt;!! !!&gt;($left, $inside) {
    "$left -&gt; ( $inside )"
}
say 42!! 1 !!;      # 42 -&gt; ( 1 )</code></pre>
</div>
</div>
<div class="paragraph">
<p>块可以直接赋值给操作符名。 使用变量声明符，并在操作符名前加上一个 <code>&amp;</code> 符号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my &amp;infix:&lt;ieq&gt; = -&gt; |l { [eq] l&gt;&gt;.fc };
say "abc" ieq "Abc";
# OUTPUT«True␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true优先级"><a class="anchor" href="#true优先级"></a>7.8.7. 优先级</h4>
<div class="paragraph">
<p>Raku 中的运算符优先级相对于现有运算符指定。 <code>is tighter</code>、<code>is equiv</code> 和 <code>is looser</code> 特性能使用一个运算符提供，新的运算符优先级与之相关。 可以应用更多的特征。</p>
</div>
<div class="paragraph">
<p>例如，<code>infix:&lt;*&gt;</code> 的优先级高于 <code>infix:&lt;+&gt;</code>，并且在中间挤压一个像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub infix:&lt;!!&gt;($a, $b) is tighter(&amp;infix:&lt;+&gt;) {
    2 * ($a + $b)
}

say 1 + 2 * 3 !! 4;     # 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>1 + 2 * 3 !! 4</code> 被解析为 <code>1 + ((2 * 3) !! 4)</code>，因为新的 <code>!!</code> 运算符的优先级在 <code>+</code> 和 <code>*</code> 之间。</p>
</div>
<div class="paragraph">
<p>可以使用下面的代码实现相同的效果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub infix:&lt;!!&gt;($a,$b) is looser(&amp;infix:&lt;x&gt;) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将新运算符置于与现有运算符相同的优先级别上，请使用 <code>is equiv(&amp;other-operator)</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="true结合性"><a class="anchor" href="#true结合性"></a>7.8.8. 结合性</h4>
<div class="paragraph">
<p>当同一个操作符在一行中连续出现多次时，有多种可能的解释。 例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1 + 2 + 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>能被解析为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1 + 2) + 3 # 左结合性</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者解析为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1 + (2 + 3) # 右结合性</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于实数的加法，区别有点模糊，因为 <code>+</code> 是 <a href="https://en.wikipedia.org/wiki/Associative_property">数学上相关的</a>。</p>
</div>
<div class="paragraph">
<p>但对其他运算符来说它很重要。 例如对于指数/幂运算符，<code>infix:&lt;**&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 2 ** (2 ** 3);      # 256
say (2 ** 2) ** 3;      # 64</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 拥有以下可能的结合性配置：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Table Assoc</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">A</th>
<th class="tableblock halign-left valign-top">Assoc</th>
<th class="tableblock halign-left valign-top">Meaning of $a ! $b ! $c</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">left</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">($a ! $b) ! $c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">right</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$a ! ($b ! $c)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">non</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ILLEGAL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">($a ! $b) and ($b ! $c)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">infix:&lt;!&gt;($a; $b; $c)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可以使用 <code>is assoc</code> trait 指定运算符的结合性，其中 <code>left</code> 是默认的结合性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub infix:&lt;§&gt;(*@a) is assoc&lt;list&gt; {
    '(' ~ @a.join('|') ~ ')';
}

say 1 § 2 § 3;      # (1|2|3)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truetraits"><a class="anchor" href="#truetraits"></a>7.8.9. Traits</h4>
<div class="paragraph">
<p>特性（<strong>traits</strong>）是在编译时运行以修改类型，变量，例程，属性或其他语言对象的行为的子例程。</p>
</div>
<div class="paragraph">
<p>traits 的例子有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class ChildClass is ParentClass { ... }
#                ^^ trait, with argument ParentClass
has $.attrib is rw;
#            ^^^^^  trait with name 'rw'
class SomeClass does AnotherRole { ... }
#               ^^^^ trait
has $!another-attribute handles &lt;close&gt;;
#                       ^^^^^^^ trait</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有之前章节中的 <code>is tighter</code>、<code>is looser</code>、<code>is equiv</code>、<code>is assoc</code> 等。</p>
</div>
<div class="paragraph">
<p>Traits 是 <code>trait_mod&lt;VERB&gt;</code> 形式的 subs, 其中  <code>VERB</code> 代表像 <code>is</code>、<code>does</code>、<code>handles</code> 那样的名字。它接受修改后的东西作为参数, 还有名字作为具名参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi sub trait_mod:&lt;is&gt;(Routine $r, :$doubles!) {
    $r.wrap({
        2 * callsame;
    });
}

sub square($x) is doubles {
    $x * $x;
}

say square 3;       # 18</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅内置常规性状文档的 <a href="https://docs.raku.org/type/Routine">类型例程</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="true重新分派"><a class="anchor" href="#true重新分派"></a>7.8.10. 重新分派</h4>
<div class="paragraph">
<p>在某些情况下，例程可能想从链中调用下一个方法。 这个链可以是类层次结构中的父类的列表，或者它可以是来自多分派的较不具体的 multi 候选者，或者它可以是来自 <code>wrap</code> 的内部例程。</p>
</div>
<div class="paragraph">
<p>在所有这些情况下，您可以使用 <code>callwith</code> 通过您自己选择的参数调用链中的下一个例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi a(Any $x) {
    say "Any $x";
    return 5;
}
multi a(Int $x) {
    say "Int $x";
    my $res = callwith($x + 1);
    say "Back in Int with $res";
}

a 1;
# OUTPUT:
# Int 1
# Any 2
# Back in Int with 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>a 1</code> 首先调用最具体的 <code>Int</code> 候选者，并且 <code>callwith</code> 重新调度到较不具体的 <code>Any</code> 候选者。</p>
</div>
<div class="paragraph">
<p>通常，重新分派传递和调用者接收到的相同的参数，因此有一个特殊的例程：<code>callsame</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi a(Any $x) {
    say "Any $x";
    return 5;
}
multi a(Int $x) {
    say "Int $x";
    my $res = callsame;
    say "Back in Int with $res";
}

a 1;        # Int 1\n Any 1\n Back in Int with 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个常见的用例是重新分派到链中的下一个例程，之后不执行任何其他操作。 这就是为什么我们有 <code>nextwith</code> 和 <code>nextsame</code>，它使用任意的参数调用下一个例程（<code>nextwith</code>）或与调用者接收（<code>nextsame</code>）相同的参数，但不会返回给调用者。 或者对其进行不同的措辞，<code>nextsame</code> 和 <code>nextwith</code> 变体用下一个候选项替换当前的调用帧(callframe)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi a(Any $x) {
    say "Any $x";
    return 5;
}
multi a(Int $x) {
    say "Int $x";
    nextsame;
    say "back in a";    # never executed, because 'nextsame' doesn't return
}

a 1;        # Int 1\n Any 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，multi sub 不是唯一能在 call，call me，nextwith 和 next 中有帮助的情况。 下面是是调度到包装的例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># enable wrapping:
use soft;

# function to be wrapped:
sub square-root($x) { $x.sqrt }

&amp;square-root.wrap(sub ($num) {
   nextsame if $num &gt;= 0;
   1i * callwith(abs($num));
});

say square-root(4);     # 2
say square-root(-4);    # 0+2i</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个用例是从父类中重分派给方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class LoggedVersion is Version {
    method new(|c) {
        note "New version object created with arguments " ~ c.perl;
        nextsame;
    }
}

say LoggedVersion.new('1.0.2');</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你需要对被包装的代码进行多次调用或获得一个引用，例如内省它，你可以使用 <code>nextcallee</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub power-it($x) { $x * $x }
sub run-it-again-and-again($x) {
    my &amp;again = nextcallee;
    again again $x;
}

&amp;power-it.wrap(&amp;run-it-again-and-again);
say power-it(5);    # 625</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true强制类型"><a class="anchor" href="#true强制类型"></a>7.9. 强制类型</h3>
<div class="paragraph">
<p>强制类型可以帮助您在例程中拥有特定类型，但接受更宽的输入。 当调用例程时，参数将自动转换为较窄的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub double(Int(Cool) $x) {
    2 * $x
}

say double '21'; # 42
say double Any;  # Type check failed in binding $x; expected 'Cool' but got 'Any'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>Int</code> 是参数将被强制的目标类型，而 <code>Cool</code> 是例程接受的作为输入的类型。</p>
</div>
<div class="paragraph">
<p>如果接受的输入类型为 <code>Any</code>，则可以将 <code>Int(Any)</code> 缩写为 <code>Int()</code>。</p>
</div>
<div class="paragraph">
<p>强制只需查找与目标类型具有相同名称的方法即可。 所以你可以为你自己的类型定义强制，像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Bar {...}

class Foo {
   has $.msg = "I'm a foo!";

   method Bar {
       Bar.new(:msg($.msg ~ ' But I am now Bar.'));
   }
}

class Bar {
   has $.msg;
}

sub print-bar(Bar() $bar) {
   say $bar.WHAT; # (Bar)
   say $bar.msg;  # I'm a foo! But I am now Bar.
}

print-bar Foo.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制类型应该在类型工作的任何地方工作，但 Rakudo 当前（2015.02）仅针对子例程参数实现了它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="truesub-main"><a class="anchor" href="#truesub-main"></a>7.10. sub MAIN</h3>
<div class="paragraph">
<p>具有特殊名称 MAIN 的 sub 在所有相关 parsers 之后执行，并且其签名是可以解析命令行参数的装置。 支持 multi 方法，如果未提供命令行参数，则会自动生成并显示使用方法。 所有命令行参数在  <a href="https://docs.raku.org/language/variables#Dynamic_variables">@*ARGS</a> 中也可用，它可以在被 MAIN 处理之前进行变换。</p>
</div>
<div class="paragraph">
<p><code>MAIN</code> 的返回值被忽略。 要提供除 0 以外的退出代码，请调用  <a href="https://docs.raku.org/routine/exit">exit</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub MAIN( Int :$length = 24,
           :file($data) where { .IO.f // die "file not found in $*CWD" } = 'file.dat',
           Bool :$verbose )
{
    say $length if $length.defined;
    say $data   if $data.defined;
    say 'Verbosity ', ($verbose ?? 'on' !! 'off');

    exit 1;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truesub-usage"><a class="anchor" href="#truesub-usage"></a>7.11. sub USAGE</h3>
<div class="paragraph">
<p>如果对于给定的命令行参数没有找到 <code>MAIN</code> 的多个候选者，则调用 sub <code>USAGE</code>。 如果没有找到此类方法，则输出生成的使用消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub MAIN(Int $i){ say $i == 42 ?? 'answer' !! 'dunno' }

sub USAGE(){
print Q:c:to/EOH/;
Usage: {$*PROGRAM-NAME} [number]

Prints the answer or 'dunno'.
EOH
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true副词-2"><a class="anchor" href="#true副词-2"></a>8. 副词</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true副词的-pair-形式"><a class="anchor" href="#true副词的-pair-形式"></a>8.1. 副词的 Pair 形式</h3>
<div class="paragraph">
<p>现在有一个普通的副词形式的 Pair 记号，也是人们所熟知的 "colon pair"（冒号对）形式。下面的表格展示了和胖箭头记号相一致的记号：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Pair and fat arrow</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Fat arrow</th>
<th class="tableblock halign-left valign-top">Adverbial pair</th>
<th class="tableblock halign-left valign-top">Paren form</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:!a</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a(0)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; $x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a($x)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; 'foo'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a&lt;foo&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a(&lt;foo&gt;)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; &lt;foo bar&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a&lt;foo bar&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a(&lt;foo bar&gt;)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; «$foo @bar»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a«$foo @bar»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a(«$foo @bar»)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; {&#8230;&#8203;}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a{&#8230;&#8203;}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a({&#8230;&#8203;})</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; [&#8230;&#8203;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a[&#8230;&#8203;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a([&#8230;&#8203;])</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; $a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:$a</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; @a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:@a</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; %a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:%a</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; &amp;a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:&amp;a</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#8658; %foo&lt;a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">%foo&lt;a&gt;:p</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>胖箭头结构应只用于项(term)所在位置因为它被认为是一个独立的表达式，因为胖箭头自身被解析为一个普通的中缀操作符（即使自动引起它左侧的标识符时）。因为左侧是一个普通的表达式，胖箭头形式会使用任何值作为键来创建 Pair。另一方面，当用上面的形式来生成 Pair 对象时，副词形式被约束为使用标识符作为键。在键不是标识符的地方，你必须使用胖箭头形式来生成 Pair。</p>
</div>
<div class="paragraph">
<p>尽管有那个约束，但是冒号和括号之间有其它东西也是可能的；然而，所有可能的非标识符形式的副词形式的键都被保留用作特殊的语义形式。Raku 当前识别十进制数的键和空(null)键。在下面的表格中，第一列和第二列不是同一个东西：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Table title</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Simple pair</th>
<th class="tableblock halign-left valign-top">colon pair</th>
<th class="tableblock halign-left valign-top">which means</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 &#8658; &lt;101010&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:2&lt;101010&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制字面值 0b101010</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 &#8658; &lt;123&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:8&lt;123&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">八进制字面值 0o123</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16 &#8658; &lt;deadbeef&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:16&lt;deadbeef&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十六进制字面值 0xdeadbeef</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16 &#8658; $somevalue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:16($somevalue)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十六进制转换函数，把十六进制的字符串转换为数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'' &#8658; $x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:($x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">签名字面值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'' &#8658; ($x,$y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:($x,$y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">签名字面值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'' &#8658; &lt;x&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:&lt;x&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">name extension</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'' &#8658; «x»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:«x»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">name extension</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'' &#8658; [$x,$y]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:[$x,$y]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">name extension</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'' &#8658; { .say }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:{ .say }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">adverbial block (not allowed on names)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有的副词形式（包括普通的带有标识符键的副词）被认为是特殊的令牌(tokens)并且除了能在项的位置上被识别，也能在各种不同的位置上被识别。特别地，当把它用在中缀的位置上时，它们修改了之前的顶端的优先级比"loose unary"紧凑的操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1 == 100 :fuzz(3)   # 调用: infix:&lt;==&gt;(1, 100, fuzz =&gt; 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在声明内部副词形式用于重命名参数声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo ( :externalname($myname) ) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>副词修改了各种引号形式的意义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">q:x 'cat /etc/passwd'</code></pre>
</div>
</div>
<div class="paragraph">
<p>当副词被追加到标识符（即，在后缀位置上）后面时，副词形式的语法用于生成那个标识符的唯一变体；该语法用于命名诸如 <code>infix:&lt;+&gt;</code> 这样的操作符和诸如 <code>statement_control:if</code> 这样的多重分发文法规则。当这样用时，副词被认为是名字的一部分，所以 <code>infix:&lt;+&gt;</code> 和 <code>infix:&lt;&#8594;</code> 是两个不同的操作符。同样地, <code>prefix:&lt;+&gt;</code> 不同于 <code>infix&lt;+&gt;</code>。（这种记法的好处有把不同的标识符分组到容易访问的集合中，例如，这就是 Raku 标准文法时如何知道当前中缀操作符集合的）。</p>
</div>
<div class="paragraph">
<p>只有能产生一列一个或更多值（偏好字符串）的标识符被允许作为名字扩展；特殊地，闭包不能作为值，所以 <code>:{&#8230;&#8203;}</code> 形式的副词不能被允许作为名字扩展。特别地，这把方法名后面的 block 空了出来，所以它允许我们把 block 解析为方法的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@stuff.sort:{ +$_ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些看起来它们使用的是 pairs，实际上它们等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@stuff.sort: { +$_ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以这儿的冒号真得不是在引入 pairs，而是引入了该方法的参数列表。在其他任何位置，<code>:{&#8230;&#8203;}</code> 会使用两种用法的一种，根据花括号定义的是闭包还是散列。如果被当做闭包， <code>:{&#8230;&#8203;}</code> 会创建把空键(null)映射到闭包的 pair。如果被当做散列构造器，那么空键会被忽略，并且 <code>:{&#8230;&#8203;}</code> 会创建一个以对象为键的散列而非像没有冒号的 <code>{&#8230;&#8203;}</code> 那样创建一个以字符串为键的散列。</p>
</div>
<div class="paragraph">
<p>胖箭头和副词对儿记法都能用于把具名参数作为项传递给函数或方法。在括号里面带有参数的调用后面，只有副词形式的语法能用于传递额外的参数。这通常用于传递额外的 block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">find($directory) :{ when not /^\./ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这正好和前面的规则离经叛道，因为副词形式的 block 处于操作符的位置，所以它修改了 "find operator"。(括号不被认为是操作符)</p>
</div>
<div class="paragraph">
<p>注意（和往常一样）<code>{&#8230;&#8203;}</code> 形式（要么基于操作符要么是特殊的）可以根据内容要么标示一个闭包，要么标示一个散列。它没有标示下标，因为 <code>:key{}</code> 实际上等价于 <code>key &#8658; {}</code>, 并且花括号一点儿也没有表现得像后缀一样。（然而，它所传递给的函数也能把那个值用于下标）</p>
</div>
<div class="paragraph">
<p>还要注意 <code>&lt;a b&gt;</code> 形式不是下标，因此并不等价于 <code>.{'a', 'b'}</code> 而是等价于 <code>('a', 'b')</code>。 裸的 <code>&lt;a&gt;</code> 转换为 <code>('a')</code> 而不是 <code>('a',)</code>。（然而，对于其它形式的括号，根据上下文，值可能也能用作下标）</p>
</div>
<div class="paragraph">
<p>两个更多地副词总是可以捆绑在一块儿。当在参数列表中用作具名参数时，你可能在参数之间放上逗号，因为它们对于函数来说就是普通的具名参数，并且胖箭头形式的参数效果相同。然而，当第一个 pair 出现在项(term)的位置上时，这个逗号才只允许出现。当期望一个中缀操作符时，那个副词总是被看做修改最近的之前的操作符，它没有被隐藏在圆括号中，并且如果你把多个这样的 pairs 作为一个字符串放在一块儿，那么你就不能在它们中间放上逗号，因为那会让之后的 pairs 看起来像项(terms)。（在操作符的位置上一点也不允许胖箭头形式）查看 S06 获取把副词用作具名参数的用法。</p>
</div>
<div class="paragraph">
<p>否定形式(<code>:!a</code>) 和符号形式(<code>:$a</code>, <code>:@a</code>, <code>:%a</code>) 绝对不会接收参数也不关心下一个字符是什么。它们被认为是完备的。这些形式需要一个标识符作为键。包含 twigil 的符号形式不会在键中包含那个 twigil。</p>
</div>
<div class="paragraph">
<p>对于接收一个非否定整数参数的标识符，它被允许缩写，例如，把 <code>:sweet(16)</code> 缩写为 <code>:16sweet</code>。（这个和 <code>:16&lt;deadbeef&gt;</code> 形式不一样，后者从来没有字母字符跟在数字后面。）只有字面的非负数字可以这样交换使用。请注意这个缩写允许：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">s:2nd/foo/bar/  # or 3rd, 4th, 5th etc.</code></pre>
</div>
</div>
<div class="paragraph">
<p>其它形式的副词（包括裸的 <code>:a</code> 形式）总是查找紧紧跟随的用括号括起的参数，并且把它吞噬掉。如果那没有达到预期，那么你必须在副词和开括号之间使用空白。在 Raku中单独的副词语法在各处都是相同的。基于参数是需要还是不需要，没有例外。（对于引号副词和 regex 副词有一个小例外，它们只接受圆括号作为它们的括号操作符，并且忽略其它括号，如果需要它们必须被放到括号里。查看上表中得" Paren form"）</p>
</div>
<div class="paragraph">
<p>除了上面要注意的之外，解析器常常会寻找括号。尽管没有标示一个真的下标，括号被类似地解析为后缀操作符。因为把括号后缀化可以和它们起初的使用 unspace 或点(或两者都) <code>:foo</code> 的区分开。</p>
</div>
<div class="paragraph">
<p>不管语法，用作具名参数的副词一般作为我们正谈论的函数的可选具名参数呈现&#8201;&#8212;&#8201;即使那个函数是操作符或宏。那个正被谈论的函数既不知道也不关心原语法是多么的怪异。</p>
</div>
</div>
<div class="sect2">
<h3 id="true下标副词"><a class="anchor" href="#true下标副词"></a>8.2. 下标副词</h3>
<div class="paragraph">
<p>为了使切片下标返回除了值以外的其它东西，那么给下标(subscript)添加合适的副词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@array = &lt;A B&gt;;
@array[0,1,2];      # returns 'A', 'B', (Any)
@array[0,1,2] :p;   # returns 0 =&gt; 'A', 1 =&gt; 'B'
@array[0,1,2] :kv;  # returns 0, 'A', 1, 'B'
@array[0,1,2] :k;   # returns 0, 1
@array[0,1,2] :v;   # returns 'A', 'B'

%hash = (:a&lt;A&gt;, :b&lt;B&gt;);
%hash&lt;a b c&gt;;       # returns 'A', 'B', (Any)
%hash&lt;a b c&gt; :p;    # returns a =&gt; 'A', b =&gt; 'B'
%hash&lt;a b c&gt; :kv;   # returns 'a', 'A', 'b', 'B'
%hash&lt;a b c&gt; :k;    # returns 'a', 'b'
%hash&lt;a b c&gt; :v;    # returns 'A', 'B'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果副词为真，那么这些副词形式都会清除不存在的条目；如果为假的话，就会留下不存在的项，就像普通的切片那样。所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@array[0,1,2] :!p;  # returns 0 =&gt; 'A', 1 =&gt; 'B', 2 =&gt; (Any)
%hash&lt;a b c&gt;  :!kv; # returns 'a', 'A', 'b', 'B', 'c', (Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样地，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my ($a,$b,$c) = %hash&lt;a b c&gt; :delete;</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除那些条目并顺道返回它们。这种形式能够工作是因为下标是顶端的在前的操作符。如果某些其它的操作符的优先级比处于顶端的逗号操作符的优先级紧凑，那么你必须用括号括起它或强制为列表上下文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1 + (%hash{$x} :delete);
$x = (%hash{$x} :delete);
($x) = %hash{$x} :delete;</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有在副词为真的时候元素才会被删除。而 <code>:!delete</code> 本质上是一个空操作；你可以基于传递的诸如 <code>:delete($kill&#8217;em)</code> 标记顺带有条件地删除条目。在任何一种情况下，被删除的值会被返回。</p>
</div>
<div class="paragraph">
<p>你也可以执行存在性测试，要么测试单个条目是否存在，要么测试条目的连接是否存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if %hash&lt;foo&gt; :exists           {...}
if %hash{any &lt;a b c&gt;}  :exists  {...}
if %hash{all &lt;a b c&gt;}  :exists  {...}
if %hash{one &lt;a b c&gt;}  :exists  {...}
if %hash{none &lt;a b c&gt;} :exists  {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>:exists</code> 副词和一组切片结果的布尔值列表结合起来使用，你也可以用类型的语义这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if any %hash&lt;a b c&gt;  :exists {...}
if all %hash&lt;a b c&gt;  :exists {...}
if one %hash&lt;a b c&gt;  :exists {...}
if none %hash&lt;a b c&gt; :exists {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>:!exists</code> 来测试不存在。这特别便捷因为优先级规则让 <code>!%hash&lt;a&gt; :exists</code> 把 <code>:exists</code> 应用到前缀 <code>!</code> 上。 <code>%hash&lt;a&gt; :!exists</code> 没有那个问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="true组合下标副词"><a class="anchor" href="#true组合下标副词"></a>8.3. 组合下标副词</h3>
<div class="paragraph">
<p>像调用中得具名参数那样，下标中处理多个副词是没有顺序之分的。有些组合有意义，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">%a = %b{@keys-to-extract} :delete :p; # same as :p :delete</code></pre>
</div>
</div>
<div class="paragraph">
<p>会把给定的键分片到另外一个散列中。而</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@actually-deleted = %h{@keys-to-extract} :delete :k; # same as :k :delete</code></pre>
</div>
</div>
<div class="paragraph">
<p>会返回真正从散列中删除的键。</p>
</div>
<div class="paragraph">
<p>只指定返回类型的副词，不能被组合，因为诸如 <code>:kv :p</code>、或 <code>:v :k</code> 就没有意义。</p>
</div>
<div class="paragraph">
<p>下面的这些副词组合被看做是合法的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:delete :kv            delete, return key/values of actually deleted keys
:delete :!kv           delete, return key/values of all keys attempted
:delete :p             delete, return pairs of actually deleted keys
:delete :!p            delete, return pairs of all keys attempted
:delete :k             delete, return actually deleted keys
:delete :!k            delete, return all keys attempted to delete
:delete :v             delete, return values of actually deleted keys
:delete :!v            delete, return values of all keys attempted
:delete :exists        delete, return Bools indicating keys existed
:delete :!exists       delete, return Bools indicating keys did not exist
:delete :exists :kv    delete, return list with key,True for key existed
:delete :!exists :kv   delete, return list with key,False for key existed
:delete :exists :!kv   delete, return list with key,Bool whether key existed
:delete :!exists :!kv  delete, return list with key,!Bool whether key existed
:delete :exists :p     delete, return pairs with key/True for key existed
:delete :!exists :p    delete, return pairs with key/False for key existed
:delete :exists :!p    delete, return pairs with key/Bool whether key existed
:delete :!exists :!p   delete, return pairs with key/!Bool whether key existed
:exists :kv            return pairs with key,True for key exists
:!exists :kv           return pairs with key,False for key exists
:exists :!kv           return pairs with key,Bool for key exists
:!exists :!kv          return pairs with key,!Bool for key exists
:exists :p             return pairs with key/True for key exists
:!exists :p            return pairs with key/False for key exists
:exists :!p            return pairs with key/Bool for key exists
:!exists :!p           return pairs with key/!Bool for key exists</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true类"><a class="anchor" href="#true类"></a>9. 类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 有一个丰富的内置语法来定义和使用类。</p>
</div>
<div class="paragraph">
<p>默认构造函数允许为创建的对象设置属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Point {
    has Int $.x;
    has Int $.y;
}

class Rectangle {
    has Point $.lower;
    has Point $.upper;

    method area() returns Int {
        ($!upper.x - $!lower.x) * ( $!upper.y - $!lower.y);
    }
}

# Create a new Rectangle from two Points
my $r = Rectangle.new(lower =&gt; Point.new(x =&gt; 0, y =&gt; 0), upper =&gt; Point.new(x =&gt; 10, y =&gt; 10));

say $r.area(); # OUTPUT: «100␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Raku 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Task {
    has      &amp;!callback;
    has Task @!dependencies;
    has Bool $.done;

    # Normally doesn't need to be written
    # BUILD is the equivalent of a constructor in other languages
    method new(&amp;callback, *@dependencies) {
        return self.bless(:&amp;callback, :@dependencies);
    }

    submethod BUILD(:&amp;!callback, :@!dependencies) { }

    method add-dependency(Task $dependency) {
        push @!dependencies, $dependency;
    }

    method perform() {
        unless $!done {
            .perform() for @!dependencies;
            &amp;!callback();
            $!done = True;
        }
    }
}

my $eat =
    Task.new({ say 'eating dinner. NOM!' },
        Task.new({ say 'making dinner' },
            Task.new({ say 'buying food' },
                Task.new({ say 'making some money' }),
                Task.new({ say 'going to the store' })
            ),
            Task.new({ say 'cleaning kitchen' })
        )
    );

$eat.perform();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="true从类开始"><a class="anchor" href="#true从类开始"></a>9.1. 从类开始</h3>
<div class="paragraph">
<p>和许多其他语言一样，Raku 使用 <code>class</code> 关键字来定义一个类。接下来的块可能包含任意代码，就像其他块一样，但类通常包含状态和行为声明。示例代码包括通过 <code>has</code> 关键字引入的属性（状态）以及通过 <code>method</code> 关键字引入的行为。</p>
</div>
<div class="paragraph">
<p>声明一个类会创建一个新的 <strong>类型对象</strong>，默认情况下，它将被安装到当前包中（就像使用 <code>our</code> 作用域声明的变量一样）。此类型对象是类的“空实例”。例如，<code>Int</code> 和 <code>Str</code> 等类型引用 Raku 内置类之一的类型对象。上面的示例使用类名称 <code>Task</code>，以便其他代码稍后可以引用它，例如通过调用 <code>new</code> 方法来创建类实例。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code>.DEFINITE</code> 方法来确定你拥有的是实例还是类型对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say Int.DEFINITE; # OUTPUT: «False␤» (type object)
say 426.DEFINITE; # OUTPUT: «True␤»  (instance)

class Foo {};
say Foo.DEFINITE;     # OUTPUT: «False␤» (type object)
say Foo.new.DEFINITE; # OUTPUT: «True␤»  (instance)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用类型表情符号来仅接受实例或类型对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi foo (Int:U) { "It's a type object!" }
multi foo (Int:D) { "It's an instance!"   }
say foo Int; # OUTPUT: «It's a type object!␤»
say foo 42;  # OUTPUT: «It's an instance!␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true状态"><a class="anchor" href="#true状态"></a>9.2. 状态</h3>
<div class="paragraph">
<p>类块中的前三行声明所有属性（在其他语言中称为字段或实例存储）。就像 <code>my</code> 变量不能从其声明的作用域之外访问一样，属性不能在类的外面访问。这种封装是面向对象设计的关键原则之一。</p>
</div>
<div class="paragraph">
<p>第一个声明指定回调的实例存储 - 为执行对象表示的任务而调用的一些代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has &amp;!callback;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&amp;</code> sigil 表示该属性代表可调用的内容。 <code>!</code> 字符是一个 <strong>twigil</strong>，或 <strong>secondary sigil</strong>。twigil 组成变量名称的一部分。在这种情况下，<code>!</code> twigil 强调，这个属性对类是私有的。</p>
</div>
<div class="paragraph">
<p>第二个声明也使用私有 twigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has Task @!dependencies;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，这个属性表示一个项目的数组，所以它需要 <code>@</code> sigil。这些项目分别指定一个任务，在完成之前必须先完成这些任务。而且，这个属性的类型声明表明该数组只能包含 <code>Task</code> 类的实例（或者它的某个子类）。</p>
</div>
<div class="paragraph">
<p>第三个属性表示任务完成的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has Bool $.done;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个标量属性（带有 <code>$</code> sigil）有一个 <code>Bool</code> 类型。而不是 <code>!</code> twigil，使用 <code>.</code> twigil。尽管 Raku 确实对属性进行了封装，但它也可以避免编写访问器方法。替换！与。都声明属性 $!done 和一个名为 done 的访问器方法。就好像你写了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has Bool $!done;
method done() { return $!done }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这不像某些语言允许的那样声明公共属性;你真的得到了一个私有属性和一个方法，而无需手动编写该方法。你可以自由地编写自己的访问器方法，如果你将来需要做一些比返回值更复杂的事情。</p>
</div>
<div class="paragraph">
<p>请注意，使用。 twigil创建了一个方法，将提供对该属性的只读访问权限。如果该对象的用户应该能够重置任务的完成状态（也许再次执行），则可以更改属性声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has Bool $.done is rw;</code></pre>
</div>
</div>
<div class="paragraph">
<p>rw 特征会导致生成的访问器方法返回一些外部代码可以修改的内容以更改该属性的值。</p>
</div>
<div class="paragraph">
<p>您还可以为属性提供默认值（对于有和没有访问者的情况，这些默认值同样适用）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has Bool $.done = False;</code></pre>
</div>
</div>
<div class="paragraph">
<p>分配是在对象构建时进行的。此时评估右侧，甚至可以引用早期的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has Task @!dependencies;
has $.ready = not @!dependencies;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true静态字段"><a class="anchor" href="#true静态字段"></a>9.3. 静态字段</h3>
<div class="paragraph">
<p>Raku 没有静态关键字。尽管如此，任何类都可以声明模块可以做的任何事情，所以使范围变量听起来像是个好主意。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Singleton {
    my Singleton $instance;
    method new {!!!}
    submethod instance {
        $instance = Singleton.bless unless $instance;
        $instance;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由我或我们定义的类属性也可以在声明时初始化，但是我们在这里实现 Singleton 模式，并且必须在第一次使用时创建对象。预测执行属性初始化的时刻不是 100％，因为它可以在编译，运行时或两者期间发生，尤其是在使用 <code>use</code> 关键字导入类时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class HaveStaticAttr {
      my Foo $.foo = some_complicated_subroutine;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类属性也可以用辅助 sigil 声明 - 以类似于对象属性的方式 - 如果属性将被公开，将生成只读访问器。</p>
</div>
</div>
<div class="sect2">
<h3 id="true方法"><a class="anchor" href="#true方法"></a>9.4. 方法</h3>
<div class="paragraph">
<p>虽然属性赋予对象状态，但方法赋予对象行为。我们暂时忽略新方法; 这是一种特殊的方法。考虑第二种方法 <code>add-dependency</code>，它将一项新任务添加到任务的依赖列表中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">method add-dependency(Task $dependency) {
    push @!dependencies, $dependency;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多方面，这看起来很像一个子声明。但是，有两个重要的区别。首先，将此例程声明为方法将其添加到当前类的方法列表中，因此 <code>Task</code> 类的任何实例都可以使用它调用它。方法调用操作符。其次，一种方法将其调用者放入特殊变量 <code>self</code> 中。</p>
</div>
<div class="paragraph">
<p>该方法本身将传入的参数（它必须是 <code>Task</code> 类的一个实例）并将其推送到 <code>invocant</code> 的 <code>@!dependencies</code> 属性上。</p>
</div>
<div class="paragraph">
<p>执行方法包含依赖性处理程序的主要逻辑：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">method perform() {
    unless $!done {
        .perform() for @!dependencies;
        &amp;!callback();
        $!done = True;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它不需要参数，而是使用对象的属性。首先，通过检查 <code>$!done</code> 属性来检查任务是否已经完成。如果是这样，那就没有什么可做的了。</p>
</div>
<div class="paragraph">
<p>否则，该方法执行所有任务的依赖关系，使用 for 构造遍历 <code>@!dependencies</code> 属性中的所有项。此迭代将每个项目（每个项目都放置一个 Task 对象）放入主题变量 <code>$_</code> 中。使用 。方法调用操作符而不指定明确的调用者将当前主题用作调用者。因此，迭代构造对当前调用者的 <code>@!dependencies</code> 属性中的每个 Task 对象调用 <code>.perform()</code> 方法。</p>
</div>
<div class="paragraph">
<p>在所有的依赖关系完成之后，通过直接调用 <code>&amp;!</code> 回调属性来执行当前任务的任务。这是括号的目的。最后，该方法将 <code>$!done</code> 属性设置为 True，以便后续对该对象执行的调用（例如，如果此 Task 是另一个 Task 的依赖项）将不会重复该任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="true私有方法"><a class="anchor" href="#true私有方法"></a>9.5. 私有方法</h3>
<div class="paragraph">
<p>就像属性一样，方法也可以是私有的。私有方法声明带有前缀感叹号。他们使用 <code>self!</code> 调用. 随后是方法的名称。要调用另一个类的私有方法，调用类必须被调用类信任。信任关系是用信任声明的，而且要信任的类必须已经声明。调用另一个类的私有方法需要该类的实例和该方法的全限定名称。信任也允许访问私有属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class B {...}

class C {
    trusts B;
    has $!hidden = 'invisible';
    method !not-yours () { say 'hidden' }
    method yours-to-use () {
        say $!hidden;
        self!not-yours();
    }
}

class B {
    method i-am-trusted () {
        my C $c.=new;
        $c!C::not-yours();
    }
}

C.new.yours-to-use(); # the context of this call is GLOBAL, and not trusted by C
B.new.i-am-trusted();</code></pre>
</div>
</div>
<div class="paragraph">
<p>信任关系不受继承。要信任全局名称空间，可以使用伪包GLOBAL。</p>
</div>
</div>
<div class="sect2">
<h3 id="true构造函数"><a class="anchor" href="#true构造函数"></a>9.6. 构造函数</h3>
<div class="paragraph">
<p>Raku 比构造函数领域的许多语言更自由。构造函数是任何返回类实例的东西。而且，构造函数是普通的方法。您从基类 <code>Mu</code> 继承了一个名为 <strong>new</strong> 的默认构造函数，但您可以自由覆盖 <code>new</code>，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">method new(&amp;callback, *@dependencies) {
    return self.bless(:&amp;callback, :@dependencies);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku中的构造函数和C＃和Java等语言中的构造函数最大的不同之处在于，它不是以某种方式为已经神奇创建的对象设置状态，而是由 Raku 构造函数自己创建对象。最简单的方法是调用也是从 <code>Mu</code> 继承的 <code>bless</code> 方法。 bless 方法期望一组命名参数为每个属性提供初始值。</p>
</div>
<div class="paragraph">
<p>该示例的构造函数将位置参数转换为命名参数，以便该类可以为其用户提供一个很好的构造函数。第一个参数是回调（将执行任务的东西）。其余参数是相关的 Task 实例。构造函数将这些捕获到 <code>@dependencies</code> slurpy 数组中，并将它们作为命名参数传递给 bless（注意 <code>:&amp;callback</code> 使用变量的名称 - 减去 sigil  - 作为参数的名称）。</p>
</div>
<div class="paragraph">
<p>私有属性确实是私有的。这意味着bless不允许直接将事物绑定到 <code>&amp;!callback</code> 和 <code>@!</code> 依赖关系。为了做到这一点，我们重写 <code>BUILD</code> 子方法，这是通过 <code>bless</code> 在全新对象上调用的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">submethod BUILD(:&amp;!callback, :@!dependencies) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 BUILD 在新创建的 Task 对象的上下文中运行，因此可以操作这些私有属性。这里的技巧是使用私有属性（<code>&amp;!callback</code> 和 <code>@!dependencies</code>）作为 BUILD 参数的绑定目标。零样板初始化！查看对象获取更多信息。</p>
</div>
<div class="paragraph">
<p>BUILD 方法负责初始化所有属性，还必须处理默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">has &amp;!callback;
has @!dependencies;
has Bool ($.done, $.ready);
submethod BUILD(
        :&amp;!callback,
        :@!dependencies,
        :$!done = False,
        :$!ready = not @!dependencies
    ) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅对象构造以获取更多影响对象构造和属性初始化的选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="true消费我们的类"><a class="anchor" href="#true消费我们的类"></a>9.7. 消费我们的类</h3>
<div class="paragraph">
<p>创建一个类后，您可以创建该类的实例。声明一个自定义构造函数提供了一种简单的方式来声明任务及其依赖关系。要创建没有依赖关系的单个任务，请写下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $eat = Task.new({ say 'eating dinner. NOM!' });</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的章节解释说，声明类 Task 在命名空间中安装了一个类型对象。这个类型对象是类的一个“空实例”，特别是没有任何状态的实例。您可以调用该实例的方法，只要它们不尝试访问任何状态;新是一个例子，因为它创建了一个新对象，而不是修改或访问现有对象。</p>
</div>
<div class="paragraph">
<p>不幸的是，晚餐从未奇迹般地发生。它有依赖任务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $eat =
    Task.new({ say 'eating dinner. NOM!' },
        Task.new({ say 'making dinner' },
            Task.new({ say 'buying food' },
                Task.new({ say 'making some money' }),
                Task.new({ say 'going to the store' })
            ),
            Task.new({ say 'cleaning kitchen' })
        )
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意自定义构造函数和明智的空白使用如何清除任务依赖关系。</p>
</div>
<div class="paragraph">
<p>最后，perform 方法调用按顺序递归调用各种其他依赖项上的 perform 方法，并给出以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">making some money
going to the store
buying food
cleaning kitchen
making dinner
eating dinner. NOM!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true继承"><a class="anchor" href="#true继承"></a>9.8. 继承</h3>
<div class="paragraph">
<p>面向对象编程提供了继承的概念，作为代码重用的机制之一。 Raku 支持一个类从一个或多个类继承的能力。当一个类从另一个类继承时，它会通知方法调度器遵循继承链寻找一个派发方法。对于通过方法关键字定义的标准方法以及通过其他方式（如属性访问器）生成的方法，都会发生这种情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Employee {
    has $.salary;
}

class Programmer is Employee {
    has @.known_languages is rw;
    has $.favorite_editor;

    method code_to_solve( $problem ) {
        return "Solving $problem using $.favorite_editor in "
        ~ $.known_languages[0];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>Programmer</code> 类型的任何对象都可以使用 <code>Employee</code> 类中定义的方法和访问器，就像它们来自 <code>Programmer</code> 类一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $programmer = Programmer.new(
    salary =&gt; 100_000,
    known_languages =&gt; &lt;Perl5 Raku Erlang C++&gt;,
    favorite_editor =&gt; 'vim'
);

say $programmer.code_to_solve('halting problem'), " will get ", $programmer.salary(), "\$";
#OUTPUT: «Solving halting problem using vim in Perl5 will get 100000$␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true重写继承到的方法"><a class="anchor" href="#true重写继承到的方法"></a>9.9. 重写继承到的方法</h3>
<div class="paragraph">
<p>当然，类可以通过定义它们自己来覆盖由父类定义的方法和属性。下面的例子演示了 Baker 类覆盖 Cook 的烹饪方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Cook is Employee {
    has @.utensils  is rw;
    has @.cookbooks is rw;

    method cook( $food ) {
        say "Cooking $food";
    }

    method clean_utensils {
        say "Cleaning $_" for @.utensils;
    }
}

class Baker is Cook {
    method cook( $confection ) {
        say "Baking a tasty $confection";
    }
}

my $cook = Cook.new(
    utensils =&gt; &lt;spoon ladle knife pan&gt;,
    cookbooks =&gt; 'The Joy of Cooking',
    salary =&gt; 40000);

$cook.cook( 'pizza' );       # OUTPUT: «Cooking pizza␤»
say $cook.utensils.perl;     # OUTPUT: «["spoon", "ladle", "knife", "pan"]␤»
say $cook.cookbooks.perl;    # OUTPUT: «["The Joy of Cooking"]␤»
say $cook.salary;            # OUTPUT: «40000␤»

my $baker = Baker.new(
    utensils =&gt; 'self cleaning oven',
    cookbooks =&gt; "The Baker's Apprentice",
    salary =&gt; 50000);

$baker.cook('brioche');      # OUTPUT: «Baking a tasty brioche␤»
say $baker.utensils.perl;    # OUTPUT: «["self cleaning oven"]␤»
say $baker.cookbooks.perl;   # OUTPUT: «["The Baker's Apprentice"]␤»
say $baker.salary;           # OUTPUT: «50000␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为调度会在 <code>Baker</code> 上移到父级之前看到 <code>Cook</code> 的 <code>cook</code> 方法，所以调用 <code>Baker</code> 的 <code>cook</code> 方法。</p>
</div>
<div class="paragraph">
<p>要访问继承链中的方法，请使用重新分派或 <code>MOP</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="true多重继承"><a class="anchor" href="#true多重继承"></a>9.10. 多重继承</h3>
<div class="paragraph">
<p>如前所述，一个类可以从多个类继承。当一个类从多个类继承时，调度员知道在查找方法时要查看这两个类。 Raku 使用C3算法对多个继承层次进行线性化，这比深度优先搜索更好地处理多重继承。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class GeekCook is Programmer is Cook {
    method new( *%params ) {
        push( %params&lt;cookbooks&gt;, "Cooking for Geeks" );
        return self.bless(|%params);
    }
}

my $geek = GeekCook.new(
    books           =&gt; 'Learning Raku',
    utensils        =&gt; ('stainless steel pot', 'knife', 'calibrated oven'),
    favorite_editor =&gt; 'MacVim',
    known_languages =&gt; &lt;Raku&gt;
);

$geek.cook('pizza');
$geek.code_to_solve('P =? NP');</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在所有可用于 <code>Programmer</code> 和 <code>Cook</code> 类的方法都可以从 <code>GeekCook</code> 类中获得。</p>
</div>
<div class="paragraph">
<p>虽然多重继承是知道和偶尔使用的有用概念，但重要的是要了解有更多有用的 OOP 概念。当达到多重继承时，最好考虑是否通过使用角色来更好地实现设计，这通常更安全，因为它们强制类作者明确地解决冲突的方法名称。有关角色的更多信息，请参阅角色。</p>
</div>
</div>
<div class="sect2">
<h3 id="truealso-声明符"><a class="anchor" href="#truealso-声明符"></a>9.11. also 声明符</h3>
<div class="paragraph">
<p>通过在特征前加上也可以在类声明主体中列出要继承的类。这也适用于角色组合特质。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class GeekCook {
    also is Programmer;
    also is Cook;
    # ...
}

role A {};
role B {};
class C { also does A; also does B }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true自省"><a class="anchor" href="#true自省"></a>9.12. 自省</h3>
<div class="paragraph">
<p>自省是在程序中收集有关某些对象的信息的过程，而不是通过阅读源代码，而是通过查询对象（或控制对象）来获取某些属性，例如其类型。</p>
</div>
<div class="paragraph">
<p>给定一个对象 <code>$o</code> 和前面几节的类定义，我们可以问一些问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if $o ~~ Employee { say "It's an employee" };
if $o ~~ GeekCook { say "It's a geeky cook" };
say $o.WHAT;
say $o.perl;
say $o.^methods(:local)».name.join(', ');
say $o.^name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">It's an employee
(Programmer)
Programmer.new(known_languages =&gt; ["Perl", "Python", "Pascal"],
        favorite_editor =&gt; "gvim", salary =&gt; "too small")
code_to_solve, known_languages, favorite_editor
Programmer</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两个测试每个智能匹配类名称。如果对象是该类或继承类，则返回 true。因此，所讨论的对象是 <code>Employee</code> 类，或者是继承它的类，但不是 <code>GeekCook</code>。</p>
</div>
<div class="paragraph">
<p><code>.WHAT</code> 方法返回与对象 <code>$o</code> 关联的类型对象，它告诉我们 <code>$o</code> 的确切类型：在这种情况下是 Programmer。</p>
</div>
<div class="paragraph">
<p><code>$o.perl</code> 返回一个可以作为 Perl 代码执行的字符串，并且再现原始对象 <code>$o</code>。虽然这在所有情况下都不能很好地工作，但它对调试简单对象非常有用。 <code>$o.^methods(:local)</code> 产生一个可以在 <code>$o</code> 上调用的方法列表。 <code>:local</code> 命名参数将返回的方法限制为在 Programmer 类中定义的方法，并排除继承的方法。</p>
</div>
<div class="paragraph">
<p>使用 <code>.^</code> 而不是单个点调用方法的语法意味着它实际上是对其元类的一个方法调用，该类是管理 <code>Programmer</code> 类的属性的类 - 或者您感兴趣的任何其他类。类也启用了其他自省方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $o.^attributes.join(', ');
say $o.^parents.map({ $_.^name }).join(', ');</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，<code>$o.^name</code> 调用元对象的名称方法，这毫不意外地返回类名称。</p>
</div>
<div class="paragraph">
<p>自省对于调试和学习语言和新库非常有用。当一个函数或方法返回一个你不知道的对象时，用 <code>.WHAT</code> 查找它的类型，用 <code>.perl</code> 等等来查看它的构造方法，你会很清楚它的返回值是什么。使用 <code>.^</code> 方法，您可以了解您可以对课程做些什么。</p>
</div>
<div class="paragraph">
<p>但也有其他应用程序：将对象序列化为一串字节的例程需要知道该对象的属性，可以通过内省查找该对象的属性。</p>
</div>
</div>
<div class="sect2">
<h3 id="true重写默认的-gist-方法"><a class="anchor" href="#true重写默认的-gist-方法"></a>9.13. 重写默认的 gist 方法</h3>
<div class="paragraph">
<p>有些类可能需要它自己的版本，它会覆盖当被调用以提供类的默认表示时被打印的简洁方式。例如，异常可能只想写入有效负载而不是完整对象，以便更清楚发生了什么。但是，每个班级你都可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Cook {
    has @.utensils  is rw;
    has @.cookbooks is rw;

    method cook( $food ) {
        return "Cooking $food";
    }

    method clean_utensils {
        return "Cleaning $_" for @.utensils;
    }

    multi method gist(Cook:U:) { '⚗' ~ self.^name ~ '⚗' }
    multi method gist(Cook:D:) { '⚗ Cooks with ' ~ @.utensils.join( " ‣ ") ~ ' using ' ~ @.cookbooks.map( "«" ~ * ~ "»").join( " and ") }
}

my $cook = Cook.new(
    utensils =&gt; &lt;spoon ladle knife pan&gt;,
    cookbooks =&gt; ['Cooking for geeks','The French Chef Cookbook']);

say Cook.gist; # OUTPUT: «⚗Cook⚗»
say $cook.gist; # OUTPUT: «⚗ Cooks with spoon ‣ ladle ‣ knife ‣ pan using «Cooking for geeks» and «The French Chef Cookbook»␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常你会想定义两个方法，一个用于类，另一个用于实例; 在这种情况下，类方法使用 alambic 符号，下面定义的实例方法聚合了我们在厨师上的数据以叙述方式显示。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>例如，封闭不容易以这种方式复制;如果你不知道封闭是什么，不要担心。此外，当前的实现方式在倾倒循环数据结构方面存在问题，但预期它们可以在某些时候由 <code>.perl</code> 正确处理。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true角色"><a class="anchor" href="#true角色"></a>10. 角色</h2>
<div class="sectionbody">
<div class="paragraph">
<p>角色是属性和方法的集合; 但是，与类不同，角色仅用于描述对象行为的一部分; 这就是为什么一般来说，角色应该在类和对象中混合使用。通常，类用于管理对象，而角色用于管理对象内的行为和代码重用。</p>
</div>
<div class="sect2">
<h3 id="true角色声明"><a class="anchor" href="#true角色声明"></a>10.1. 角色声明</h3>
<div class="paragraph">
<p>声明 Roles 就像声明 Class 一样,  在 role 中声明属性和方法就像在 Raku 的类中声明属性和方法那样。
角色使用关键字  <code>role</code> 放在所声明的角色名称前面。角色使用 <code>does</code> 关键字 mixed in,  <code>does</code> 关键字放在角色名之前。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">constant dt = Date.today.DateTime;

role CheckingIn {
    has DateTime $.start = dt.later(hours =&gt; 9);
    has DateTime $.end   = $!start.later(hours =&gt; 12);
    has Bool $.saturday  = False;

    method hello() { "Good Moring!" }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true角色组合"><a class="anchor" href="#true角色组合"></a>10.2. 角色组合</h3>
<div class="paragraph">
<p>角色 <code>CheckingIn</code> 声明了三个属性: <code>s.start</code>、<code>$.end</code>、<code>$.saturday</code> 和一个方法 <code>hello</code>。<code>does</code> 会把角色中的属性和方法混到类里面, 就像这些属性和方法一开始就存在于类中一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class JJL does CheckingIn {
    has Str $.name;
    method working() {
        "{$!name}: has worked {self.end.hour - self.start.hour} hours."
    }

    method Str {
        self.hello();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们初始化类 <code>JJL</code> 的时候, 传递自有的属性和混合而来的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $jjl = JJL.new(
    :name('jjy')
    :start(DateTime.new(year =&gt; 2019, month =&gt; 4, day =&gt; 19, hour =&gt; 9)),
    :end(DateTime.new(year =&gt; 2019, month =&gt; 4, day =&gt; 19, hour =&gt; 20)),
    :saturday
     );
say $jjl.working();</code></pre>
</div>
</div>
<div class="paragraph">
<p>类只须声明某些特定的属性， 例如 <code>JJL</code> 中的 <code>$.name</code>。角色中的属性可以有默认值, 角色中的方法可以有默认实现, 也可以没有默认实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">role CheckingIn {
    method hello() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 <code>&#8230;&#8203;</code> 是 yadayada 运算符, 表示不实现该方法, 只是占位符。JJL 类可以实现/覆盖角色中的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class JJL does CheckingIn {
    method hello() { "implementation or overrite" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Class 中不能再声明和 Role 中同名的属性或方法!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Attribute '$!end' already exists in the class 'JJL', but a role also wishes to compose it at t.p6:11</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true角色冲突"><a class="anchor" href="#true角色冲突"></a>10.3. 角色冲突</h3>
<div class="paragraph">
<p>类可以继承多个角色, 如果所继承的角色中有同名的属性/方法, 那么继承后就会发生冲突:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">role Salary {
    has Bool $.saturday  = False;
    has $.dollar;

    method hello() { "Thans for your working!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们声明了一个新的角色 <code>Salary</code>, 其中  <code>$.saturday</code> 属性和 <code>hello()</code> 方法与角色 <code>CheckingIn</code> 中的同名, 我们同时继承这俩个角色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Employee does CheckingIn does Salary {
    has Str $.name;
    has Int $.age;

    method Str { self.hello() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会导致属性冲突:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Attribute '$!saturday' conflicts in role composition</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们注释掉 Salary 中的 <code>$!saturday</code>, 依然存在冲突</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Method 'hello' must be resolved by class Employee because it exists in multiple roles (Salary, CheckingIn)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再去掉 Salary 中的 <code>hello()</code> 方法, 冲突就消失了。所以避免冲突的方法是, 混合角色的时候注意同名属性和方法, 但这通常无法避免。</p>
</div>
</div>
<div class="sect2">
<h3 id="true匿名角色"><a class="anchor" href="#true匿名角色"></a>10.4. 匿名角色</h3>

</div>
<div class="sect2">
<h3 id="true实例化角色"><a class="anchor" href="#true实例化角色"></a>10.5. 实例化角色</h3>
<div class="paragraph">
<p>如果你实例化角色, 那么角色会变成类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">role Point {
    has $.x;
    has $.y;
    method abs { sqrt($.x * $.x + $.y * $.y) }
}

my $p = Point.new(x =&gt; 6, y =&gt; 8);
say $p ~~ Point;
say $p.abs;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">True
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>实例化角色 <code>Point</code> 之后, <code>$p</code> 变成了 <code>Point</code> 类了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truejunction"><a class="anchor" href="#truejunction"></a>11. Junction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="trueall"><a class="anchor" href="#trueall"></a>11.1. all</h3>
<div class="paragraph">
<p>查找当前目录下的所有以 <code>.md</code> 为后缀的文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">dir(test =&gt; all(/\.md$/))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueany"><a class="anchor" href="#trueany"></a>11.2. any</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @bad_ext = ('plx', 'pm', 'pl', 'p6');
my $file_ext = 'p6';
if lc($file_ext) eq any(@bad_ext) {
    say "$file_ext files is  allowed, You are a Perler";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1|2|3) + 4; # any(5, 6, 7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的表达式相当于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">5|6|7</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1|2) + (3&amp;4); # all(any(4, 5), any(5, 6))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truenone"><a class="anchor" href="#truenone"></a>11.3. none</h3>

</div>
<div class="sect2">
<h3 id="trueone"><a class="anchor" href="#trueone"></a>11.4. one</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Erwin_Schr%C3%B6dinger">薛定谔欧文</a>应该是喜欢 Raku 的, 因为他的著名的<a href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat">薛定谔的猫</a>可以用 Raku 的 <a href="https://docs.raku.org/type/Junction">Junction</a> 表达:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $cat = 'dead' | 'alive';
say "cat is both dead and alive" if $cat eq 'dead' and $cat eq 'alive';

# OUTPUT:
# cat is both dead and alive</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面发生了什么事情? 我会告诉你全部的!</p>
</div>
</div>
<div class="sect2">
<h3 id="trueany-2"><a class="anchor" href="#trueany-2"></a>11.5. any</h3>
<div class="paragraph">
<p>拿最简单的来说, Junctions 允许你把一堆值当作单个值。例如, 你可以使用 <code>any</code> Junction 来测试一个变量是否等于所给定值中的任意一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 'it matches!' if 'foo' eq 'foo' | 'bar' | 'ber';
say 'single-digit prime' if 5 == any ^9.grep: *.is-prime;

my @values = ^100;
say "it's in there!" if 42 == @values.any;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">it matches!
single-digit prime
it's in there!</code></pre>
</div>
</div>
<div class="paragraph">
<p>要从一堆值中创建一个 <code>any</code> Junction, 你可以使用 <code>|</code> 中缀操作符、调用 <code>any</code> 函数或者使用 <code>.any</code> 方法。上面的条件会返回 True 如果 Junction 中的任意一个(<code>any</code>) 值匹配所给定的值的话。事实上, 没有人能阻止你在两端都使用 Junction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @one = 1..10;
my @two = 5..15;
say "There's overlap!" if @one.any == @two.any;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">there's overlap!</code></pre>
</div>
</div>
<div class="paragraph">
<p>运算符会返回 True 如果 <code>@one</code> 中的任意一个值(<code>any</code>) 在数值上等于 <code>@two</code> 中的任意一个值(<code>any</code>)的话。这个语法糖很甜, 但是我们还可以做的更多。</p>
</div>
</div>
<div class="sect2">
<h3 id="trueall-for-one-and-any-for-none"><a class="anchor" href="#trueall-for-one-and-any-for-none"></a>11.6. All for One and Any for None</h3>
<div class="paragraph">
<p><code>any</code> Junction 唯一一个你能获得的 Junction。你还可以选择 <code>all</code>、<code>any</code>、<code>one</code> 和 <code>none</code>。当在布尔上下文中时, 它们的意思就像下面这样; 构建 Junction 的函数/方法名和 Junction 自身的名字一样并且下面还列出了构建 Junction 的中缀操作符:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>all</code> — 所有的值都被计算为 True(使用中缀 <code>&amp;</code>)</p>
</li>
<li>
<p><code>any</code> — 至少其中的一个值被计算为 True(使用中缀 <code>|</code>)</p>
</li>
<li>
<p><code>one</code> — 正好其中有一个值被计算为 True(使用中缀 <code>^</code>)</p>
</li>
<li>
<p><code>none</code> — 没有一个值被计算为 True(没有可用的中缀)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用 <code>all</code> JUnction 时要特别注意:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @values = 2, 3, 5;
say 'all primes' if @values.all ~~ *.is-prime;

my @moar-values;
say 'also all primes' if @moar-values.all ~~ *.is-prime;</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使它没有值的时候也会返回 True, 这可能不是你想要的。在那些情况下, 你可以使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @moar-values;
say 'also all primes' if @moar-values and @moar-values.all ~~ *.is-prime;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecall-me-baby"><a class="anchor" href="#truecall-me-baby"></a>11.7. Call Me, Baby</h3>
<div class="literalblock">
<div class="content">
<pre>你可以把 Junctions 用作并不期望 Junction 的子例程的参数。那么会发生什么呢? 对于每一个 Junctioned 的值, 那个子例程都会被调用一次, 并且返回值会是一个 Junction：</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"> sub caculate-things($n) {
     say "$n is prime"          if $n.is-prime;
     say "$n is an even number" if $n %% 2;
     say "$n is pretty big"     if $n &gt; 1e6;
     $n²;
 }

my @values = 1, 5, 42, 1e10.Int;
say 'EXACTLY ONE square is larger than 1e10'
    if 1e10 &lt; calculate-things @values.one;

# OUTPUT:
# 5 is a prime
# 42 is an even number
# 10000000000 is an even number
# 10000000000 is pretty big
# EXACTLY ONE square is larger than 1e10</code></pre>
</div>
</div>
<div class="paragraph">
<p>暴露的副作用可能有点太过神奇并且你可能不想在生产代码中看到它, 但是使用一个子例程来修改原来的 Junctioned 化的值是相当能接受的。执行一个数据库查询来获取"实际的"值并且在之后计算那个条件怎么样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">use DBIish;

my $dbh = DBIish.connect: 'SQLite', :database&lt;test.db&gt;;

sub lookup ($id) {
    given $dbh.prepare: 'SELECT id, text FROM stuff WHERE id = ?' {
        .execute: $id;
        .allrows[0][1] // '';
    }
}

my @ids = 3, 5, 10;
say 'yeah, it got it, bruh' if 'meow' eq lookup @ids.any;

# OUTPUT (the database has a row with id = 5 and text = 'meow'):
# yeah, it got it, bruh</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true我们一直在期盼你-请坐"><a class="anchor" href="#true我们一直在期盼你-请坐"></a>11.8. 我们一直在期盼你, 请坐。</h3>
<div class="paragraph">
<p>那个游戏变化了当你的子例程正好期望一个 Junction 作为参数的时候。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub do-stuff (Junction $n) {
    say 'value is even'  if $n %% 2;
    say 'value is prime' if $n.is-prime;
    say 'value is large' if $n &gt; 1e10;
}

do-stuff (2, 3, 1e11.Int).one;
say '---';
do-stuff (2, 3, 1e11.Int).any;

# OUTPUT:
# value is large
# ---
# value is even
# value is prime
# value is large</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们提供了一个 <code>one</code> Junction 时, 只有正好满足给定值中的其中一个条件才会被触发。当我们提供一个 <code>any</code> Junction 时, 满足条件的任何一个给定值都会触发。</p>
</div>
<div class="paragraph">
<p>但是! 你没有必要非等着世界为你分发 Junctions。你自己制造一个怎么样呢, 还能在测试条件时节省代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub do-stuff (*@v) {
    my $n = @v.one;
    say "$n is even"  if $n %% 2;
    say "$n is prime" if $n.is-prime;
    say "$n is large" if $n &gt; 1e10;
}

do-stuff 2, 3, 1e11.Int;
say '---';
do-stuff 42;

# OUTPUT:
# one(2, 3, 100000000000) is large
# ---
# one(42) is even</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true结论"><a class="anchor" href="#true结论"></a>11.9. 结论</h3>
<div class="paragraph">
<p>Raku 的 Junctions 是值的叠加态, 它允许你测试多个值就像它们是一个值一样。除了提供非常短并且易读的语法, Junctions 还允许你使用子例程变换叠加值或者使用副作用。</p>
</div>
<div class="paragraph">
<p>你还可以生成显式操作 Junctions 的子例程或者把提供的多个值转换成 Junctions 以简化代码。</p>
</div>
<div class="paragraph">
<p>最后, Junctions 被设计为能使用所有你计算机所提供的可用能力并且在不久的将来会做成自动线程化。</p>
</div>
<div class="paragraph">
<p>Junctions 很精彩, 使用它们, 玩的开心!</p>
</div>
<div class="listingblock">
<div class="title">生成含有26个英文字母和下划线的 junction</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">any('A'..'Z','a'..'z','_');</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">any(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, _)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">判断一个字符是否在某个集合中</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so any('A'..'Z','a'..'z') ∈ set("12a34".comb); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>"12a34".comb 会把字符串分割为单个字符，返回一个字符数组。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true正则表达式"><a class="anchor" href="#true正则表达式"></a>12. 正则表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正则表达式, 简称 regexes, 是描述文本模式的字符序列。模式匹配就是将这些模式和实际的文本进行匹配的过程。</p>
</div>
<div class="sect2">
<h3 id="true词法约定"><a class="anchor" href="#true词法约定"></a>12.1. 词法约定</h3>
<div class="paragraph">
<p>Raku 正则表达式有特殊的写法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">m/abc/;         # 立即与 $_ 匹配的正则表达式
rx/abc/;        # Regex 对象
/abc/;          # Regex 对象</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于前两个例子,  分隔符还能用除了斜线之外的其它字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">m{abc};
rx{abc};</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 冒号和圆括号都不能用作正则表达式分隔符; 不使用冒号作为正则表达式分割符是因为它和副词冲突, 例如 <code>rx:i/abc/</code>(忽略大小写的正则表达式), 而不用圆括号作为正则表达式分割符是因为圆括号表示函数调用。</p>
</div>
<div class="paragraph">
<p>空白符在正则表达式中通常被忽略(带有 <code>:s</code> 或 <code>:sigspace</code> 副词的正则表达式除外)。</p>
</div>
<div class="paragraph">
<p>通常, 对于 Raku 来说, 正则表达式中的注释以 # 号开头, 直至行尾。</p>
</div>
</div>
<div class="sect2">
<h3 id="true字面值"><a class="anchor" href="#true字面值"></a>12.2. 字面值</h3>
<div class="paragraph">
<p>正则表达式最简单的情况是匹配字符串字面值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'properly' ~~ m/ perl / {
    say "'properly' contains 'perl'";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>字母数字和下划线 _ 按字面值匹配。所有其它字符要么使用反斜线转义(例如, <code>\:</code> 匹配一个冒号), 要么用引号引起来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ 'two words' /     # 匹配 'two words' 包括空格
/ "a:b"       /     # 匹配 'a:b' 包括冒号
/ '#' /             # 匹配井字符</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串是从左往右搜索的, 所以如果只有部分字符串匹配正则表达式也足够:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abcdef' ~~ / de / {
    say ~$/;            # OUTPUT: «de␤»
    say $/.prematch;    # OUTPUT: «abc␤»
    say $/.postmatch;   # OUTPUT: «f␤»
    say $/.from;        # OUTPUT: «3␤»
    say $/.to;          # OUTPUT: «5␤»
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配结果存储在 <code>$/</code> 变量中并且也从匹配中返回。如果匹配成功, 那么结果就是 <a href="https://docs.raku.org/type/Match">Match</a> 类型, 否则它就是 <a href="https://docs.raku.org/type/Nil">Nil</a></p>
</div>
</div>
<div class="sect2">
<h3 id="true通配符和字符类"><a class="anchor" href="#true通配符和字符类"></a>12.3. 通配符和字符类</h3>
<div class="sect3">
<h4 id="true点号匹配任意字符"><a class="anchor" href="#true点号匹配任意字符"></a>12.3.1. 点号匹配任意字符: .</h4>
<div class="paragraph">
<p>在正则表达式中一个未转义的点 <code>.</code>  匹配任意单个字符。</p>
</div>
<div class="paragraph">
<p>所以,  这些都匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'perl' ~~ /per./;       # matches the whole string
'perl' ~~ / per . /;    # the same; whitespace is ignored
'perl' ~~ / pe.l /;     # the . matches the r
'speller' ~~ / pe.l/;   # the . matches the first l</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这个不匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'perl' ~~ /. per /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为在目标字符串中 <code>per</code> 前面没有要匹配的字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="true反斜杠-预定义字符类"><a class="anchor" href="#true反斜杠-预定义字符类"></a>12.3.2. 反斜杠, 预定义字符类</h4>

</div>
<div class="sect3">
<h4 id="trueunicode-properties"><a class="anchor" href="#trueunicode-properties"></a>12.3.3. Unicode properties</h4>
<div class="paragraph">
<p>Raku 有 <code>\w</code> 形式的预定义字符类。大写形式是它的反面, <code>\W</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\d 和 \D</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\d</code> 匹配单个数字(Unicode 属性 N) 而 <code>\D</code> 匹配单个不是数字的字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'ab42' ~~ /\d/ and say ~$/;     # OUTPUT: «4␤»
'ab42' ~~ /\D/ and say ~$/;     # OUTPUT: «a␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 不仅仅只有阿拉伯数字(通常用于拉丁字母表中)匹配 <code>\d</code>, 还有来自其它下标的数字也匹配 \d。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">U+0035 5 DIGIT FIVE
U+07C2 ߂ NKO DIGIT TWO
U+0E53 ๓ THAI DIGIT THREE
U+1B56 ᭖ BALINESE DIGIT SIX</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>\h 和 \H</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\h</code> 匹配单个水平空白符。 <code>\H</code> 匹配单个不是水平空白符的字符。</p>
</div>
<div class="paragraph">
<p>水平空白符的例子有:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">U+0020 SPACE
U+00A0 NO-BREAK SPACE
U+0009 CHARACTER TABULATION
U+2001 EM QUAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>像换行符那样的垂直空白被显式地排除了; 那些可以用 <code>\v</code> 来匹配, 而 <code>\s</code> 匹配任何类型的空白:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\n 和 \N</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\n</code> 匹配单个逻辑换行符。<code>\n</code> 也支持匹配 Windows 的 CR LF 代码点对儿;　尽管还不清楚魔法是发生在读取数据时还是在正则表达式匹配时。 <code>\N</code> 匹配单个非逻辑换行符。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\s 和 \S</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\s</code> 匹配单个空白符。 <code>\S</code> 匹配单个非空白符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'contains a word starting with "w"' ~~ / w \S+ / {
    say ~$/;        # OUTPUT: «word␤»
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>\t 和 \T</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\t</code> 匹配单个 tab/制表符, <code>U+0009</code>。(注意这儿不包含诸如 <code>U+000B VERTICAL TABULATION</code> 这样奇异的制表符)。<code>\T</code> 匹配单个非制表符。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\v 和 \V</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\v</code> 匹配单个垂直空白符。 <code>\V</code> 匹配单个非垂直空白符。</p>
</div>
<div class="paragraph">
<p>垂直空白符的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">U+000A LINE FEED
U+000B VERTICAL TABULATION
U+000C FORM FEED
U+000D CARRIAGE RETURN
U+0085 NEXT LINE
U+2028 LINE SEPARATOR
U+2029 PARAGRAPH SEPARATOR</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>\s</code> 去匹配任意空白, 而不仅仅匹配垂直空白。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\w 和 \W</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\w</code> 匹配单个单词字符; 例如: 一个字母(Unicode 类别 L), 一个数字或一个下划线。<code>\W</code> 匹配单个非单词字符。</p>
</div>
<div class="paragraph">
<p>单词字符的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">0041 A LATIN CAPITAL LETTER A
0031 1 DIGIT ONE
03B4 δ GREEK SMALL LETTER DELTA
03F3 ϳ GREEK LETTER YOT
0409 Љ CYRILLIC CAPITAL LETTER LJE</code></pre>
</div>
</div>
<div class="paragraph">
<p>预定义的 subrules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&lt;alnum&gt;   \w       'alpha' 加上 'digit'
&lt;alpha&gt;   &lt;:L&gt;     字母字符
&lt;blank&gt;   \h       水平空白
&lt;cntrl&gt;            控制字符
&lt;digit&gt;   \d       十进制数字
&lt;graph&gt;            'alnum' 加上 'punct'
&lt;lower&gt;   &lt;:Ll&gt;    小写字符
&lt;print&gt;            'graph' 加上 'space', 但是不含 'cntrl'
&lt;punct&gt;            标点符号 (只是在 ASCII 之外的标点)
&lt;space&gt;   \s       空白
&lt;upper&gt;   &lt;:Lu&gt;    大写字符
&lt;|wb&gt;              单词边界 (零宽断言)
&lt;ww&gt;               Within Word (零宽断言)
&lt;xdigit&gt;           十六进制数 [0-9A-Fa-f]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueunicode-属性"><a class="anchor" href="#trueunicode-属性"></a>12.3.4. Unicode 属性</h4>
<div class="paragraph">
<p>目前提到的字符类大多是为了方便; 另一种方法是使用 Unicode 字符属性。这些以 <code>&lt;:property&gt;</code> 的形式出现, 其中 <strong>property</strong> 可以是短形式的或长形式的 Unicode 一般类别名。它们使用 pair 语法。</p>
</div>
<div class="paragraph">
<p>要匹配一个 Unicode 属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"a".uniprop('Script');                 # OUTPUT: «Latin␤»
"a" ~~ / &lt;:Script&lt;Latin&gt;&gt; /;
"a".uniprop('Block');                  # OUTPUT: «Basic Latin␤»
"a" ~~ / &lt;:Block('Basic Latin')&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的 Unicode 通用类别表是从 Perl 5 的 <a href="http://perldoc.perl.org/perlunicode.html">perlunicode</a> 文档偷来的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Short	Long
L	Letter
LC	Cased_Letter
Lu	Uppercase_Letter
Ll	Lowercase_Letter
Lt	Titlecase_Letter
Lm	Modifier_Letter
Lo	Other_Letter
M	Mark
Mn	Nonspacing_Mark
Mc	Spacing_Mark
Me	Enclosing_Mark
N	Number
Nd	Decimal_Number (also Digit)
Nl	Letter_Number
No	Other_Number
P	Punctuation (also punct)
Pc	Connector_Punctuation
Pd	Dash_Punctuation
Ps	Open_Punctuation
Pe	Close_Punctuation
Pi	Initial_Punctuation
        (may behave like Ps or Pe depending on usage)
Pf	Final_Punctuation
        (may behave like Ps or Pe depending on usage)
Po	Other_Punctuation
S	Symbol
Sm	Math_Symbol
Sc	Currency_Symbol
Sk	Modifier_Symbol
So	Other_Symbol
Z	Separator
Zs	Space_Separator
Zl	Line_Separator
Zp	Paragraph_Separator
C	Other
Cc	Control (also cntrl)
Cf	Format
Cs	Surrogate
Co	Private_Use
Cn	Unassigned</code></pre>
</div>
</div>
<div class="paragraph">
<p>举个例子: <code>&lt;:Lu&gt;</code> 匹配单个大写字母。</p>
</div>
<div class="paragraph">
<p>它的反面是这个: <code>&lt;:!property&gt;</code>。所以, <code>&lt;:!Lu&gt;</code> 匹配单个非大写字母的字符。</p>
</div>
<div class="paragraph">
<p>Unicode 类别可以使用中缀运算符组合在一起:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Operator	Meaning
+	        并集
|	        并集
&amp;	        交集
-	        差集 (第一个减去第二个)
^	        对称交集 / XOR</code></pre>
</div>
</div>
<div class="paragraph">
<p>要匹配要么一个小写字母,要么一个数字, 可以写成 <code>&lt;:Ll+:N&gt;</code> 或 <code>&lt;:Ll+:Number&gt;</code> 或 <code>&lt;+ :Lowercase_Letter + :Number&gt;</code>。</p>
</div>
<div class="paragraph">
<p>使用圆括号将类别和一组类别分组也是可以的; 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'raku' ~~ m{\w+(&lt;:Ll+:N&gt;)}  # OUTPUT: «0 =&gt; ｢6｣␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true可枚举的字符类和区间"><a class="anchor" href="#true可枚举的字符类和区间"></a>12.3.5. 可枚举的字符类和区间</h4>
<div class="paragraph">
<p>有时候, 预先存在的通配符和字符类不够用。幸运的是, 定义你自己的字符类相当简单。在 <code>&lt;[]&gt;</code> 中, 你可以放入任何数量的单个字符和字符区间(两个端点之间有两个点号), 带有或不带有空白。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"abacabadabacaba" ~~ / &lt;[ a .. c 1 2 3 ]&gt; /;
# Unicode hex codepoint range
"ÀÁÂÃÄÅÆ" ~~ / &lt;[ \x[00C0] .. \x[00C6] ]&gt; /;
# Unicode named codepoint range
"ÀÁÂÃÄÅÆ" ~~ / &lt;[ \c[LATIN CAPITAL LETTER A WITH GRAVE] .. \c[LATIN CAPITAL LETTER AE] ]&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>&lt;&gt;</code> 中你可以使用 <code>+</code> 或 <code>-</code> 来添加或移除多个区间定义, 甚至混合某些上面的 unicode 属性。你还可以在 <code>[]</code> 之间写上反斜线形式的字符类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ &lt;[\d] - [13579]&gt; /;
# 以 \d 开始并移除 ASCII 奇数, 但是和下面这个不太一样
/ &lt;[02468]&gt; /;
# 因为第一个还包含"奇怪的" unicode 数字</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析引号分割的字符串的一个常见模式涉及到对字符类取反:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say '"in quotes"' ~~ / '"' &lt;-[ " ]&gt; * '"'/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这先匹配一个引号, 然后匹配任何不是引号的字符, 再然后还是一个引号。 上面例子中的 <code>*</code> 和 <code>+</code> 会在 <a href="https://docs.raku.org/language/regexes#Quantifiers">量词</a>一节中解释。</p>
</div>
<div class="paragraph">
<p>就像你可以使用 <code>-</code> 用于集合差集和取反单个值一样, 你也可以在前面显式地放上一个 <code>+</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ &lt;+[123]&gt; /  # 和 &lt;[123]&gt; 一样</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true量词"><a class="anchor" href="#true量词"></a>12.4. 量词</h3>
<div class="paragraph">
<p>量词使前面的原子匹配可变次数。例如, <code>a+</code> 匹配一个或多个字符 <strong>a</strong>。</p>
</div>
<div class="paragraph">
<p>量词比连结绑定的更紧, 所以 <code>ab+</code> 匹配一个 <strong>a</strong>, 然后跟着一个或多个 <strong>b</strong>。对于引号来说, 有点不同, 所以 <code>'ab'+</code> 匹配字符串 <strong>ab</strong>, <strong>abab</strong>, <strong>ababab</strong> 等等。</p>
</div>
<div class="sect3">
<h4 id="true一次或多次"><a class="anchor" href="#true一次或多次"></a>12.4.1. 一次或多次:<br></h4>
<div class="paragraph">
<p><code>+</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
</div>
<div class="paragraph">
<p>例如, 要匹配 <code>form=value</code> 形式的字符串, 你可以这样写正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ \w+ '=' \w+ /</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true零次或多次"><a class="anchor" href="#true零次或多次"></a>12.4.2. 零次或多次: *</h4>
<div class="ulist">
<ul>
<li>
<p>量词使它前面的原子匹配零次或多次, 没有次数上限。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如, 要允许 <strong>a</strong> 和 <strong>b</strong> 之间出现可选的空白,  你可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ a \s* b /</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true零次或一次匹配"><a class="anchor" href="#true零次或一次匹配"></a>12.4.3. 零次或一次匹配: ?</h4>
<div class="paragraph">
<p><code>?</code> 量词使它前面的原子匹配零次或一次。</p>
</div>
</div>
<div class="sect3">
<h4 id="true常规量词-min-max"><a class="anchor" href="#true常规量词-min-max"></a>12.4.4. 常规量词: ** min..max</h4>
<div class="paragraph">
<p>要限定原子匹配任意次数,　你可以写出像 a ** 2..5 那样的表达式来匹配字符 <em>a</em> 至少 2 次, 至多 5 次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'a' ~~ /a ** 2..5/;        # OUTPUT: «False␤»
say so  'aaa' ~~ /a ** 2..5/;     # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果最小匹配次数和最大匹配次数相同, 那么使用单个整数: a ** 5 精确地匹配 5 次。</p>
</div>
<div class="listingblock">
<div class="title">match <code>a</code> exactly 5 times</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'aaaaa' ~~ /a ** 5/;       # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用 <code>^</code> 脱字符来排除区间的端点:</p>
</div>
<div class="listingblock">
<div class="title">exclude endpoint</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'a'    ~~ /a ** 1^..^6/;   # OUTPUT: «False␤»
say so 'aaaa' ~~ /a ** 1^..^6/;   # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这个包含从 0 开始的数值区间:</p>
</div>
<div class="listingblock">
<div class="title">there are 0 to 5 'a&#8217;s in a row</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'aaa' ~~ /a ** ^6/;        # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用一个 Whatever Star <code>*</code> 操作符来表示无限区间:</p>
</div>
<div class="listingblock">
<div class="title">Whatever star in the right endpoint indicating infinite range</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'aaaa' ~~ /a ** 1^..*/;    # OUTPUT: «True␤» -- there are 2 or more 'a's in a row</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true修饰符量词"><a class="anchor" href="#true修饰符量词"></a>12.4.5. 修饰符量词: %</h4>
<div class="paragraph">
<p>为了更容易地匹配逗号分割那样的值, 可以在以上任何一个量词的后面加上一个 <code>%</code> 修饰符以指定某个分割符必须出现在每一次匹配之间。例如, <code>a+ % ','</code> 会匹配 <strong>a</strong>, 或 <strong>a,a</strong> 或 <strong>a,a,a</strong> 等等, 但是不会匹配 <strong>a,</strong> 或 <strong>a,a,</strong> 等。要连这些也要匹配, 那么使用 <code>%%</code> 代替 <code>%</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'12,23,34' ~~ / [\d+]+ % ',' /</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true贪婪量词-vs-非贪婪量词"><a class="anchor" href="#true贪婪量词-vs-非贪婪量词"></a>12.4.6. 贪婪量词 Vs. 非贪婪量词: ?</h4>
<div class="paragraph">
<p>默认地, 量词要求进行贪婪匹配:</p>
</div>
<div class="listingblock">
<div class="title">dot plus star means greedy match</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'abababa' ~~ /a .* a/ &amp;&amp; say ~$/;   # OUTPUT: «abababa␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以给量词附加一个 <code>?</code> 修饰符来开启非贪婪匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">'abababa' ~~ /a .*? a/ &amp;&amp; say ~$/;   # OUTPUT: «aba␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>!</code> 修饰符显式地要求贪婪匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="true阻止回溯"><a class="anchor" href="#true阻止回溯"></a>12.4.7. 阻止回溯: :</h4>
<div class="paragraph">
<p>你可以在正则表达式中通过为量词附加一个 <code>:</code> 修饰符来阻止回溯:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'abababa' ~~ /a .* aba/;    # OUTPUT: «True␤»
say so 'abababa' ~~ /a .*: aba/;   # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truealternation"><a class="anchor" href="#truealternation"></a>12.5. Alternation: ||</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/regexes#Alternation:_||">||</a> 在正则表达式中表示备选分支, 在匹配由 <code>||</code> 分割的几个可能的备选分支之一时, <strong>第一个</strong>匹配的备选分支胜出。例如, <strong>ini</strong> 文件有如下形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="ini" class="language-ini hljs">[section]
key = value</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 如果你解析单行 <strong>ini</strong> 文件, 那么它要么是一个 section, 要么是一个键值对儿。所以正则表达式可以是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ '[' \w+ ']' || \S+ \s* '=' \s* \S* /</code></pre>
</div>
</div>
<div class="paragraph">
<p>即, 它要么是一个由方括号包围起来的单词, 要么是一个键值对。</p>
</div>
</div>
<div class="sect2">
<h3 id="truelongest-alternation"><a class="anchor" href="#truelongest-alternation"></a>12.6. Longest Alternation: |</h3>
<div class="paragraph">
<p>如果正则表达式由 <code>|</code> 分割, 则最长的那个匹配胜出。独立于正则表达式中的词法顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say ('abc' ~~ / a | .b /).Str;    # OUTPUT: «ab␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配一组单词中的任意一个, 就在正则表达式中写上那个数组名好了（以 <code>@</code> 开头）。默认地，这被插值为 <code>|</code> 备选分支（“<strong>longest match</strong>”），但是你也可以把他指定为 <code>||</code> 备选分支（“<strong>first match</strong>”）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a = &lt;foo bar barkeep&gt;;
say "barkeeper" ~~ / @a /;     # ｢barkeep｣
say "barkeeper" ~~ / |@a /;    # ｢barkeep｣
say "barkeeper" ~~ / || @a /;  # ｢bar｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>/@a/</code> 和 <code>/|@a/</code> 是等价的, 都会被解析成 <code>/ foo | bar | barkeep /</code>; 而 <code>/|| @a/</code> 会被解析成 <code>/ foo || bar || barkeep /</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="true锚点"><a class="anchor" href="#true锚点"></a>12.7. 锚点</h3>
<div class="paragraph">
<p>正则表达式引擎尝试在字符串中从左至右地搜索来查找匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'properly' ~~ / perl/;   # OUTPUT: «True␤»
#          ^^^^</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时候这不是你想要的。相反, 你可能只想匹配整个字符串, 或一整行, 或精确地一个或几个完整的单词。锚点或零宽断言能帮助我们。</p>
</div>
<div class="paragraph">
<p>为了整个正则表达式能够匹配, 零宽断言需要被成功地匹配但是零宽断言在匹配时不消耗字符。</p>
</div>
<div class="sect3">
<h4 id="true-字符串的开头-字符串的末尾"><a class="anchor" href="#true-字符串的开头-字符串的末尾"></a>12.7.1. ^ , 字符串的开头, $ , 字符串的末尾</h4>
<div class="paragraph">
<p><code>^</code> 断言只匹配字符串的开头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'properly' ~~ /  perl/;    # OUTPUT: «True␤»
say so 'properly' ~~ /^ perl/;    # OUTPUT: «False␤»
say so 'perly'    ~~ /^ perl/;    # OUTPUT: «True␤»
say so 'perl'     ~~ /^ perl/;    # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$</code> 断言只匹配字符串的末尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'use perl' ~~ /  perl  /;   # OUTPUT: «True␤»
say so 'use perl' ~~ /  perl $/;   # OUTPUT: «True␤»
say so 'perly'    ~~ /  perl $/;   # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以把这两个断言组合起来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'use perl' ~~ /^ perl $/;   # OUTPUT: «False␤»
say so 'perl'     ~~ /^ perl $/;   # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>记住, <code>^</code> 匹配<strong>字符串</strong>的开头, 而非<strong>行</strong>的开头。同样地, <code>$</code> 匹配<strong>字符串</strong>的结尾, 而非<strong>行</strong>的结尾。</p>
</div>
<div class="paragraph">
<p>下面的是多行字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = q:to/EOS/;
   Keep it secret
   and keep it safe
   EOS

say so $str ~~ /safe   $/;   # OUTPUT: «True␤»  -- 'safe' is at the end of the string
say so $str ~~ /secret $/;   # OUTPUT: «False␤» -- 'secret' is at the end of a line -- not the string
say so $str ~~ /^Keep   /;   # OUTPUT: «True␤»  -- 'Keep' is at the start of the string
say so $str ~~ /^and    /;   # OUTPUT: «False␤» -- 'and' is at the start of a line -- not the string</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true-匹配行的开头-匹配行的末尾"><a class="anchor" href="#true-匹配行的开头-匹配行的末尾"></a>12.7.2. ^^ 匹配行的开头, $$ 匹配行的末尾</h4>
<div class="paragraph">
<p><code>^^</code> 断言匹配逻辑行的开头。即, 要么在字符串的开头, 要么在换行符之后。然而, 它不匹配字符串的结尾, 即使它以一个换行符结尾。</p>
</div>
<div class="paragraph">
<p><code>$$</code> 只匹配逻辑换行符的结尾, 即, 在换行符之前, 或在字符串的结尾, 当最后一个字符不是换行符时。</p>
</div>
<div class="paragraph">
<p>(为了理解下面的示例, 最好先了解 <code>q:to/EOS/&#8230;&#8203;EOS</code> 的 "heredoc" 语法移除了前置的缩进, 使之与 <code>EOS</code> 标记同级, 以至于第一行, 第二行和最后一行没有前置空格而第三行和第四行各有两个前置空格。)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = q:to/EOS/;
    There was a young man of Japan
    Whose limericks never would scan.
      When asked why this was,
      He replied "It's because
    I always try to fit as many syllables into the last line as ever I possibly can."
    EOS

say so $str ~~ /^^ There/;        # OUTPUT: «True␤»  -- start of string
say so $str ~~ /^^ limericks/;    # OUTPUT: «False␤» -- not at the start of a line
say so $str ~~ /^^ I/;            # OUTPUT: «True␤»  -- start of the last line
say so $str ~~ /^^ When/;         # OUTPUT: «False␤» -- there are blanks between
                                  #                       start of line and the "When"

say so $str ~~ / Japan $$/;       # OUTPUT: «True␤»  -- end of first line
say so $str ~~ / scan $$/;        # OUTPUT: «False␤» -- there's a . between "scan"
                                  #                      and the end of line
say so $str ~~ / '."' $$/;        # OUTPUT: «True␤»  -- at the last line</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truew-和-w-单词边界"><a class="anchor" href="#truew-和-w-单词边界"></a>12.7.3. &lt;|w&gt; 和 &lt;!|w&gt;, 单词边界</h4>
<div class="paragraph">
<p>要匹配单词边界, 使用 <code>&lt;|w&gt;</code>。这与其它语言的 <code>\b</code> 类似，要匹配一个非单词边界, 使用 <code>&lt;!|w&gt;</code>, 类似其它语言的 <code>\B</code>。这些都是零宽断言。</p>
</div>
</div>
<div class="sect3">
<h4 id="true-和-左右单词边界"><a class="anchor" href="#true-和-左右单词边界"></a>12.7.4. &lt;&lt; 和 &gt;&gt; , 左右单词边界</h4>
<div class="paragraph">
<p><code>&lt;&lt;</code> 匹配左单词边界。它匹配左侧(或者字符串的开头)是非单词字符而右侧是一个单词字符的位置。</p>
</div>
<div class="paragraph">
<p><code>&gt;&gt;</code> 匹配右单词边界。它匹配左侧有一个单词字符而右侧(或者字符串的结尾)是一个非单词字符的位置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = 'The quick brown fox';
say so $str ~~ /br/;              # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; br/;           # OUTPUT: «True␤»
say so $str ~~ /br &gt;&gt;/;           # OUTPUT: «False␤»
say so $str ~~ /own/;             # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; own/;          # OUTPUT: «False␤»
say so $str ~~ /own &gt;&gt;/;          # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用变体 <strong>«</strong> 和 <strong>»</strong> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = 'The quick brown fox';
say so $str ~~ /« own/;          # OUTPUT: «False␤»
say so $str ~~ /own »/;          # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true分组和捕获"><a class="anchor" href="#true分组和捕获"></a>12.8. 分组和捕获</h3>
<div class="paragraph">
<p>在普通的(非正则表达式)Raku 代码中, 你可以使用圆括号把东西组织到一块, 通常用于覆盖操作符优先级:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 1+4*2;   # 9, parsed as 1 + (4*2)
say (1+4)*2; # 输出: 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>在正则表达式中也可以使用同样的分组工具:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ a || b c/;   # 匹配 'a' 或 'bc'
/ (a || b) c/; # 匹配 'ac' 或 'bc'</code></pre>
</div>
</div>
<div class="paragraph">
<p>分组可以应用在量词上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ a b+ /;      # 匹配一个 'a', 后面再跟着一个或多个 'b'
/ (a b)+/;     # 匹配一个或多个 'ab' 序列
/ (a || b)+ /; # 匹配一个 'a' 序列或者 'b' 序列, 至少一次</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个非量词化的捕获产生一个 <a href="https://docs.raku.org/type/Match">Match</a> 对象。当捕获被量词化(除了使用 <code>?</code> 量词)之后, 该捕获就变成 <a href="https://docs.raku.org/type/Match">Match</a> 对象的列表。</p>
</div>
<div class="sect3">
<h4 id="true捕获"><a class="anchor" href="#true捕获"></a>12.8.1. 捕获</h4>
<div class="paragraph">
<p>圆括号不仅仅能够分组, 它们也 <strong>捕获</strong>; 也就是说, 它们使分组中匹配到的字符串用作变量，并且还作为生成的  <a href="https://docs.raku.org/type/Match">Match</a> 对象的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $str = 'number 42';
if $str ~~ /'number' (\d+) / {
    say "The number is $0";    # The number is 42
    # or
    say "The number is $/[0]"; # The number is 42
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>圆括号对儿是从左到右编号的, 编号从零开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc' ~~ /(a) b (c)/ {
    say "0:$0; 1:$1"; # 输出: 0:a; 1:c
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$0</code> 和 <code>$1</code> 等语法是简写的。这些捕获可以从用作列表的匹配对象 <code>$/</code> 中规范地获取到, 所以, <code>$0</code> 实际上是 <code>$/[0]</code> 的语法糖。</p>
</div>
<div class="paragraph">
<p>将匹配对象强制转换为列表可以方便地以编程方式访问所有元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc' ~~ /(a) b (c)/ {
    say $/.list.join: ','; # 输出 a,c
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true非捕获分组"><a class="anchor" href="#true非捕获分组"></a>12.8.2. 非捕获分组</h4>
<div class="paragraph">
<p>正则表达式中的圆括号扮演了双重角色: 它们将内部的正则表达式元素分组, 并通过内部的子正则表达式捕获所匹配到的内容。</p>
</div>
<div class="paragraph">
<p>要仅仅获得分组行为, 可以使用方括号 <code>[&#8230;&#8203;]</code> 代替圆括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc' ~~ / [a||b] (c) / {
    say ~$0;                # OUTPUT: «c␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不需要捕获, 则使用非捕获分组可提供三个好处: 它们更干净地传达正则表达式; 它们使您更容易对您关心的捕获组计数; 并且它匹配比较快。</p>
</div>
</div>
<div class="sect3">
<h4 id="true捕获编号"><a class="anchor" href="#true捕获编号"></a>12.8.3. 捕获编号</h4>
<div class="paragraph">
<p>上面已经说明，捕获从左到右编号。 原则上是真的，这也是过于简单的。</p>
</div>
<div class="paragraph">
<p>为了完整起见，列出了以下规则。 当您发现自己经常使用它们时，考虑命名捕获（可能是 subrules）是值得的。</p>
</div>
<div class="paragraph">
<p>备选分支会重置捕获计数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ (x) (y)  || (a) (.) (.) /
# $0  $1      $0  $1  $2</code></pre>
</div>
</div>
<div class="paragraph">
<p>例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc' ~~ /(x)(y) || (a)(.)(.)/ {
    say ~$1;            # b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果两个（或多个）备选分支具有不同的捕获编号，则捕获编号最多的决定了下一个捕获的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = 'abcd';

if / a [ b (.) || (x) (y) ] (.) / {
    #      $0     $0  $1    $2
    say ~$2;           # d
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>捕获可以嵌套，在这种情况下，它们的每一级都会编号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc' ~~ / ( a (.) (.) ) / {
    say "Outer: $0";                # Outer: abc
    say "Inner: $0[0] and $0[1]";   # Inner: b and c
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true命名捕获"><a class="anchor" href="#true命名捕获"></a>12.8.4. 命名捕获</h4>
<div class="paragraph">
<p>除了给捕获编号，你也可以给他们起名字。 命名捕获的通用和略微冗长的方式是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc' ~~ / $&lt;myname&gt; = [ \w+ ] / {
    say ~$&lt;myname&gt;      # OUTPUT: «abc␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对命名捕获 <strong>$&lt;myname&gt;</strong> 的访问是将匹配对象作为哈希索引的简写，换句话说：<code>$/{'myname'}</code> 或 <code>$/&lt;myname&gt;</code>。</p>
</div>
<div class="paragraph">
<p>命名捕获也可以使用常规捕获分组语法进行嵌套:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'abc-abc-abc' ~~ / $&lt;string&gt;=( [ $&lt;part&gt;=[abc] ]* % '-' ) / {
    say ~$&lt;string&gt;;         # OUTPUT: «abc-abc-abc␤»
    say ~$&lt;string&gt;&lt;part&gt;;   # OUTPUT: «[abc, abc, abc]␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将匹配对象强制为散列可让您轻松地以编程方式访问所有命名捕获:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if 'count=23' ~~ / $&lt;variable&gt;=\w+ '=' $&lt;value&gt;=\w+ / {
    my %h = $/.hash;
    say %h.keys.sort.join: ', ';        # OUTPUT: «value, variable␤»
    say %h.values.sort.join: ', ';      # OUTPUT: «23, count␤»

    for %h.kv -&gt; $k, $v {
        say "Found value '$v' with key '$k'";
        # outputs two lines:
        #   Found value 'count' with key 'variable'
        #   Found value '23' with key 'value'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Subrules 部分会讨论获取命名捕获的更方便的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="true捕获标记"><a class="anchor" href="#true捕获标记"></a>12.8.5. 捕获标记: &lt;( )&gt;</h4>
<div class="paragraph">
<p><code>&lt;(</code> token 表示匹配的整体捕捉的开始，而相应的 <code>)&gt;</code> token 表示其末端。 <code>&lt;(</code> 类似于其他语言的 <code>\K</code> 丢弃 <code>\K</code> 之前找到的任何匹配项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true替换"><a class="anchor" href="#true替换"></a>12.9. 替换</h3>
<div class="paragraph">
<p>正则表达式也可以用来替换另一个文本。 您可以使用它来解决拼写错误(例如, 用 "Pearl Jam" 替换 "Perl Jam"), 从 <code>yyyy-mm-ddThh:mm:ssZ</code> 到 <code>mm-dd-yy h:m {AM,PM}</code> 重新格式化 ISO8601 日期及其它。</p>
</div>
<div class="paragraph">
<p>就像搜索替换编辑器的对话框一样，<code>s///</code> 操作符有两面，左侧和右侧。 左侧是匹配表达式的位置，右侧是您要替换的表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="true词汇约定"><a class="anchor" href="#true词汇约定"></a>12.10. 词汇约定</h3>
<div class="paragraph">
<p>替换和匹配的写法类似，但替换运算符既有正则表达式匹配的区域，也有替换的文本区域：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">s/replace/with/;           # a substitution that is applied to $_
$str ~~ s/replace/with/;   # a substitution applied to a scalar</code></pre>
</div>
</div>
<div class="paragraph">
<p>替换操作法允许除了斜线之外的分隔符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">s|replace|with|;
s!replace!with!;
s,replace,with,;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 冒号和诸如 <code>{}</code> 或 <code>()</code> 的分隔符不能作为替换分割符。带有副词的冒号斜线诸如 <code>s:i/Foo/Bar</code> 和其它分割符有其它用途。</p>
</div>
<div class="paragraph">
<p>就像 <code>m//</code> 操作符一样, 通常会忽略空白。在 Raku 中, 注释以 <strong>#</strong> 号开头直到当前行的结尾。</p>
</div>
</div>
<div class="sect2">
<h3 id="true替换字符串字面值"><a class="anchor" href="#true替换字符串字面值"></a>12.11. 替换字符串字面值</h3>
<div class="paragraph">
<p>要替换的最简单的东西就是字符串字面量。你要替换的字符串在替换运算符的左侧, 而替换它的字符串在替换操作符的右侧; 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = 'The Replacements';
s/Replace/Entrap/;
.say;                    # OUTPUT: «The Entrapments␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>字母数字字符和下划线是文字匹配，就像其表哥 <code>m//</code> 操作符一样。 所有其他字符都必须使用反斜杠 <code>\</code> 转义，或包含在引号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = 'Space: 1999';
s/Space\:/Party like it's/;
.say                        # OUTPUT: «Party like it's 1999␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，匹配约束仅适用于替换表达式的左侧。</p>
</div>
<div class="paragraph">
<p>默认情况下，替换仅在第一匹配中完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = 'There can be twly two';
s/tw/on/;                     # replace 'tw' with 'on' once
.say;                         # OUTPUT: «there can be only two␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true通配符和字符类-2"><a class="anchor" href="#true通配符和字符类-2"></a>12.12. 通配符和字符类</h3>
<div class="paragraph">
<p>任何可以进入 <code>m//</code> 操作符的内容都可以进入替换操作符的左侧，包括通配符和字符类。 当您匹配的文本不是静态的时，这很方便，例如尝试匹配字符串中间的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = "Blake's 9";
s/\d+/7/;         # replace any sequence of digits with '7'
.say;             # OUTPUT: «Blake's 7␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，你可以使用任何 <code>+</code>，<code>*</code> 和 <code>?</code> 修饰符，它们的行为就像在 <code>m//</code> 操作符的上下文中一样。</p>
</div>
</div>
<div class="sect2">
<h3 id="true捕获组"><a class="anchor" href="#true捕获组"></a>12.13. 捕获组</h3>
<div class="paragraph">
<p>就像在匹配运算符中一样，捕获组在左侧被允许，匹配的内容填充 <code>$0..$n</code> 变量和 <code>$/</code> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = '2016-01-23 18:09:00';
s/ (\d+)\-(\d+)\-(\d+) /today/;   # replace YYYY-MM-DD with 'today'
.say;                             # OUTPUT: «today 18:09:00␤»
"$1-$2-$0".say;                   # OUTPUT: «01-23-2016␤»
"$/[1]-$/[2]-$/[0]".say;          # OUTPUT: «01-23-2016␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何这些变量 <code>$0</code>，<code>$1</code>，<code>$/</code> 也可以在运算符的右侧使用，所以你可以操纵你刚刚匹配的内容。 这样，您可以将日期的YYYY，MM和DD部分分开，并将其重新格式化为 <code>MM-DD-YYYY</code> 顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = '2016-01-23 18:09:00';
s/ (\d+)\-(\d+)\-(\d+) /$1-$2-$0/;    # transform YYYY-MM-DD to MM-DD-YYYY
.say;                                 # OUTPUT: «01-23-2016 18:09:00␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于右侧实际上是一个常规的 Raku 内插字符串，因此可以将时间从 <code>HH:MM</code> 重新格式化为 `h:MM {AM,PM} 格式, 如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$_ = '18:38';
s/(\d+)\:(\d+)/{$0 % 12}\:$1 {$0 &lt; 12 ?? 'AM' !! 'PM'}/;
.say;                                                    # OUTPUT: «6:38 PM␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用上面的模数 <code>%</code> 运算符将样本代码保留在80个字符以下，否则就是 <code>$0 &lt;12 ?? $0 !! $0 - 12</code>。 结合解析器表达式语法的强大功能，真正使您在这里看到的内容成为可能，您可以使用“正则表达式”来解析任何文本。</p>
</div>
</div>
<div class="sect2">
<h3 id="true用于嵌套结构的波浪号"><a class="anchor" href="#true用于嵌套结构的波浪号"></a>12.14. 用于嵌套结构的波浪号</h3>
<div class="paragraph">
<p><code>~</code> 运算符是一个帮助器，用于匹配具有特定终结符的嵌套子规则作为目标。 它被设计为放置在开口和闭合括号之间，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ '(' ~ ')' &lt;expression&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 它主要忽略左侧的参数, 并且在接下来的两个原子（可以被量化）上操作。 它对下两个原子的操作是“旋转”它们，使得它们实际上以相反的顺序匹配。 因此，上面的表达式，乍一看，只不过是下面的简写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ '(' &lt;expression&gt; ')' /</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是除此之外，当它重写原子时，它还会插入将设置内部表达式以识别终止符的装置，并且如果内部表达式不在所需的闭合原子上终止，则产生适当的错误消息。 所以它确实也注意了左边的括号，它实际上把我们的例子改写成更像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$&lt;OPEN&gt; = '(' &lt;SETGOAL: ')'&gt; &lt;expression&gt; [ $GOAL || &lt;FAILGOAL&gt; ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>FAILGOAL 是一种可以由用户定义的特殊方法，它将在解析失败时被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar A { token TOP { '[' ~ ']' \w+  };
            method FAILGOAL($goal) {
                die "Cannot find $goal near position {self.pos}"
            }
}

say A.parse: '[good]';  # OUTPUT: «｢[good]｣␤»
A.parse: '[bad';        # will throw FAILGOAL exception
CATCH { default { put .^name, ': ', .Str } };
# OUTPUT: «X::AdHoc: Cannot find ']'  near position 4␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使没有开口分隔符，也可以使用此构造来设置闭合结构的期望值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"3)"  ~~ / &lt;?&gt; ~ ')' \d+ /;  # RESULT: «｢3)｣»
"(3)" ~~ / &lt;?&gt; ~ ')' \d+ /;  # RESULT: «｢3)｣»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>&lt;?&gt;</code> 在第一个空字符串中返回true。</p>
</div>
<div class="paragraph">
<p>正则表达式捕获的顺序是原始的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">"abc" ~~ /a ~ (c) (b)/;
say $0; # OUTPUT: «｢c｣␤»
say $1; # OUTPUT: «｢b｣␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truesubrules"><a class="anchor" href="#truesubrules"></a>12.15. Subrules</h3>
<div class="paragraph">
<p>就像你可以把代码片段放进子例程中一样, 你同样可以把正则表达式片段放进命名规则中(named rules)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex line { \N*\n }
if "abc\ndef" ~~ /&lt;line&gt; def/ {
    say "First line:", $&lt;line&gt;.chomp; # OUTPUT:«First line: abc␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名正则可以使用 <code>my regex named-regex { body here }</code> 来声明, 并使用 <code>&lt;named-regex&gt;</code> 来调用。与此同时, 调用命名正则的时候会安装一个同名的命名捕获。</p>
</div>
<div class="paragraph">
<p>要给捕获起一个和 regex 不同的名字, 那么使用 <code>&lt;capture-name=named-regex&gt;</code> 语法。如果不想捕获, 那么使用一个前置的点号来抑制捕获: <code>&lt;.named-regex&gt;</code>。如果它是在同一个类或 grammar 中声明的方法, 那么在同一个词法上下文中会为该正则声明一个 <code>&lt;&amp;named-regex&gt;</code></p>
</div>
<div class="paragraph">
<p>下面是一个更完善的解析 ini 文件的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex header { \s* '[' (\w+) ']' \h* \n+ }
my regex identifier  { \w+ }
my regex kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }
my regex section {
    &lt;header&gt;
    &lt;kvpair&gt;*
}

my $contents = q:to/EOI/;
    [passwords]
        jack=password1
        joy=muchmoresecure123
    [quotas]
        jack=123
        joy=42
EOI

my %config;
if $contents ~~ /&lt;section&gt;*/ {
    for $&lt;section&gt;.list -&gt; $section {
        my %section;
        for $section&lt;kvpair&gt;.list -&gt; $p {
            %section{ $p&lt;key&gt; } = ~$p&lt;value&gt;;
        }
        %config{ $section&lt;header&gt;[0] } = %section;
    }
}
say %config.perl;

# OUTPUT: «{:passwords(${:jack("password1"), :joy("muchmoresecure123")}),
#           :quotas(${:jack("123"), :joy("42")})}»</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名正则可以规整到 <a href="https://docs.raku.org/language/grammars">gramamrs</a> 中。<a href="https://design.raku.org/S05.html#Predefined_Subrules)">S05-regex</a> 中有一组预定义的 subrules。</p>
</div>
</div>
<div class="sect2">
<h3 id="true副词-3"><a class="anchor" href="#true副词-3"></a>12.16. 副词</h3>
<div class="paragraph">
<p>副词修改正则表达式的工作方式, 并为某些类型的循环任务提供方便的快捷方式。</p>
</div>
<div class="paragraph">
<p>有两种副词: 正则表达式副词适用于定义正则表达式时, 匹配副词适用于正则表达式与字符串匹配时。</p>
</div>
<div class="paragraph">
<p>这种区别往往是模糊的, 因为匹配和声明通常是文本上关闭的, 但使用方法形式的匹配使得区分清晰一点。</p>
</div>
<div class="paragraph">
<p><code>'abc' ~~ /../</code> 大致相当于 <code>'abc'.match(/../)</code>, 甚至可以更清楚地单独写成一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $regex = /../;           # definition
if 'abc'.match($regex) {    # matching
    say "'abc' has at least two characters";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式副词像 <code>:i</code> 会进入定义行而匹配副词像 <code>:overlap</code> 会附加到匹配调用上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $regex = /:i . a/;
for 'baA'.match($regex, :overlap) -&gt; $m {
    say ~$m;
}
# OUTPUT: «ba␤aA␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true正则表达式副词"><a class="anchor" href="#true正则表达式副词"></a>12.17. 正则表达式副词</h3>
<div class="paragraph">
<p>在正则表达式声明时出现的副词是实际正则表达式的一部分, 并影响 Raku 编译器如何将正则表达式转换为二进制代码。</p>
</div>
<div class="paragraph">
<p>例如: <code>:ignorecase (:i)</code> 副词告诉编译器忽略大写, 小写和标题大小写字母之间的区别。</p>
</div>
<div class="paragraph">
<p>所以 <code>'a'~~ /A/</code> 是假的, 但 <code>'a' ~~ /:i A /</code> 是一个成功的匹配。</p>
</div>
<div class="paragraph">
<p>正则表达式副词可以在正则表达式声明之前或之内, 并且仅在词法上影响其后的正则表达式部分。 请注意, 在正则表达式之前出现的正则表达式副词必须出现在将正则表达式引入解析器之后, 如 <code>rx</code> 或 <code>m</code> 或裸的 <code>/</code>。 但是这样是无效的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $rx1 = :i/a/;      # adverb is before the regex is recognized =&gt; exception</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这些是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $rx1 = rx:i/a/;      # before
my $rx2 = rx/:i a/;     # inside</code></pre>
</div>
</div>
<div class="paragraph">
<p>而下面这两种是不等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $rx3 = rx/a :i b/;   # matches only the b case insensitively
my $rx4 = rx/:i a b/;   # matches completely case insensitively</code></pre>
</div>
</div>
<div class="paragraph">
<p>方括号和圆括号约束副词的作用域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ (:i a b) c /;         # matches 'ABc' but not 'ABC'
/ [:i a b] c /;         # matches 'ABc' but not 'ABC'</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="trueratchet"><a class="anchor" href="#trueratchet"></a>12.17.1. Ratchet</h4>
<div class="paragraph">
<p><code>:ratchet</code> 或 <code>:r</code> 副词会导致正则表达式引擎不回溯。</p>
</div>
<div class="paragraph">
<p>假如没有这个副词, 那么正则表达式的一部分将尝试不同的路径来匹配字符串, 以使正则表达式的其他部分可以匹配。 例如, 在 <code>'abc' ~~ / \w+ ./</code> 中, <code>\w+</code> 首先吃光整个字符串 abc, 然后 <code>.</code> 就失败了。 因此 <code>\w+</code> 放弃一个字符, 只匹配 ab 而 <code>.</code> 可以成功匹配字符串 c。 放弃字符的过程(或在轮试的情况下, 尝试不同的分支)被称为回溯。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so 'abc' ~~ / \w+ . /;        # OUTPUT: «True␤»
say so 'abc' ~~ / :r \w+ . /;     # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ratcheting 是一种优化, 因为回溯是昂贵的。 但更重要的是, 它与人类解析文本的方式密切相关。 如果你有一个正则表达式 <code>my regex identifier { \w+ }</code> 和 <code>my regex keyword { if | else | endif }</code>, 你直观地期望 <code>identifier</code> 吞噬整个单词，而不是放弃结束下一个规则，如果下一个 rule 失败时。</p>
</div>
<div class="paragraph">
<p>例如，你不想让单词 <code>motif</code> 被解析为标识符 mot 后面跟着关键字 if。 相反, 你想将 <code>motif</code> 解析为标识符; 并且如果解析器期望之后有一个 <code>if</code>, 那么最好让它失败, 而不是以你不期望的方式解析输入。</p>
</div>
<div class="paragraph">
<p>由于 ratcheting 行为在解析器中通常是需要的, 所以有一个快捷方式来声明一个 ratcheting 正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my token thing { .... }
# short for
my regex thing { :r ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truesigspace"><a class="anchor" href="#truesigspace"></a>12.17.2. Sigspace</h4>
<div class="paragraph">
<p><code>:sigspace</code> 或 <code>:s</code> 副词使空白在正则表达式中有意义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so "I used Photoshop®"   ~~ m:i/   photo shop /;      # OUTPUT: «True␤»
say so "I used a photo shop" ~~ m:i:s/ photo shop /;   # OUTPUT: «True␤»
say so "I used Photoshop®"   ~~ m:i:s/ photo shop /;   # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m:s/ photo shop /</code> 的作用和 <code>m/ photo &lt;.ws&gt; shop &lt;.ws&gt; /</code> 一样。默认地, <code>&lt;.ws&gt;</code> 确保单词是分开的, 所以 <code>a b</code> 和 <code>^$</code> 会匹配中间的 <code>&lt;.ws&gt;</code>, 但是 <code>ab</code> 不会。</p>
</div>
<div class="paragraph">
<p>正则表达式中哪里的空白会被转换为 <code>&lt;.ws&gt;</code> 取决于空白前面是什么。在上面的例子中, 正则表达式开头的空白不会被转换为 <code>&lt;.ws&gt;</code>, 但是字符后面的空白会被转换为 <code>&lt;.ws&gt;</code>。通常, 规则就是, 如果某一项可能匹配某个东西, 那么它后面的空白会被转换为 <code>&lt;.ws&gt;</code>。</p>
</div>
<div class="paragraph">
<p>此外, 如果空白跟在某个项之后, 量词(<code>+</code>,<code>*</code> 或 <code>?</code>)之前, 那么 <code>&lt;.ws&gt;</code> 会在每次 term 匹配后匹配。 所以, <code>foo +</code> 变为 <code>[foo &lt;.ws&gt;]+</code>。另一方面, 量词后面的空白和普通的空白作用一样; 例如: <code>foo+</code> 变为 <code>foo+&lt;.ws&gt;</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truematching-adverbs"><a class="anchor" href="#truematching-adverbs"></a>12.18. Matching adverbs</h3>
<div class="paragraph">
<p>和正则表达式副词对比, 其与正则表达式声明有关, 匹配副词只有在将字符串与正则表达式匹配时才有意义。</p>
</div>
<div class="paragraph">
<p>它们永远不会出现在正则表达式内部, 只能在外部 - 作为 <code>m/&#8230;&#8203;/</code> 匹配的一部分或作为匹配方法的参数。</p>
</div>
<div class="sect3">
<h4 id="truecontinue"><a class="anchor" href="#truecontinue"></a>12.18.1. Continue</h4>
<div class="paragraph">
<p><code>:continue</code> 或短的 <code>:c</code> 副词接收一个参数。 这个参数是正则表达式开始搜索的位置。 默认情况下, 它从字符串的开头搜索, 但是 <code>:c</code> 覆盖该位置。 如果没有为 <code>:c</code> 指定位置, 它将默认为 0, 除非设置了 <code>$/</code>, 在这种情况下, 它默认为 <code>$/.to</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'a1xa2' {
    say ~m/a./;         # OUTPUT: «a1␤»
    say ~m:c(2)/a./;    # OUTPUT: «a2␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意: 不同于 <code>:pos</code>, 使用 <code>:continue()</code> 的匹配将尝试在字符串中进一步匹配, 而不是马上失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say "abcdefg" ~~ m:c(3)/e.+/; # OUTPUT: «｢efg｣␤»
say "abcdefg" ~~ m:p(3)/e.+/; # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueexhaustive"><a class="anchor" href="#trueexhaustive"></a>12.18.2. Exhaustive</h4>
<div class="paragraph">
<p>要找到正则表达式的所有可能的匹配 - 包括重叠的 - 和几个从同一位置开始的匹配, 请使用 <code>:exhaustive</code>(short: <code>ex</code>) 副词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'abracadabra' {
    for m:exhaustive/ a .* a / -&gt; $match {
        say ' ' x $match.from, ~$match;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码产生这样的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">abracadabra
abracada
abraca
abra
   acadabra
   acada
   aca
     adabra
     ada
       abra</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueglobal"><a class="anchor" href="#trueglobal"></a>12.18.3. Global</h4>
<div class="paragraph">
<p>不是搜索一个匹配并返回一个 <a href="https://docs.raku.org/type/Match">Match 对象</a>, Global 搜索每个不重叠的匹配, 并将其返回到<a href="https://docs.raku.org/type/List)">列表</a>中。 为此, 请使用 <code>:global</code> 副词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'several words here' {
    my @matches = m:global/\w+/;
    say @matches.elems;         # OUTPUT: «3␤»
    say ~@matches[2];           # OUTPUT: «here␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:g</code> 是 <code>:global</code> 的简写。</p>
</div>
</div>
<div class="sect3">
<h4 id="truepos"><a class="anchor" href="#truepos"></a>12.18.4. Pos</h4>
<div class="paragraph">
<p>在字符串的特定位置锚定匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'abcdef' {
    my $match = m:pos(2)/.*/;
    say $match.from;        # OUTPUT: «2␤»
    say ~$match;            # OUTPUT: «cdef␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:p</code> 是 <code>:pos</code> 的简写。</p>
</div>
<div class="paragraph">
<p>注意: 不同于 <code>:continue</code>, 使用 <code>:pos()</code> 锚定的匹配在不匹配时将立即失败, 而不是尝试进一步匹配字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say "abcdefg" ~~ m:c(3)/e.+/; # OUTPUT: «｢efg｣␤»
say "abcdefg" ~~ m:p(3)/e.+/; # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueoverlap"><a class="anchor" href="#trueoverlap"></a>12.18.5. Overlap</h4>
<div class="paragraph">
<p>要获得多个匹配, 包括重叠的匹配, 但每个起始位置只有一个(最长的)匹配, 请指定 <code>:overlap</code> (short <code>:ov</code>) 副词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'abracadabra' {
    for m:overlap/ a .* a / -&gt; $match {
        say ' ' x $match.from, ~$match;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">abracadabra
   acadabra
     adabra
       abra</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true环视断言"><a class="anchor" href="#true环视断言"></a>12.19. 环视断言</h3>
<div class="sect3">
<h4 id="true向前查看断言"><a class="anchor" href="#true向前查看断言"></a>12.19.1. 向前查看断言</h4>
<div class="paragraph">
<p>要检查一个模式是否出现在另一个模式之前，请通过 <code>before</code> 断言使用 lookahead 断言。形式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&lt;?before pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，要搜索字符串 foo 后面紧跟着字符串 bar, 请使用以下 regexp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">rx{ foo &lt;?before bar&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say "foobar" ~~ rx{ foo &lt;?before bar&gt; };   # OUTPUT: «foo␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果要搜索一个不紧随某个模式的模式, 那么您需要使用反向向前查看断言, 其形式如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&lt;!before pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，所有出现的不在 bar 之前的 foo 都会匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">rx{ foo &lt;!before bar&gt; }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true向后查看断言"><a class="anchor" href="#true向后查看断言"></a>12.19.2. 向后查看断言</h4>
<div class="paragraph">
<p>要检查一个模式是否出现在另一个模式之后，请通过 <code>after</code> 断言使用 <code>lookbehind</code> 断言。 其形式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&lt;?after pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 要搜索字符串 foo 立即跟着的 bar 字符串, 使用如下正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">rx{ &lt;?after foo&gt; bar } # read as after foo is bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say "foobar" ~~ rx{ &lt;?after foo&gt; bar }; #  OUTPUT: «bar␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是, 如果要搜索的模式不是紧随其后的模式, 那么您需要使用反向的 lookbehind 断言, 其形式如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&lt;!after pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, bar 前面不是 foo 的所有 bar 将被匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">rx{ &lt;!after foo&gt; bar }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true最佳实践和陷阱"><a class="anchor" href="#true最佳实践和陷阱"></a>12.20. 最佳实践和陷阱</h3>
<div class="paragraph">
<p>为了提供强大的正则表达式和 Grammar，这里有一些代码布局和可读性的最佳实践，实际匹配的内容，以及避免常见的陷阱。</p>
</div>
<div class="sect3">
<h4 id="true代码布局"><a class="anchor" href="#true代码布局"></a>12.20.1. 代码布局</h4>
<div class="paragraph">
<p>如果没有 <code>:sigspace</code> 副词，在 Raku 正则表达式中空格并不重要。 使用它自己的优势，并插入空格，增加可读性。 此外，必要时插入注释。</p>
</div>
<div class="paragraph">
<p>比较非常紧凑的写法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex float { &lt;[+-]&gt;?\d*'.'\d+[e&lt;[+-]&gt;?\d+]? }</code></pre>
</div>
</div>
<div class="paragraph">
<p>和这种可读性更好的写法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex float {
     &lt;[+-]&gt;?        # optional sign
     \d*            # leading digits, optional
     '.'
     \d+
     [              # optional exponent
        e &lt;[+-]&gt;?  \d+
     ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据经验， 在原子周围和组的内部使用空白; 将量词直接放在原子之后; 并垂直对齐开口和闭合关方括号和括号。</p>
</div>
<div class="paragraph">
<p>在括号或方括号内使用替换列表时，请对齐竖线：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex example {
    &lt;preamble&gt;
    [
    || &lt;choice_1&gt;
    || &lt;choice_2&gt;
    || &lt;choice_3&gt;
    ]+
    &lt;postamble&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true保持短小"><a class="anchor" href="#true保持短小"></a>12.20.2. 保持短小</h4>
<div class="paragraph">
<p>正则代码通常比常规代码更紧凑。 因为他们用这么少的字符就做得那么多，所以保持了正则表达式的简短。</p>
</div>
<div class="paragraph">
<p>当你可以给正则表达式的一部分命名时，通常最好将它放入一个单独的，命名的正则表达式中。</p>
</div>
<div class="paragraph">
<p>例如，您可以以前面获取浮点正则表达式为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex float {
     &lt;[+-]&gt;?        # optional sign
     \d*            # leading digits, optional
     '.'
     \d+
     [              # optional exponent
        e &lt;[+-]&gt;?  \d+
     ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将其分解为部件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my token sign { &lt;[+-]&gt; }
my token decimal { \d+ }
my token exponent { 'e' &lt;sign&gt;? &lt;decimal&gt; }
my regex float {
    &lt;sign&gt;?
    &lt;decimal&gt;?
    '.'
    &lt;decimal&gt;
    &lt;exponent&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有助于，特别是当正则表达式变得更加复杂时。 例如，您可能希望在存在指数的情况下使小数点可选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex float {
    &lt;sign&gt;?
    [
    || &lt;decimal&gt;?  '.' &lt;decimal&gt; &lt;exponent&gt;?
    || &lt;decimal&gt; &lt;exponent&gt;
    ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true要匹配什么"><a class="anchor" href="#true要匹配什么"></a>12.20.3. 要匹配什么</h4>
<div class="paragraph">
<p>输入数据格式通常没有明确的规范，或者程序员不知道规范。 然后，按照你的期望自由是好的，但只要没有可能的含糊之处。</p>
</div>
<div class="paragraph">
<p>例如，在 <code>ini</code> 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[section]
key=value</code></pre>
</div>
</div>
<div class="paragraph">
<p>section 标题内可以有什么内容？ 只允许一个词可能限制性太强。 有人可能会写 <code>[two words]</code>，或使用破折号等。而不是问内部允许什么，可能值得问一下：什么是不允许的？</p>
</div>
<div class="paragraph">
<p>显然，不允许闭合方括号，因为 <code>[a]b]</code> 是不明确的。 根据同一论点，应禁止开口方括号。 这让我们失望了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">token header { '[' &lt;-[ \[\] ]&gt;+ ']' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你只处理一行就没问题。 但是，如果您正在处理整个文件，那么正则表达式会解析</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[with a
newline in between]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能不是一个好主意。妥协是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">token header { '[' &lt;-[ \[\] \n ]&gt;+ ']' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在后处理中，从 section 标题中删除前导和尾随空格和制表符。</p>
</div>
</div>
<div class="sect3">
<h4 id="true匹配空白"><a class="anchor" href="#true匹配空白"></a>12.20.4. 匹配空白</h4>
<div class="paragraph">
<p><code>:sigspace</code> 副词（或使用 <code>rule</code> 声明符而不是 <code>token</code> 或 <code>regex</code>）非常便于隐式解析可能出现在许多地方的空格。</p>
</div>
<div class="paragraph">
<p>回到解析 <code>ini</code> 文件的例子，我们有</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能不像我们想要的那样的文字，因为用户可能在等号周围放置空格。 那么，我们可以试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex kvpair { \s* &lt;key=identifier&gt; \s* '=' \s* &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但那看起来很笨重，所以我们尝试别的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my rule kvpair { &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>可是等等！ 值之后的隐式空格匹配会占用所有空格，包括换行符，因此 <code>\n+</code> 没有任何东西可以匹配（并且 <code>rule</code> 也禁用了回溯，因此没有运气）。</p>
</div>
<div class="paragraph">
<p>因此，将隐式空格的定义重新定义为输入格式中不重要的空白非常重要。</p>
</div>
<div class="paragraph">
<p>这通过重新定义 token <code>ws</code> 来工作; 但是，它只适用于 <a href="https://docs.raku.org/language/grammars">grammars</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar IniFormat {
    token ws { &lt;!ww&gt; \h* }
    rule header { \s* '[' (\w+) ']' \n+ }
    token identifier  { \w+ }
    rule kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }
    token section {
        &lt;header&gt;
        &lt;kvpair&gt;*
    }

    token TOP {
        &lt;section&gt;*
    }
}

my $contents = q:to/EOI/;
    [passwords]
        jack = password1
        joy = muchmoresecure123
    [quotas]
        jack = 123
        joy = 42
EOI
say so IniFormat.parse($contents);</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了将所有正则表达式都放入 grammar 并将其转换为 tokens（因为它们无论如何都不需要回溯），有趣的一点是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">token ws { &lt;!ww&gt; \h* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在进行隐式空格分析的时候会调用该 token。 当它不在两个单词字符之间（ <code>&lt;!ww&gt;</code>，"在单词中"的否定断言）和零个或多个水平空格字符之间匹配。 对水平空格的限制很重要，因为换行符（垂直空格）会分隔记录，不应被隐式匹配。</p>
</div>
<div class="paragraph">
<p>不过，潜伏着一些与空白相关的麻烦。 正则表达式 <code>\n+</code> 与 <code>\n \n</code> 之类的字符串不匹配，因为两个换行符之间有空白。 要允许此类输入字符串，请将 <code>\n+</code> 替换为 <code>\n\s*</code>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truegrammar"><a class="anchor" href="#truegrammar"></a>13. Grammar</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Grammars 是由一组具名正则组成的。</p>
</div>
<div class="paragraph">
<p>Grammars 是一个很强大的用于析构文本的工具。</p>
</div>
<div class="paragraph">
<p>Grammars 允许你把正则组织到一块儿, 就像类组织方法那样。</p>
</div>
<div class="sect2">
<h3 id="true具名正则"><a class="anchor" href="#true具名正则"></a>13.1. 具名正则</h3>
<div class="paragraph">
<p>grammars 的主要组成部分是 <a href="http://doc.raku.org/language/regexes">regexes</a>, 所以在介绍 grammars 之前, 我们先了解什么是具名正则。 具名正则(named regexes) 有它自己的特殊语法, 具名正则跟子例程(subroutine) 的定义很像:</p>
</div>
<div class="listingblock">
<div class="title">named regexes called number</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex number { \d+ [ \. \d+ ]?   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>普通的 regex 中空格被忽略, 其中 <code>[]</code> 是非捕获组。
上面的代码使用 <code>my</code> 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</p>
</div>
<div class="paragraph">
<p>正则有名字了就方便我们在任何地方引用那个正则了:</p>
</div>
<div class="listingblock">
<div class="title">reference named regexes</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say so "32.51" ~~ &amp;number;                         # ①
say so "15 + 4.5" ~~ /&lt;number&gt;\s* '+' \s*&lt;number&gt;/ # ②</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 grammars 外面, 为什么用 <code>&amp;number</code> 引用具名正则呢? 对比具名子例程你就知道了:</p>
</div>
<div class="listingblock">
<div class="title">named subroutine</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub number { say "i am a subroutine" }  # 具名子例程
&amp;number                                 # sub number () { #`(Sub|140651249646256) ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是有个语法不一致的地方就是, 在 <code>/ /</code> 或 grammars 里面, 引用具名正则的语法有点特殊, 就是给正则的名字包裹上 <code>&lt; &gt;</code>。这会把该具名正则插入(带入)到整个正则之中, 就像字符串插值那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># 声明具名正则
my regex number { \d+ [ \. \d+]? }
my token ident  { \w+            }
my rule  alpha  { &lt;[A..Za..z]&gt;   }

# ① 在 grammar 外面使用 &amp; 符号引用具名正则
say so "12.34" ~~ &amp;number; # true

# ② 在正则构造 // 里面使用
say so "12.88 + 0.12" ~~ / &lt;number&gt; \s* '+' \s* &lt;number&gt; /; # true
# say so "12.88 + 0.12" ~~ / &lt;left=.number&gt; \s* '+' \s* &lt;right=.number&gt; /;
# wrong, method 'number' not found for invocant of class 'Cursor'

# ③ 在 grammar 里面使用
grammar EquationParse {
    # 这里也不能给 number 起别名, 除非 number 是在 grammar 内部声明的
     token TOP { &lt;number&gt; \s* '+' \s* &lt;number&gt; \s* '=' \s* &lt;number&gt; }
}

# 等式解析
my $expr = EquationParse.parse("12.88 + 0.12 = 13.00");
say $expr;</code></pre>
</div>
</div>
<div class="paragraph">
<p>声明具名正则不是只有一个 <code>regex</code> 声明符, 实际上 , regex 声明符用的最少, 大多数时候, 都是使用 <code>token</code> 或 <code>rule</code> 声明符。token 和 rule 这两个都是 <code>ratcheing</code> (棘轮)的, 这意味着如果匹配失败, 那么正则引擎就不会回溯并尝试重新匹配了。这通常会是你想要的, 但不适用于所有情况:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>棘轮用于单向驱动, 防止逆转。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="title">ratcheing</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex works-but-slow { .+ q } # 可能会回溯
my token fails-but-fast { .+ q } # 不回溯
my $s = 'Tokens and rules won\'t backtrack, which makes them fail quicker!';
say so $s ~~ &amp;works-but-slow; # True
say so $s ~~ &amp;fails-but-fast; # False, .+ 得到了整个字符串但不回溯</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>token</code> 和 <code>rule</code> 的唯一区别就是 <code>rule</code> 声明符会让正则中的 <code>:sigspace</code> 修饰符起效:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my token non-space-y { 'once' 'upon' 'a' 'time' }
my rule space-y { 'once' 'upon' 'a' 'time' }
say 'onceuponatime'    ~~ &amp;non-space-y;
say 'once upon a time' ~~ &amp;space-y;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true创建-grammar"><a class="anchor" href="#true创建-grammar"></a>13.2. 创建 Grammar</h3>
<div class="paragraph">
<p>具名正则是构建 Grammars 的基础, 所以我们了解完具名正则的声明以及如何引用具名正则之后, 再来看 Grammars 会有一脉相承的感觉。</p>
</div>
<div class="paragraph">
<p>Grammars 应该只用于解析文本; 如果你想提取复杂的数据, 推荐 <a href="http://doc.raku.org/language/grammars#Action_Objects">action object</a>和 grammar 一块使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="trueproto-regexes"><a class="anchor" href="#trueproto-regexes"></a>13.3. Proto regexes</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Grammar">Grammars</a> 是由 rules, tokens, regexes 组成的; 这些 rules, tokens, regexes 实际上就是方法, 因为 grammars 是类。
这些方法可以共享共同的名称和功能，因此可以使用 <a href="https://docs.raku.org/syntax/proto">proto</a>。
如果你有很多备选分支(alternations), 那么生成可读性好的代码或子类化(subclass)你的 grammar 可能会变得很困难。在下面的 <code>Actions</code> 类中, <code>TOP</code> 方法中的三元操作符不是很完美并且当我们添加更多的运算符时它会变得更糟糕:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar Calculator {
    token TOP { [ &lt;add&gt; | &lt;sub&gt; ] }
    rule  add { &lt;num&gt; '+' &lt;num&gt; }
    rule  sub { &lt;num&gt; '-' &lt;num&gt; }
    token num { \d+ }
}

class Calculations {
    method TOP ($/) { make $&lt;add&gt; ?? $&lt;add&gt;.made !! $&lt;sub&gt;.made; }
    method add ($/) { make [+] $&lt;num&gt;; }
    method sub ($/) { make [-] $&lt;num&gt;; }
}

say Calculator.parse('2 + 3', actions =&gt; Calculations).made;

# OUTPUT:
# 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了让世界变得更加美好, 我们可以在 tokens 身上使用看起来像 <code>:sym&lt;&#8230;&#8203;&gt;</code> 那样的副词来使用原型正则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar Calculator {
    token TOP { &lt;calc-op&gt; }

    proto rule calc-op          {*}
          rule calc-op:sym&lt;add&gt; { &lt;num&gt; '+' &lt;num&gt; }
          rule calc-op:sym&lt;sub&gt; { &lt;num&gt; '-' &lt;num&gt; }

    token num { \d+ }
}

class Calculations {
    method TOP              ($/) { make $&lt;calc-op&gt;.made; }
    method calc-op:sym&lt;add&gt; ($/) { make [+] $&lt;num&gt;; }
    method calc-op:sym&lt;sub&gt; ($/) { make [-] $&lt;num&gt;; }
}

say Calculator.parse('2 + 3', actions =&gt; Calculations).made;

# OUTPUT:
# 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个 grammar 中, 备选分支(alternation)已经被 <code>&lt;calc-op&gt;</code> 替换掉了, 它实质上是我们将要创建的一组值的名字。我们通过使用 <code>proto rule calc-op</code> 定义了一个 rule 原型类型(prototype) 来达成。我们之前的每一个备选分支已经被新的 rule <code>calc-op</code> 替换掉了并且备选分支的名字被附加上了 <code>:sym&lt;&gt;</code> 副词。</p>
</div>
<div class="paragraph">
<p>在 actions 类中, 我们现在摆脱了三目操作符, 仅仅只在 <code>$&lt;calc-op&gt;</code> 匹配对象上接收 <code>.made</code> 值。并且单独备选分支的 actions 现在和 grammar 遵守相同的具名模式:  <code>method calc-op:sym&lt;add&gt;</code> 和 <code>method calc-op:sym&lt;sub&gt;</code>。</p>
</div>
<div class="paragraph">
<p>当你子类化(subclass)那个 grammar 和 actions 类的时候才能看到这个方法的真正魅力。假设我们想为 calculator 增加一个乘法功能:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar BetterCalculator is Calculator {
    rule calc-op:sym&lt;mult&gt; { &lt;num&gt; '*' &lt;num&gt; }
}

class BetterCalculations is Calculations {
    method calc-op:sym&lt;mult&gt; ($/) { make [*] $&lt;num&gt; }
}

say BetterCalculator.parse('2 * 3', actions =&gt; BetterCalculations).made;

# OUTPUT:
# 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有我们需要添加的就是为 <code>calc-op</code> 组添加额外的 rule 和 action, 感谢原型正则(proto regexes), 所有的东西都能正常工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="true特殊的-tokens"><a class="anchor" href="#true特殊的-tokens"></a>13.4. 特殊的 Tokens</h3>
<div class="sect3">
<h4 id="truetop"><a class="anchor" href="#truetop"></a>13.4.1. TOP</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar Foo {
    token TOP { \d+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TOP</code> token 是默认的第一个尝试去匹配的 token , 当解析一个 grammar 的时候 - 那颗树的根。注意如果你正使用 <code>.parse</code> 方法进行解析, 那么 token TOP 被自动地锚定到字符串的开头和结尾(再看看 <code>.subparse</code>)。</p>
</div>
<div class="paragraph">
<p>使用 <code>rule TOP</code> 或 <code>regex TOP</code> 也是可以接受的。</p>
</div>
<div class="paragraph">
<p>在 <code>.parse</code>、<code>.subparse</code> 或 <code>.parsefile</code> Grammar 方法中使用 <code>:rule</code> 具名参数可以选择一个不同的 token 来进行起始匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="truews"><a class="anchor" href="#truews"></a>13.4.2. ws</h4>
<div class="paragraph">
<p>当使用 <code>rule</code> 而非 <code>token</code> 时, 原子(atom)后面的任何空白(whitespace)被转换为一个对 <code>ws</code> 的非捕获调用。即:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">rule entry { &lt;key&gt; '=' &lt;value&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">token entry { &lt;key&gt; &lt;.ws&gt; ’=’ &lt;.ws&gt; &lt;value&gt; &lt;.ws&gt; } # . = non-capturing</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认的 <code>ws</code> 匹配"空白"(whitespace), 例如空格序列(不管什么类型)、换行符、unspaces、或 heredocs。</p>
</div>
<div class="paragraph">
<p>提供你自己的 <code>ws</code> token 是极好的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar Foo {
    rule TOP { \d \d }
}.parse: "4   \n\n 5"; # Succeeds

grammar Bar {
    rule TOP { \d \d }
    token ws { \h*   }
}.parse: "4   \n\n 5"; # Fails</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的例子中, 在 Bar Gramamr 中重写了自己的 <code>ws</code>, 只匹配水平空白符, 所以 <code>\n\n</code> 匹配失败。</p>
</div>
</div>
<div class="sect3">
<h4 id="true总是成功断言"><a class="anchor" href="#true总是成功断言"></a>13.4.3. 总是成功断言</h4>
<div class="paragraph">
<p><code>&lt;?&gt;</code> 总是匹配成功。 当它用作 grammar 中的 token 时, 它可以被用于触发一个 Action 类方法。在下面的 grammar 中, 我们查找阿拉伯数字并且使用 <code>always succeed assertion</code> 定义一个 succ token。</p>
</div>
<div class="paragraph">
<p>在 action 类中, 我们使用对 succ 方法的调用来设置(在这个例子中, 我们在 <code>@!numbers</code> 中准备了一个新元素)。在 <code>digit</code> 方法中, 我们把阿拉伯数字转换为梵文数字并且把它添加到 @!numbers 数组的最后一个元素中。多亏了 <code>succ</code>, 最后一个元素总是当前正被解析的 <code>digit</code> 数字的数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar Digifier {
    rule TOP {
        [ &lt;.succ&gt; &lt;digit&gt;+ ]+
    }
    token succ   { &lt;?&gt; }
    token digit { &lt;[0..9]&gt; }
}

class Devanagari {
    has @!numbers;
    method digit ($/) { @!numbers[*-1] ~= $/.ord.&amp;[+](2358).chr }
    method succ  ($)  { @!numbers.push: ''     }
    method TOP   ($/) { make @!numbers[^(*-1)] }
}

say Digifier.parse('255 435 777', actions =&gt; Devanagari.new).made;
# OUTPUT:
# (२५५ ४३५ ७७७)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truegrammar-中的方法"><a class="anchor" href="#truegrammar-中的方法"></a>13.5. Grammar 中的方法</h3>
<div class="paragraph">
<p>在 grammar 中使用 <code>method</code> 代替 <code>rule</code> 或 <code>token</code> 也是可以的, 只要它们返回一个 <a href="https://docs.raku.org/type/Cursor">Cursor</a> 类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar DigitMatcher {
    method TOP (:$full-unicode) {
        $full-unicode ?? self.num-full !! self.num-basic;
    }
    token num-full  { \d+ }
    token num-basic { &lt;[0..9]&gt;+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 grammar 会根据 parse 方法提供的参数尝试不同的匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say +DigitMatcher.subparse: '12७१७९०९', args =&gt; \(:full-unicode);
# OUTPUT:
# 12717909

say +DigitMatcher.subparse: '12७१७९०९', args =&gt; \(:!full-unicode);
# OUTPUT:
# 12</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueaction-object"><a class="anchor" href="#trueaction-object"></a>13.6. Action Object</h3>
<div class="paragraph">
<p>一个成功的 grammar 匹配会给你一棵匹配对象(Match objects)的解析树, 匹配树(match tree)到达的越深, 则 grammar 中的分支越多, 那么在匹配树中航行以获取你真正感兴趣的东西就变的越来越困难。</p>
</div>
<div class="paragraph">
<p>为了避免你在匹配树(match tree)中迷失, 你可以提供一个 action object。grammar 中每次解析成功一个具名规则(named rule)之后, 它就会尝试调用一个和该 grammar rule 同名的方法, 并传递给这个方法一个 <code>Match</code> 对象作为位置参数。如果不存在这样的同名方法, 就跳过。</p>
</div>
<div class="paragraph">
<p>这儿有一个例子来说明 grammar 和 action：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar TestGrammar {
    token TOP { ^ \d+ $ }
}

class TestActions {
    method TOP($/) {
        $/.make(2 + $/);  # 等价于 $/.make: 2 + $/
    }
}
my $actions = TestActions.new; # 创建 Action 实例
my $match   = TestGrammar.parse('40', :$actions);
say $match;       # ｢40｣
say $match.made;  # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TestActions</code> 的一个实例变量作为具名参数 <code>actions</code> 被传递给 <code>parse</code> 调用, 然后当 token <code>TOP</code> 匹配成功之后, 就会自动调用方法 <code>TOP</code>, 并传递匹配对象(match object) 作为方法的参数。</p>
</div>
<div class="paragraph">
<p>为了让参数是匹配对象更清楚, 上面的例子使用 <code>$/</code> 作为 action 方法的参数名, 尽管那仅仅是一个方便的约定, 跟内在无关。 <code>$match</code> 也可以。(尽管使用 <code>$/</code> 可以提供把 <code>$</code> 作为 <code>$/</code> 的缩写的优势。)</p>
</div>
<div class="paragraph">
<p>下面是一个更有说服力的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar KeyValuePairs {
    token TOP {
        [ \n+]*
    }
    token ws { \h* } # 重写了关于"空白"的定义
    rule pair {
         '='
    }
    token identifier {
        \w+
    }
}

class KeyValuePairsActions {
    method identifier($/)  { $/.make: ~$/              }
    method pair      ($/)  { $/.make: $.made =&gt; $.made }
    method TOP       ($/)  { $/.make: $».made          }
}

my $res = KeyValuePairs.parse(q:to/EOI/, :actions(KeyValuePairsActions)).made;
    second=b
    hits=42
    perl=6
    EOI
for @$res -&gt; $p {
    say "Key: $p.key()\tValue: $p.value()";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Key: second     Value: b
Key: hits       Value: 42
Key: perl       Value: 6</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>pair</code> 这个 rule, 解析一对由等号分割的 pair, 并且给 <code>identifier</code> 这个 token 各自起了别名。对应的 action 方法构建了一个 <code>Pair</code> 对象, 并使用子匹配对象(sub match objects)的 <code>.made</code> 属性。这也暴露了一个事实: submatches 的 action 方法在那些调用正则/外部正则之前就被调用。所以 action 方法是按后续调用的。</p>
</div>
<div class="paragraph">
<p>名为 <code>TOP</code> 的 action 方法仅仅把由 <code>pair</code> 这个 rule 的多重匹配组成的所有对象收集到一块, 然后以一个列表的方式返回。</p>
</div>
<div class="paragraph">
<p>注意 <code>KeyValuePairsActions</code> 是作为一个类型对象(type object)传递给方法 <code>parse</code> 的, 这是因为 action 方法中没有一个使用属性(属性只能通过实例来访问)。</p>
</div>
<div class="paragraph">
<p>其它情况下, action 方法可能会在属性中保存状态。 那么这当然需要你传递一个实例给 <code>parse</code> 方法。</p>
</div>
<div class="paragraph">
<p>注意, <code>token ws</code> 有点特殊: 当 <code>:sigspace</code> 开启的时候(就是我们使用 <code>rule</code> 的时候), 我们覆写的 <code>ws</code> 会替换某些空白序列。这就是为什么 <code>rule pair</code> 中等号两边的空格解析没有问题并且闭合 <code>}</code> 之前的空白不会狼吞虎咽地吃下换行符, 因为换行符在 <code>TOP</code> token 已经占位置了, 并且 token 不会回溯。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># ws 的内置定义
/ &lt;.ws&gt; /                # match "whitespace":
                         #   \s+ if it's between two \w characters,
                         #   \s* otherwise

&gt; my token ws { \h* } # 重写 ws 这个内置的 token
&gt; say so "\n" ~~ &amp;ws # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以 <code>&lt;.ws&gt;</code> 内置的定义是：如果空白在两个 <code>\w</code> 单词字符之间, 则意思为 <code>\s+</code>, 否则为 <code>\s*</code>。 我们可以重写 <code>ws</code> 关于空白的定义, 重新定义我们需要的空白。比如把 <code>ws</code> 定义为 <code>{ \h* }</code> 就是所有水平空白符, 甚至可以将`ws` 定义为非空白字符。例如: <code>token ws { 'x' }</code></p>
</div>
</div>
<div class="sect2">
<h3 id="truegrammar-with-action"><a class="anchor" href="#truegrammar-with-action"></a>13.7. Grammar with Action</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar StationDataParser {
    token TOP          { ^ &lt;keyval&gt;+ &lt;observations&gt; $             }
    token keyval       { $&lt;key&gt;=[&lt;-[=]&gt;+] '=' \h* $&lt;val&gt;=[\N+] \n }
    token observations { 'Obs:' \h* \n &lt;observation&gt;+             }
    token observation  { $&lt;year&gt;=[\d+] \h* &lt;temp&gt;+ %% [\h*] \n    }
    token temp         { '-'? \d+ \. \d+                          }
}

class StationData {
    has $.name;
    has $.country;
    has @.data;

    submethod BUILD(:%info (:Name($!name), :Country($!country), *%), :@!data) {
    }
}

class StationDataActions {
    method TOP($/) {
        make StationData.new(
            info =&gt; $&lt;keyval&gt;.map(*.ast).hash,
            data =&gt; $&lt;observations&gt;.ast
        );
    }

    method keyval($/) {
        make ~$&lt;key&gt; =&gt; ~$&lt;val&gt;;
    }
    method observations($/) {
        make $&lt;observation&gt;.map(*.ast).grep(*.value.none &lt;= -99);
    }
    method observation($/) {
        make +$&lt;year&gt; =&gt; $&lt;temp&gt;.map(*.Num);
    }
}

say StationDataParser.parse( q:to/EOCSV/, :actions(StationDataActions)).ast
Name= Jan Mayen
Country= NORWAY
Lat=   70.9
Long=    8.7
Height= 10
Start year= 1921
End year= 2009
Obs:
1921 -4.4 -7.1 -6.8 -4.3 -0.8  2.2  4.7  5.8  2.7 -2.0 -2.1 -4.0
1922 -0.9 -1.7 -6.2 -3.7 -1.6  2.9  4.8  6.3  2.7 -0.2 -3.8 -2.6
2008 -2.8 -2.7 -4.6 -1.8  1.1  3.3  6.1  6.9  5.8  1.2 -3.5 -0.8
2009 -2.3 -5.3 -3.2 -1.6  2.0  2.9  6.7  7.2  3.8  0.6 -0.3 -1.3
EOCSV</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true解析售票数据"><a class="anchor" href="#true解析售票数据"></a>13.8. 解析售票数据</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar SalesExport::Grammar {
    token TOP { ^ &lt;country&gt;+ $ }
    token country {
        &lt;cname=.name&gt; \n
        &lt;destination&gt;+
    }

    token destination {
        \s+ &lt;dname=.name&gt; \s+ ':' \s+
        &lt;lat=.num&gt; ',' &lt;long=.num&gt; \s+ ':' \s+
        &lt;sales=.integer&gt; \n
    }

    token name    { \w+          }
    token num     { \d+ [\.\d+]? }
    token integer { \d+          }
}

my $string = q:to/THE END/;
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
THE END

class SalesExport::Grammar::Actions {
	method destination($/) { make ~$&lt;dname&gt; =&gt; $&lt;sales&gt;          }
    method country($/)     { make ~$&lt;cname&gt; =&gt; $&lt;destination&gt;    }
    method TOP($/)         { make $&lt;country&gt;».made              }
}

my $actions = SalesExport::Grammar::Actions.new;
my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made;

# 获取所有国家的名字
for @$grammar_action -&gt; $p {
    say "$p.key()";
}

say  "-" x 45;
for @$grammar_action -&gt; $p {
    for $p.value() -&gt; $d {
	   for @$d -&gt; $n {
	      say ~$n&lt;dname&gt;;
	   }
	  }
}

say  "-" x 45;

# 计算每个国家卖了多少票
for @$grammar_action -&gt; $c {
    for $c.value() -&gt; $d {
	   my $sales_count=0;
	   for @$d -&gt; $n {
	      $sales_count += ~$n&lt;sales&gt;;
	   }
	   say $sales_count;
	  }
}


 #`(

# say $grammar_object;
#  say $grammar_object&lt;country&gt;.Str;
say "_" x 45;
# say $grammar_object&lt;country&gt;[0];
# say $grammar_object&lt;country&gt;[1].Str;

 say "_" x 45;
# say $grammar_object&lt;country&gt;[].Str;
# say $grammar_object&lt;country&gt;.values;

# 获取国家的名字
say $grammar_object&lt;country&gt;[0]&lt;name&gt;.Str;
say $grammar_object&lt;country&gt;[1]&lt;name&gt;.Str;
say $grammar_object&lt;country&gt;[2]&lt;name&gt;.Str;

 say "_" x 45;
# 获取目的地
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;name&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;name&gt;.Str;

 say "_" x 45;
# 获取经度
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;lat&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;lat&gt;.Str;

 say "_" x 45;
# 获取纬度
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;long&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;long&gt;.Str;

 say "_" x 45;
# 获取sales
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;sales&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;sales&gt;.Str;

 say "_" x 45;
 # 获取所有国家
say $grammar_object&lt;country&gt;»&lt;name&gt;.Str;

 say "_" x 45;
 # 获取第一个国家的所有目的地
 say $grammar_object&lt;country&gt;[0]&lt;destination&gt;»&lt;name&gt;.Str;

 say "_" x 45;
 # 获取第一个国家的所有的 sales
 say $grammar_object&lt;country&gt;[0]&lt;destination&gt;»&lt;sales&gt;.Str;
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>只能在叶子节点上(最后一个正则名字的前面)使用超运算符 <code>»</code>。 <code>S/</code> 匹配对象中, 键就是正则的名字, 键值就是匹配到的部分内容.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar SalesExport::Grammar {
    token TOP { ^ &lt;country&gt;+ $ }
    token country {
        &lt;cname=.name&gt; \n
        &lt;destination&gt;+
    }

    token destination {
        \s+ &lt;dname=.name&gt; \s+ ':' \s+
        &lt;lat=.num&gt; ',' &lt;long=.num&gt; \s+ ':' \s+
        &lt;sales=.integer&gt; \n
    }

    token name    { \w+          }
    token num     { \d+ [\.\d+]? }
    token integer { \d+          }
}

my $string = q:to/THE END/;
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
THE END

class SalesExport::Grammar::Actions {
	method destination($/) { make ~$&lt;dname&gt; =&gt; [$&lt;sales&gt;.map(*.Num+10),$&lt;lat&gt;.map(*.Num+90) ]         }
    method country($/)     { make ~$&lt;cname&gt; =&gt; $&lt;destination&gt;».made            }
    method TOP($/)         { make $&lt;country&gt;».made                             }
}

my $actions = SalesExport::Grammar::Actions.new;
my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made;
#say $grammar_action.Str;
# 获取所有国家的名字
for @$grammar_action -&gt; $p {
    say "$p.key()";
}
say '-' x 45;
# 获取所有目的地
for @$grammar_action -&gt; $p {
    for $p.value() -&gt; $d {
	    for @$d -&gt; $n{
		    say $n.key();
		}
	}
}
say '-' x 45;
# 获取出售的票数
for @$grammar_action -&gt; $p {
    print "$p.key()\t";
    for $p.value() -&gt; $d {
	    my $count;
	    for @$d -&gt; $n{
		    $count += $n.value()[0];
		}
	say $count;
	}
}

say '-' x 45;
# 获取经度 lat
for @$grammar_action -&gt; $p {
    for $p.value() -&gt; $d {
	    for @$d -&gt; $n{
		    say $n.value()[1];
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">Norway
Ukraine
Switzerland
---------------------------------------------
Oslo
Bergen
Kiev
Wengen
---------------------------------------------
Norway  26
Ukraine 13
Switzerland 13
---------------------------------------------
149.914289
150.388533
140.456001
136.608265</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true并发"><a class="anchor" href="#true并发"></a>14. 并发</h2>
<div class="sectionbody">
<div class="paragraph">
<p>maybe will coming soon at 2021</p>
</div>
<div class="sect2">
<h3 id="truesluppy"><a class="anchor" href="#truesluppy"></a>14.1. Sluppy</h3>

</div>
<div class="sect2">
<h3 id="truechannel"><a class="anchor" href="#truechannel"></a>14.2. Channel</h3>

</div>
<div class="sect2">
<h3 id="truereactwhenever"><a class="anchor" href="#truereactwhenever"></a>14.3. react/whenever</h3>

</div>
<div class="sect2">
<h3 id="truerace"><a class="anchor" href="#truerace"></a>14.4. race</h3>

</div>
<div class="sect2">
<h3 id="truehyper"><a class="anchor" href="#truehyper"></a>14.5. hyper</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="true异常"><a class="anchor" href="#true异常"></a>15. 异常</h2>
<div class="sectionbody">
<div class="paragraph">
<p>maybe will coming soon at 2021</p>
</div>
<div class="sect2">
<h3 id="truedie"><a class="anchor" href="#truedie"></a>15.1. die</h3>

</div>
<div class="sect2">
<h3 id="truewarn"><a class="anchor" href="#truewarn"></a>15.2. warn</h3>

</div>
<div class="sect2">
<h3 id="truenote"><a class="anchor" href="#truenote"></a>15.3. note</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="true标准输入和标准输出"><a class="anchor" href="#true标准输入和标准输出"></a>16. 标准输入和标准输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>maybe will coming soon at 2021</p>
</div>
<div class="sect2">
<h3 id="true标准输入"><a class="anchor" href="#true标准输入"></a>16.1. 标准输入</h3>

</div>
<div class="sect2">
<h3 id="true标准输出"><a class="anchor" href="#true标准输出"></a>16.2. 标准输出</h3>

</div>
<div class="sect2">
<h3 id="trueio-对象"><a class="anchor" href="#trueio-对象"></a>16.3. IO 对象</h3>

</div>
<div class="sect2">
<h3 id="trueget"><a class="anchor" href="#trueget"></a>16.4. get</h3>

</div>
<div class="sect2">
<h3 id="true文件句柄"><a class="anchor" href="#true文件句柄"></a>16.5. 文件句柄</h3>

</div>
<div class="sect2">
<h3 id="truein"><a class="anchor" href="#truein"></a>16.6. $*IN</h3>

</div>
<div class="sect2">
<h3 id="trueout"><a class="anchor" href="#trueout"></a>16.7. $*OUT</h3>

</div>
<div class="sect2">
<h3 id="trueargv"><a class="anchor" href="#trueargv"></a>16.8. $*ARGV</h3>

</div>
<div class="sect2">
<h3 id="trueargvfiles"><a class="anchor" href="#trueargvfiles"></a>16.9. $*ARGVFILES?</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="truewhatever-star"><a class="anchor" href="#truewhatever-star"></a>17. Whatever Star</h2>
<div class="sectionbody">
<div class="paragraph">
<p>冒号和星号是 Raku 中比较有特色的俩个符号, 上次我们介绍了冒号, 今天我们来看一看星号 <code>*</code>:</p>
</div>
<div class="sect2">
<h3 id="true动态变量"><a class="anchor" href="#true动态变量"></a>17.1. 动态变量</h3>
<div class="sect3">
<h4 id="trueargfiles-不可思议的命令行输入句柄"><a class="anchor" href="#trueargfiles-不可思议的命令行输入句柄"></a>17.1.1. $*ARGFILES - 不可思议的命令行输入句柄</h4>
<div class="listingblock">
<div class="title">argfiles.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$*ARGFILES.perl.say; #=&gt; IO::Handle.new(:path(Any),:chomp)

# 按行读取
for $*ARGFILES.lines -&gt; $line {
    say "$line";
}

# 一次性读取
# say $*ARGFILES.slurp;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">USAGE</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">$ raku argfiles.pl6 file1 file2 file3 ...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://doc.raku.org/type/IO::Handle">IO::Handle</a></p>
</li>
<li>
<p><a href="http://doc.raku.org/language/io">Input/Output</a></p>
</li>
<li>
<p><a href="http://qiita.com/syohex/items/0a7782920968ab105ba0">Raku文件操作</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueargs-来自命令行的参数"><a class="anchor" href="#trueargs-来自命令行的参数"></a>17.1.2. @*ARGS - 来自命令行的参数</h4>
<div class="listingblock">
<div class="title">agrs.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say @*ARGS.WAHT;    #=&gt; (Array)
say @*ARGS;         #=&gt; [a b c d e]
say @*ARGS.perl;    #=&gt; ["a", "b", "c", "d", "e"]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">USAGE</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">$ raku args.pl6 a b c d e</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://doc.raku.org/type/Array">Array</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="truein-标准输入文件句柄-等同于-stdin"><a class="anchor" href="#truein-标准输入文件句柄-等同于-stdin"></a>17.1.3. $*IN - 标准输入文件句柄, 等同于 stdin</h4>
<div class="listingblock">
<div class="title">in.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*IN.perl;   #=&gt; IO::Handle.new(:path(IO::Special.new(what =&gt; "&lt;STDIN&gt;")),:chomp)
say $*IN.path;   #=&gt; IO::Special.new(what =&gt; "&lt;STDIN&gt;")
say $*IN.chomp;  #=&gt; True

.say for $*IN.lines;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">USAGE</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">$ raku in.pl6
你好</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">USAGE</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$ cat somefile.txt | raku in.pl6</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueout-标准输出文件句柄-等同于-stdout"><a class="anchor" href="#trueout-标准输出文件句柄-等同于-stdout"></a>17.1.4. $*OUT - 标准输出文件句柄, 等同于 stdout</h4>
<div class="listingblock">
<div class="title">out.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*OUT.perl;   #=&gt; IO::Handle.new(:path(IO::Special.new(what =&gt; "&lt;STDOUT&gt;")),:chomp)
say $*OUT.path;   #=&gt; IO::Special.new(what =&gt; "&lt;STDOUT&gt;")
say $*OUT.chomp;  #=&gt; True

$*OUT.say( q:to/新年快乐/ );
    祝你新年快乐
    2016.01.23
    让我再说一次
新年快乐

# 通常我们会在打印时省略 $*OUT
# say "哈利路亚";</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一段代码中 <code>//</code> 中间的字符是分割符。这打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">祝你新年快乐
2016.01.23
让我再说一次</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">USAGE</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">$ raku out.pl6
$ raku out.pl6 &gt; result.txt</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://doc.raku.org/type/IO">IO</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueerr-标准错误文件句柄-等同于-stderr"><a class="anchor" href="#trueerr-标准错误文件句柄-等同于-stderr"></a>17.1.5. $*ERR - 标准错误文件句柄, 等同于 stderr</h4>
<div class="listingblock">
<div class="title">err.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*ERR.perl;   #=&gt; IO::Handle.new(:path(IO::Special.new(what =&gt; "&lt;STDERR&gt;")),:chomp)
say $*ERR.path;   #=&gt; IO::Special.new(what =&gt; "&lt;STDERR&gt;")
say $*ERR.chomp;  #=&gt; True

$*ERR.say("我错了");

# 平时可以使用 note
# note "前方高能预警";</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">USAGE</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">$ raku err.pl6 &gt; /dev/null
我错了</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truerepo-保存所安装加载的模块信息的变量"><a class="anchor" href="#truerepo-保存所安装加载的模块信息的变量"></a>17.1.6. $*REPO - 保存所安装/加载的模块信息的变量</h4>
<div class="listingblock">
<div class="title">repo.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*REPO;
say $*REPO.perl;
say $*REPO.id;
say $*REPO.path-spec;
say $*REPO.loaded;
say $*REPO.repo-chain;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truetz-系统的本地时区"><a class="anchor" href="#truetz-系统的本地时区"></a>17.1.7. $*TZ - 系统的本地时区</h4>
<div class="listingblock">
<div class="title">tz.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*TZ;      #=&gt; 32400
say $*TZ.perl; #=&gt; 32400

say $*TZ.WHAT; #=&gt; (Int)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truecwd-当前工作目录"><a class="anchor" href="#truecwd-当前工作目录"></a>17.1.8. $*CWD - 当前工作目录</h4>
<div class="listingblock">
<div class="title">cwd.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*CWD;       #=&gt; "/Users/kujira".IO
say $*CWD.path;  #=&gt; /Users/kujira
say $*CWD.perl;  #=&gt; "/Users/kujira".IO(:SPEC(IO::Spec::Unix),:CWD("/Users/kujira"))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truekernel-我是为哪个内核编译的"><a class="anchor" href="#truekernel-我是为哪个内核编译的"></a>17.1.9. $*KERNEL - 我是为哪个内核编译的?</h4>
<div class="listingblock">
<div class="title">kernel.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*KERNEL;            #=&gt; darwin (18.5.0)
say $*KERNEL.release;    #=&gt; Darwin Kernel Version 18.5.0: Mon Mar 11 20:40:32 PDT 2019; root:xnu-4903.251.3~3/RELEASE_X86_64
say $*KERNEL.name;       #=&gt; darwin
say $*KERNEL.auth;       #=&gt; unknown
say $*KERNEL.version;    #=&gt; v18.5.0
say $*KERNEL.signature;  #=&gt; (Blob)
say $*KERNEL.desc;       #=&gt; (Str)

say $*KERNEL.perl;        #=&gt; Kernel.new(release =&gt; "Darwin Kernel Version 18.5.0: Mon Mar 11 20:40:32 PDT 2019; root:xnu-4903.251.3~3/RELEASE_X86_64", name =&gt; "darwin", auth =&gt; "unknown", version =&gt; v18.5.0, signature =&gt; Blob, desc =&gt; Str)
say $*KERNEL.WHAT;        #=&gt; (Kernel)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truedistro-我在哪个操作系统发行版下编译"><a class="anchor" href="#truedistro-我在哪个操作系统发行版下编译"></a>17.1.10. $*DISTRO - 我在哪个操作系统发行版下编译?</h4>
<div class="listingblock">
<div class="title">distro.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*DISTRO;           #=&gt; macosx (10.14.4)

say $*DISTRO.name;      #=&gt; macosx
say $*DISTRO.is-win;    #=&gt; False
say $*DISTRO.version;   #=&gt; v10.14.4

say $*DISTRO.path-sep;  #=&gt; :
say $*DISTRO.auth;      #=&gt; Apple Computer, Inc.
say $*DISTRO.desc;      #=&gt; 2019-04-01T20:45:26.421867+08:00
say $*DISTRO.release;   #=&gt; 18E226
say $*DISTRO.signature; #=&gt; (Blob)

say $*DISTRO.gist;      #=&gt; macosx (10.14.4)
say $*DISTRO.Str;       #=&gt; macosx
say $*DISTRO.perl;      #=&gt; Distro.new(release =&gt; "18E226", is-win =&gt; Bool::False, path-sep =&gt; ":", name =&gt; "macosx", auth =&gt; "Apple Computer, Inc.", version =&gt; v10.14.4, signature =&gt; Blob, desc =&gt; "2019-04-01T20:45:26.421867+08:00")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truevm-我在哪个虚拟机下编译"><a class="anchor" href="#truevm-我在哪个虚拟机下编译"></a>17.1.11. $*VM - 我在哪个虚拟机下编译?</h4>
<div class="listingblock">
<div class="title">vm.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*VM;         #=&gt; moar (2019.03)
say $*VM.config;
say $*VM.perl;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueperl-我是为哪个-perl-编译的"><a class="anchor" href="#trueperl-我是为哪个-perl-编译的"></a>17.1.12. $*PERL - 我是为哪个 Perl 编译的?</h4>
<div class="listingblock">
<div class="title">perl.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*PERL;          #=&gt; Raku (6.d)
say $*PERL.compiler; #=&gt; rakudo (2019.03)

say $*PERL.perl;     #=&gt; Perl.new(compiler =&gt; Compiler.new(id =&gt; "E8252BAA8CCA5C482BDD1088C325C513F7B95D46", release =&gt; "", codename =&gt; "", name =&gt; "rakudo", auth =&gt; "The Perl Foundation", version =&gt; v2019.03, signature =&gt; Blob, desc =&gt; Str), name =&gt; "Raku", auth =&gt; "The Perl Foundation", version =&gt; v6.d, signature =&gt; Blob, desc =&gt; Str)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truepid-当前进程的进程-id"><a class="anchor" href="#truepid-当前进程的进程-id"></a>17.1.13. $*PID - 当前进程的进程 ID</h4>
<div class="listingblock">
<div class="title">pid.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*PID;      #=&gt; 91224
say $*PID.perl; #=&gt; 91224
say $*PID.WHAT; #=&gt; (Int)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueprogram-name-当前可执行文件的路径"><a class="anchor" href="#trueprogram-name-当前可执行文件的路径"></a>17.1.14. $*PROGRAM-NAME - 当前可执行文件的路径</h4>
<div class="listingblock">
<div class="title">program-name.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*PROGRAM-NAME;
say $*PROGRAM-NAME.perl;
say $*PROGRAM-NAME.IO.basename;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueprogram-当前执行的-perl-程序的位置"><a class="anchor" href="#trueprogram-当前执行的-perl-程序的位置"></a>17.1.15. $*PROGRAM - 当前执行的 Perl 程序的位置</h4>
<div class="listingblock">
<div class="title">program.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*PROGRAM;        #=&gt; "/Users/kujira/program.pl6".IO
say $*PROGRAM.Str;    #=&gt; program.pl6

say $*PROGRAM.perl;   #=&gt; "program.pl6".IO(:SPEC(IO::Spec::Unix),:CWD("/Users/kujira"))

say $*PROGRAM.SPEC;   #=&gt; (Unix)
say $*PROGRAM.CWD;    #=&gt; /Users/kujira

say $*PROGRAM.WHAT;   #=&gt; (Path)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueexecutable-当前运行的-perl-可执行文件的绝对路径"><a class="anchor" href="#trueexecutable-当前运行的-perl-可执行文件的绝对路径"></a>17.1.16. $*EXECUTABLE - 当前运行的 perl 可执行文件的绝对路径</h4>
<div class="listingblock">
<div class="title">executable.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*EXECUTABLE;           #=&gt; "/usr/local/bin/raku".IO
say $*EXECUTABLE.Str;       #=&gt; /usr/local/bin/raku
say $*EXECUTABLE.basename;  #=&gt; raku

say $*EXECUTABLE.WHAT;      #=&gt; (Path)

say $*EXECUTABLE.perl;      #=&gt; "/usr/local/bin/raku".IO(:SPEC(IO::Spec::Unix))
say $*EXECUTABLE.SPEC;      #=&gt; (Unix)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueexecutable-name-当前运行的-perl-可执行文件的名字"><a class="anchor" href="#trueexecutable-name-当前运行的-perl-可执行文件的名字"></a>17.1.17. $*EXECUTABLE-NAME - 当前运行的 perl 可执行文件的名字</h4>
<div class="listingblock">
<div class="title">executable-name.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*EXECUTABLE-NAME;       #=&gt; raku
say $*EXECUTABLE-NAME.WHAT;  #=&gt; (Str)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueuser-运行该程序的用户"><a class="anchor" href="#trueuser-运行该程序的用户"></a>17.1.18. $*USER - 运行该程序的用户</h4>
<div class="listingblock">
<div class="title">user.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*USER;      #=&gt; ohmycloud
say +$*USER;     #=&gt; 501
say ~$*USER;     #=&gt; ohmycloud
say $*USER.perl; #=&gt; IntStr.new(501, "ohmycloud")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truegroup-运行该程序的用户的主要组"><a class="anchor" href="#truegroup-运行该程序的用户的主要组"></a>17.1.19. $*GROUP - 运行该程序的用户的主要组</h4>
<div class="listingblock">
<div class="title">group.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*GROUP;       #=&gt; staff
say ~$*GROUP;      #=&gt; staff
say +$*GROUP;      #=&gt; 20
say $*GROUP.perl;  #=&gt; IntStr.new(20, "staff")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truehome-运行该程序的用户的家目录"><a class="anchor" href="#truehome-运行该程序的用户的家目录"></a>17.1.20. $*HOME - 运行该程序的用户的家目录</h4>
<div class="listingblock">
<div class="title">home.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*HOME;       #=&gt; "/Users/ohmycloud".IO

say $*HOME.CWD;   #=&gt; /Users/ohmycloud
say $*HOME.SPEC;  #=&gt; (Unix)
say $*HOME.WHAT;  #=&gt; (Path)

say $*HOME.perl;  #=&gt; IO::Path.new("/Users/ohmycloud", :SPEC(IO::Spec::Unix), :CWD("/Users/ohmycloud"))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://doc.raku.org/type/IO::Path">IO::Path</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="truespec-该程序所运行的平台"><a class="anchor" href="#truespec-该程序所运行的平台"></a>17.1.21. $*SPEC - 该程序所运行的平台</h4>
<div class="listingblock">
<div class="title">spec.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*SPEC;          #=&gt; (Unix)
say $*SPEC.perl;     #=&gt; IO::Spec::Unix
say $*SPEC.path;     #=&gt; (/usr/local/Cellar/rakudo-star/2019.03/share/raku/site/bin /usr/local/sbin /usr/local/bin /usr/bin /bin /usr/sbin /sbin)
say $*SPEC.tmpdir;   #=&gt; "/var/folders/ys/992mqs3s4px485rtg4t7jc3r0000gn/T/".IO
say $*SPEC.dir-sep;  #=&gt; /
say $*SPEC.curdir;   #=&gt; .
say $*SPEC.updir;    #=&gt; ..
say $*SPEC.curupdir; #=&gt; none(., ..)
say $*SPEC.rootdir;  #=&gt; /
say $*SPEC.devnull;  #=&gt; /dev/null</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewhatever-star-2"><a class="anchor" href="#truewhatever-star-2"></a>17.2. Whatever Star</h3>
<div class="paragraph">
<p>在 Raku 中，根据上下文的不同，您可以叫它星星（或者，如果你愿意的话，可以叫它星号）或者 <strong>whatever</strong>。</p>
</div>
<div class="paragraph">
<p>让我们看看 <code>*</code> 的不同用法，从最简单的开始，旨在了解最烧脑的例如 <code>* ** *</code>。</p>
</div>
<div class="paragraph">
<p>前两种用法很简单，不需要太多的讨论：</p>
</div>
<div class="sect3">
<h4 id="true1-乘法"><a class="anchor" href="#true1-乘法"></a>17.2.1. 1. 乘法</h4>
<div class="paragraph">
<p>单个星号用于乘法。严格来讲, 这是一个中缀运算符 <code>infix:&lt;*&gt;</code>, 它的返回值为 <code>Numeric</code>。</p>
</div>
<div class="listingblock">
<div class="title">multiplication</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 20 * 18; # 360</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true2-幂"><a class="anchor" href="#true2-幂"></a>17.2.2. 2. 幂</h4>
<div class="paragraph">
<p>两个星号 <code>**</code> 是幂运算符。再次, 这是一个中缀运算符 <code>infix:&lt;**&gt;</code>, 它返回 <code>Numeric</code> 结果, 计算两个给定值的幂。</p>
</div>
<div class="listingblock">
<div class="title">power</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say pi ** e; # 22.4591577183611</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true3-零或多次重复"><a class="anchor" href="#true3-零或多次重复"></a>17.2.3. 3. 零或多次重复</h4>
<div class="paragraph">
<p>正则表达式中同样也使用了两个标记（ <code>*</code> 或 <code>**</code>），它们表示不同的东西。 Raku 的一个特点是它可以很容易地在不同的语言之间切换。 正则表达式和 grammar 都是这样的内部语言的例子，其中同样的符号在 Raku 中可能意味着不同的含义。</p>
</div>
<div class="paragraph">
<p><code>*</code> 号量词这个语法条目和 Perl 5 中点行为类似: 允许原子的零次或多次重复。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $weather = '*****';
my $snow = $weather ~~ / ('*'*) /;
say 'Snow level is ' ~ $snow.chars; # Snow level is 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 我们还在这儿看到了同一个字符的另一种用法, <code>*</code> 字面量。</p>
</div>
</div>
<div class="sect3">
<h4 id="true4-min-到-max-次重复"><a class="anchor" href="#true4-min-到-max-次重复"></a>17.2.4. 4. Min 到 Max 次重复</h4>
<div class="paragraph">
<p>两个 <code>**</code> 号是另一个量词的一部分，它指定了最小和最大重复次数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $operator = '..';
say "'$operator' is a valid Raku operator"
    if $operator ~~ /^ '.' ** 1..3 $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，预计这个点会被重复一次，两次或三次; 不多也不少。</p>
</div>
<div class="paragraph">
<p>让我们超前一点儿，以 <code>Whatever</code> 符号的角色（剧场中的角色，而不是 Raku 的面向对象编程）使用星号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $phrase = 'I love you......';
say 'You are so uncertain...'
    if $phrase ~~ / '.' ** 4..* /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围的第二个端点是打开的，这个正则表达式接受所有其中包含四个点以上的短语。</p>
</div>
</div>
<div class="sect3">
<h4 id="true5-吞噬参数"><a class="anchor" href="#true5-吞噬参数"></a>17.2.5. 5. 吞噬参数</h4>
<div class="paragraph">
<p>在子例程签名的数组参数之前的星号意味着吞噬参数 - 将单独的标量参数吞噬进单个数组中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">list-gifts('chocolade', 'ipad', 'camelia', 'raku');

sub list-gifts(*@items) {
    say 'Look at my gifts this year:';
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>哈希也允许吞噬参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">dump(alpha =&gt; 'a', beta =&gt; 'b'); # Prints:
                                 # alpha = a
                                 # beta = b

sub dump(*%data) {
    for %data.kv {say "$^a = $^b"}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，与 Perl 5 不同的是，如果您省略函数签名中的星号，代码将无法编译，因为 Raku 就是说一不二：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">Too few positionals passed; expected 1 argument but got 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true6-吨吨吨吨吨吨吨"><a class="anchor" href="#true6-吨吨吨吨吨吨吨"></a>17.2.6. 6. 吨吨吨吨吨吨吨</h4>
<div class="paragraph">
<p><code>**@</code> 也能工作，但是当你传递数组或列表的时候请注意其中的区别。</p>
</div>
<div class="paragraph">
<p>带一颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a = &lt; chocolade ipad &gt;;
my @b = &lt; camelia raku &gt;;

all-together(@a, @b);
all-together(['chocolade', 'ipad'], ['camelia', 'raku']);
all-together(&lt; chocolade ipad &gt;, &lt; camelia raku &gt;);

sub all-together(*@items) {
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前，无论参数列表传递的方式如何，每个礼物都被单独打印了出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">chocolade
ipad
camelia
raku
chocolade
ipad
camelia
raku
chocolade
ipad
camelia
raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>带俩颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">keep-groupped(@a, @b);
keep-groupped(['chocolade', 'ipad'], ['camelia', 'raku']);
keep-groupped(&lt; chocolade ipad &gt;, &lt; camelia raku &gt;);

sub keep-groupped(**@items) {
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，<code>@items</code> 数组只有两个元素，反映了参数的结构类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[chocolade ipad]
[camelia raku]</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(chocolade ipad)
(camelia raku)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true7-动态作用域"><a class="anchor" href="#true7-动态作用域"></a>17.2.7. 7. 动态作用域</h4>
<div class="paragraph">
<p><code>*</code> twigil，引入了动态作用域。 动态变量和全局变量很容易搞混淆，所以最好测试下面的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub happy-new-year() {
    "Happy new $*year year!"
}

my $*year = 2018;
say happy-new-year(); # 输出 Happy new 2018 year!</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你省略了星号, 那么代码就运行不了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">Variable '$year' is not declared</code></pre>
</div>
</div>
<div class="paragraph">
<p>更正它的唯一方法是将 <code>$year</code> 的定义移到函数定义的上面。 使用动态变量 <code>$*year</code>，函数被调用的地方定义了结果。 <code>$*year</code> 变量在子例程的外部作用域中是不可见的，但是在动态作用域内是可见的。</p>
</div>
<div class="paragraph">
<p>对于动态变量，将新值赋给现有变量还是创建新变量并不重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub happy-new-year() {
    "Happy new $*year year!"
}

my $*year = 2018;
say happy-new-year();

{
    $*year = 2019;        # New value
    say happy-new-year(); # 2019
}

{
    my $*year = 2020;     # New variable
    say happy-new-year(); # 2020
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true8-编译变量"><a class="anchor" href="#true8-编译变量"></a>17.2.8. 8. 编译变量</h4>
<div class="paragraph">
<p>Raku 提供了许多伪动态常量, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $*PERL;      # Raku (6.d)
say @*ARGS;      # Prints command-line arguments
say %*ENV&lt;HOME&gt;; # Prints home directory</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true9-all-methods"><a class="anchor" href="#true9-all-methods"></a>17.2.9. 9. All methods</h4>
<div class="paragraph">
<p><code>.*</code> postfix 伪运算符调用给定名称的所有方法，名称可以在给定的对象中找到，并返回一个结果列表。 在微不足道的情况下，你会得到一个学术上荒诞不羁的代码：</p>
</div>
<div class="listingblock">
<div class="title">call with star</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">6.*perl.*say; # (6 Int.new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>带星号的代码与不带星号代码有些不同：</p>
</div>
<div class="listingblock">
<div class="title">call without star</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">pi.perl.say; # 3.14159265358979e0 (notice the scientific
             # format, unlike pi.say)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.*</code> postfix 的真正威力来自于继承。 它有时有助于揭示真相：</p>
</div>
<div class="listingblock">
<div class="title">dot star and inheritance</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Present {
    method giver() {
        'parents'
    }
}

class ChristmasPresent is Present {
    method giver() {
        'Santa Claus'
    }
}

my ChristmasPresent $present;

$present.giver.say;             # Santa Claus
$present.*giver.join(', ').say; # Santa Claus, parents</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个星号就差别很大!</p>
</div>
<div class="paragraph">
<p>现在，到了 Raku 最神秘的部分。接下来的两个概念，<code>Whatever</code> 和 <code>WhateverCode</code> 类，很容易混淆在一起。 让我们试着做对吧。</p>
</div>
</div>
<div class="sect3">
<h4 id="true10-whatever"><a class="anchor" href="#true10-whatever"></a>17.2.10. 10. Whatever</h4>
<div class="paragraph">
<p>Whatever 是什么呢? Placeholder for unspecified value/parameter - 未指定的值/参数的占位符。</p>
</div>
<div class="paragraph">
<p><code>*</code> 字面量在 「项」 的位置上创建 「Whatever」 对象。</p>
</div>
<div class="paragraph">
<p>单个星号 <code>*</code> 能表示任何东西(<code>Whatever</code>)。 <code>Whatever</code> 在 Raku 中是一个预定义好的类, 它在某些有用的场景下引入了一些规定好的行为。</p>
</div>
<div class="paragraph">
<p>例如，在范围和序列中，最后的 <code>*</code> 表示无穷大。 我们今天已经看到了一个例子。 这是另一个：</p>
</div>
<div class="listingblock">
<div class="title">* represent Inf in range and sequence</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">.say for 1 .. *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个单行程序具有非常高的能量转换效率，因为它产生了一个递增整数的无限列表。 如果你要继续，请按 <code>Ctrl + C</code>。</p>
</div>
<div class="paragraph">
<p>范围 <code>1 .. *</code> 与 <code>1 .. Inf</code> 相同。 您可以清楚地看到，如果您跳转到 Rakudo Raku 源文件并在 <code>Range</code> 类的实现中找到如下定义：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/rakudo/rakudo/blob/master/src/core/Range.pm">src/core/Range.pm</a></div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi method new(Whatever \min,Whatever \max,:$excludes-min,:$excludes-max){
    nqp::create(self)!SET-SELF(-Inf,Inf,$excludes-min,$excludes-max,1);
}
multi method new(Whatever \min, \max, :$excludes-min, :$excludes-max) {
    nqp::create(self)!SET-SELF(-Inf,max,$excludes-min,$excludes-max,1);
}
multi method new(\min, Whatever \max, :$excludes-min, :$excludes-max) {
    nqp::create(self)!SET-SELF(min,Inf,$excludes-min,$excludes-max,1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个 multi 构造函数描述了三种情况：<code>* .. <strong></code>，<code></strong> .. $n</code> 和 <code>$n .. *</code>，它们被立即转换为 <code>-Inf .. Inf</code>，<code>-Inf .. $n</code> 和 <code>$n .. Inf</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>作为一个圣诞故事，这里有一个小小的插曲，表明 <code>*</code> 不仅仅是一个 <code>Inf</code>。 有两个到 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Whatever.pm">src/core/Whatever.pm</a> 的提交：</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>首先，2015年9月16日，<a href="https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07">MakeWhatever.new == Inf True</a></p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { '*' }
+     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>几周之后, 在2015年10月23日，<a href="https://github.com/rakudo/rakudo/commit/4e35e807c5f0c8ac134e1ed87b4b9343966d0d8d#diff-ac169f9e5137f98d305f3cae4c0c4d07">* no longer defaults to Inf</a>, 这是为了保护其他 dwimmy 情况下的扩展性:</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { '*' }
-     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="paragraph">
<p>回到我们更实际的问题，让我们创建自己的使用 whatever 符号 <code>*</code> 的类，。 下面是一个简单的例子，它带有一个接收 <code>Int</code> 值或者 <code>Whatever</code> 的 multi-方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class N {
    multi method display(Int $n) {
        say $n;
    }

    multi method display(Whatever) {
        say 2000 + 100.rand.Int;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，该方法只是打印该值。 第二种方法是打印一个在 2000 到 2100 之间的随机数。 因为第二种方法的唯一参数是 <code>Whatever</code>，所以签名中不需要变量。</p>
</div>
<div class="paragraph">
<p>下面是你如何使用这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $n = N.new;
$n.display(2018);
$n.display(*);</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个调用回显它的参数，而第二个调用打印某些随机的东西。</p>
</div>
<div class="paragraph">
<p><code>Whatever</code> 符号可以作为一个裸的 <code>Whatever</code>。 假如，你创建一个 <code>echo</code> 函数，并将 <code>*</code> 传递给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub echo($x) {
    say $x;
}

echo(2018); # 2018
echo(*);    # *</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，没有魔术发生，该程序打印一个星号。</p>
</div>
<div class="paragraph">
<p>现在我们正处在一个四两拨千斤的节骨眼上。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Table Whatever</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">例外</th>
<th class="tableblock halign-left valign-top">例子</th>
<th class="tableblock halign-left valign-top">它是做什么的?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">逗号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,*,2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用一个 * 元素生成一个 Parcel</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">范围运算符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Range.new(:from(1), :to(*))</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">序列运算符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 &#8230;&#8203; *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无限列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">智能匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 ~~ *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 True</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">赋值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x = *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 * 赋值给 $x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">绑定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x := *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 * 绑定给 $x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">列表复制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 xx *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生成无限列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串复制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $str = '-' x *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生成字符串模板</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意不能使用嵌套的闭包:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1..5).map: { * ** 2 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">===SORRY!=== Error while compiling:
Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *
at line 2
------&gt; &lt;BOL&gt;⏏&lt;EOL&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意上面的错误信息, 说的已经很明显了, WhateverCode 已经是一个不带花括号的闭包了, 所以要么移除花括号, 要么使用合法的参数语法代替 <code>*</code> 号, 提示信息足够清楚了。所以, 按照提示:</p>
</div>
<div class="paragraph">
<p>方法一: 使用 <code>$_</code> 代替 <code>*</code> 号</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1..5).map: { $_ ** 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法二: 移除花括号</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1..5).map:  * ** 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法三: 显式的使用闭包</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1..5).map: -&gt; $item { $item ** 2 }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="true11-whatevercode"><a class="anchor" href="#true11-whatevercode"></a>17.2.11. 11. WhateverCode</h4>
<div class="paragraph">
<p>最后, 我们来谈谈 <code>WhateverCode</code>。<code><strong></code> 的大部分魔法来自于 「Whatever 柯里化」. 当 <code></strong></code> 作为项与很多运算符组合使用时, 编译器会把表达式转换为 「WhateverCode」 类型的闭包.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $c = * + 2;          # 等价于 my $c = -&gt; $x { $x + 2 };
say $c(4);              # 6
say $c.WHAT             # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my $c = &#8594; $x { $x + 2 }</code> 中, <code>$c</code> 是一个 <a href="https://docs.raku.org/type/Block">Block</a></p>
</div>
<div class="paragraph">
<p>如果一个表达式中有 N 个 <code>*</code>, 则会产生一个含有 N 个参数的闭包:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $c = * + *;          # 等价于 my $c = -&gt; $x, $y { $x + $y }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在复杂的表达式中使用 <code>*</code> 也会产生闭包:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $c = 4 * * + 5;      # 等价于 my $c = -&gt; $x { 4 * $x + 5 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>*</code> 号身上调用方法也会产生闭包:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&lt;a b c&gt;.map: *.uc;     # 等价于 &lt;a b c&gt;.map: -&gt; $char { $char.uc }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whatever 最强大的用处是 「Whatever」 闭包。</p>
</div>
<div class="paragraph">
<p>对于 Whatever 没有特殊意义的普通操作符：把 Whatever 当作参数传递时就创建了一个闭包！ 所以，举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">* + 1 # 等价于 -&gt; $a { $a + 1 }
* + * # 等价于 -&gt; $a, $b { $a + $b }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@list.grep(* &gt; 10)                  # 返回 @list 数组中所有大于 10 的元素
@list.grep( -&gt; $e { $e &gt; 10 } )     # 同上, 使用显式的闭包
@list.grep: -&gt; $e { $e &gt; 10 }       # 同上, 使用冒号调用方式
@list.grep: * &gt; 10                  # 同上
@list.grep: { $_ &gt; 10 }             # 同上

@list.map(* + *)                    # 返回 @list 数组中每两个元素的和
@list.map( -&gt; $a, $b { $a+$b } )    # 同上, 使用显式的闭包</code></pre>
</div>
</div>
<div class="paragraph">
<p>取一个数组然后打印出它的最后一个元素。如果你使用 Perl 5 的风格来做, 你会键入 <code>@a[-1]</code> 那样的东西。在 Raku 中, 那会产生错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">Unsupported use of a negative -1 subscript
to index from the end; in Raku please
use a function such as *-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译器建议使用一个函数, 例如 <code>*-1</code>。它是函数吗？是的, 更准确的说, 它是一个 <code>WhateverCode</code> 块:</p>
</div>
<div class="listingblock">
<div class="title">WhateverCode</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say (*-1).WHAT; # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果给 <code>@a[ ]</code> 的方括号里面传递一个闭包， 它会把 <code>@a</code> 数组的元素个数作为参数传递并计算！</p>
</div>
<div class="paragraph">
<p>数组的最后一个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a =  1,22,33,11;
say @a[*-1];
say @a[-&gt;$a {$a-1}]; # $a  即为数组@a 的元素个数</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组的倒数第二个元素</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say @a[*-2];
say @a[-&gt;$a {$a-2}];</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以 <code>@a[<strong>/2]</code> 是 <code>@a</code> 数组的中间元素, <code>@a[1..</strong>-2]</code> 是 <code>@a</code> 中不包含首尾元素的其它元素。</p>
</div>
<div class="paragraph">
<p>现在, 打印数组的后半部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a = &lt; one two three four five six &gt;;
say @a[3..*]; # (four five six)</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组的索引的范围是 <code>3 .. *</code>。 <code>Whatever</code> 作为 range 的右端意味着从数组中取出所有剩余的元素。 <code>3 .. *</code> 的类型是 <code>Range</code>:</p>
</div>
<div class="listingblock">
<div class="title">Range</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say (3..*).WHAT; # (Range)</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，减少一个元素。 我们已经看到，要指定最后一个元素，必须要使用诸如 <code>*-1</code> 的函数。 在 range 的右端可以做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say @a[3 .. *-2]; # (four five)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个时候，发生了所谓的 <code>Whatever-柯里化</code>，<code>Range</code> 变成了 <code>WhateverCode</code>:</p>
</div>
<div class="listingblock">
<div class="title">Whatever-柯里化</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say (3 .. *-2).WHAT; # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WhateverCode</code> 是一个内置的 Raku 类名称; 它可以很容易地用于方法分派。 让我们更新上一节中的代码，并添加一个方法变体，它需要一个 <code>WhateverCode</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class N {
    multi method display(Int $n) {
        say $n;
    }

    multi method display(Whatever) {
        say 2000 + 100.rand.Int;
    }

    multi method display(WhateverCode $code) {
        say $code(2000 + 100.rand.Int);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，参数列表中的星号要么落入 <code>display(Whatever)</code>, 要么落入 <code>display(WhateverCode)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">N.display(2018);     # display(Int $n)

N.display(*);        # display(Whatever)

N.display(* / 2);    # display(WhateverCode $code)
N.display(* - 1000); # display(WhateverCode $code)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再来看看 <code>display</code> 方法中的签名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi method display(WhateverCode $code)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$code</code> 参数被用作方法内的函数引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $code(2000 + 100.rand.Int);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数需要一个参数，但它会去哪里？ 或者换句话说，函数体是什么，在哪里？ 我们将该方法调用为 <code>N.display(* / 2)</code> 或 <code>N.display(* - 1000)</code>。 答案是 <code>* / 2</code> 和 <code>* - 1000</code> 都是函数！ 还记得编译器关于使用诸如 <code>*-1</code> 之类的函数的提示吗？</p>
</div>
<div class="paragraph">
<p>这里的星号成为第一个函数参数，因此 <code>* / 2</code> 相当于 <code>{$^a / 2}</code>，而 <code>*-1000</code> 相当于 <code>{$^a - 1000}</code>。</p>
</div>
<div class="paragraph">
<p>这是否意味着可以在 <code>$^a</code> 的旁边使用 <code>$^b</code>? 当然！ 使 <code>WhateverCode</code> 块接受两个参数。 你如何指出其中的第二个？ 毫不惊喜，再用一个星号！ 让我们将 <code>display</code> 方法的第四个变体添加到我们的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi method display(WhateverCode $code
                     where {$code.arity == 2}) {
    say $code(2000, 100.rand.Int);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，使用 <code>where</code> 块来缩小调度范围，只选择那些有两个参数的 <code>WhateverCode</code> 块。 完成此操作后，方法调用中将允许含有两个雪花：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">N.display( * + * );
N.display( * - * );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些调用定义了用于计算结果的函数 <code>$code</code>。 所以，<code>N.display(* + *)</code> 背后的实际操作如下：<code>2000 + 100.rand.Int</code>。</p>
</div>
<div class="paragraph">
<p>需要更多的雪花吗？ 多添加点星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">N.display( * * * );
N.display( * ** * );</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地, 里面实际的计算是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">2000 * 100.rand.Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">2000 ** 100.rand.Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜！ 你现在可以像编译器那样毫不费力地解析 <code>* ** *</code> 结构了。</p>
</div>
</div>
<div class="sect3">
<h4 id="true作业"><a class="anchor" href="#true作业"></a>17.2.12. 作业</h4>
<div class="paragraph">
<p>到目前为止，Raku 给了我们很多圣诞礼物。 让我们回过头来做一下练习并回答一下问题：下面代码中的每个星号在意味着什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @n =
    ((0, 1, * + * ... *).grep: *.is-prime).map: * * * * *;
.say for @n[^5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>我建议我们从转换代码开始来摆脱所有的星号，并使用不同的语法。</p>
</div>
<div class="paragraph">
<p>序列运算符 <code>&#8230;&#8203;</code> 之后的 <code>*</code> 意味着无限地生成序列，所以用 <code>Inf</code> 来代替它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">((0, 1, * + * ... Inf).grep: *.is-prime).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成器函数中的两个星号 <code>* + *</code> 可以用一个带有两个显式参数的 lambda 函数来替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">((0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep:
    *.is-prime).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，简单的语法交替。 用带圆括号的方法调用替换 <code>.grep</code>。 它的参数 <code><strong>.is-prime</code> 变成一个代码块，并且星号被替换为默认变量 <code>$_</code>。 请注意，代码使用 <code></strong></code> 时不需要花括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep({
    $_.is-prime
}).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，与 <code>.map</code> 相同的技巧：但是这次这个方法有三个参数，因此，你可以编写 <code>{$^a * $^b * $^c}</code> 而不是 <code>* * * * *</code>，这里是新的 完整程序的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @n = (0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep({
        $_.is-prime
    }).map({
        $^a * $^b * $^c
    });
.say for @n[^5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在很明显，代码打印了三个斐波那契素数组积的前五个。</p>
</div>
</div>
<div class="sect3">
<h4 id="true附加题"><a class="anchor" href="#true附加题"></a>17.2.13. 附加题</h4>
<div class="paragraph">
<p>在教科书中，最具挑战性的任务是用 <code>*</code> 标记的。 这里有几个由你自己来解决。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. Raku 中的 <code>chdir('/')</code> 和 <code>＆*chdir('/')</code> 有什么区别？</p>
</li>
<li>
<p>2. 解释下面的 Raku 代码并修改它以展示其优点：<code>.say for 1 &#8230;&#8203; **</code>。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true主题变量"><a class="anchor" href="#true主题变量"></a>18. 主题变量</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>$_</code> 是主题变量。它是 <strong>没有显式签名的块</strong> 的默认参数，因此 <code>for @array {&#8230;&#8203;}</code> 和 <code>given $var {&#8230;&#8203;}</code> 这样的构造通过调用块绑定到 <code>$_</code>。</p>
</div>
<div class="sect2">
<h3 id="truefor-2"><a class="anchor" href="#truefor-2"></a>18.1. for</h3>
<div class="listingblock">
<div class="title">for automatically set topic variable if there is no explicit signature</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for &lt;a b c&gt; { say $_ }  # sets $_ to 'a', 'b' and 'c' in turn
say $_ for &lt;a b c&gt;;     # same, even though it's not a block</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truegiven"><a class="anchor" href="#truegiven"></a>18.2. given</h3>
<div class="listingblock">
<div class="title">given</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given 'a'   { say $_ }  # sets $_ to 'a'
say $_ given 'a';       # same, even though it's not a block</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置默认的主题变量可以省去很多打字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for Date.new('2018-01-01') .. Date.new('2018-01-07') {
  printf("%04d%02d%02d%02d%02d%02d\n", .year, .month, .day, .hour, .minute, .second) given .DateTime
}

# 20180101000000
# 20180102000000
# 20180103000000
# 20180104000000
# 20180105000000
# 20180106000000
# 20180107000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>对象初始化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Employee {
    subset Salary         of Real where * &gt; 0;
    subset NonEmptyString of Str  where * ~~ /\S/;

    has NonEmptyString $.name    is rw;
    has NonEmptyString $.surname is rw;
    has Salary         $.salary  is rw;

    method gist {
        return qq:to[END];
        Name:    {$.name}
        Surname: {$.surname}
        Salary:  {$.salary}
        END
    }
}
my $employee = Employee.new();

given $employee {
    .name    = 'Sally';
    .surname = 'Ride';
    .salary  = 200;
}

say $employee;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueregex"><a class="anchor" href="#trueregex"></a>18.3. regex</h3>
<div class="paragraph">
<p>在方法上调用 <code>$_</code> 可以通过省略变量名来缩的更短：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">.say;                   # same as $_.say</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m/regex/</code> 和 <code>/regex/</code> 正则匹配 <code>$_</code> 而 <code>s/regex/subst/</code> 替换作用于 <code>$_</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say "Looking for strings with non-alphabetic characters...";
for &lt;ab:c d$e fgh ij*&gt; {
    .say if m/&lt;-alpha&gt;/;
}

# OUTPUT: «Looking for strings with non-alphabetic characters...
#          ab:c
#          d$e
#          ij*␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewithwithout"><a class="anchor" href="#truewithwithout"></a>18.4. with/without</h3>
<div class="paragraph">
<p>with 不引入块时也能设置 <code>$_</code> 主题变量：</p>
</div>
<div class="listingblock">
<div class="title">with</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say $_ with 42; # 42
.say with 42;   # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>with/without 会把条件设置为 <code>$_</code>：</p>
</div>
<div class="listingblock">
<div class="title">with</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># The below code says "Found a at 0"
my $s = "abc";
with   $s.index("a") { say "Found a at $_" }
orwith $s.index("b") { say "Found b at $_" }
orwith $s.index("c") { say "Found c at $_" }
else                 { say "Didn't find a, b or c" }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewhen-2"><a class="anchor" href="#truewhen-2"></a>18.5. when</h3>
<div class="paragraph">
<p><code>when</code> 语句使主题变量 <code>$_</code> 和所提供的表达式进行智能匹配，以使在指定匹配的时候能检查值、正则表达式和类型：</p>
</div>
<div class="listingblock">
<div class="title">for .. when</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for 42, 43, "foo", 44, "bar" {
    when Int { .say }
    when /:i ^Bar/ { .say }
    default  { say "Not an Int or a Bar" }
}
# OUTPUT: «42␤43␤Not an Int or a Bar␤44␤Bar␤»</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">&gt; for ('Swift', 'PHP', 'Python', 'Perl')  { .say if  Str }
Nil
&gt; for ('Swift', 'PHP', 'Python', 'Perl')  { .say if  $_ ~~ Str }
Swift
PHP
Python
Perl

for ('Swift', 'PHP', 'Python', 'Perl')  { .say when Str }
Swift
PHP
Python
Perl</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">for/when</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for (12, 24, 56, 42) {.say when *&gt;40 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>列表解析：</p>
</div>
<div class="listingblock">
<div class="title">ord</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(.ord when /7$/ for 1..99)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewhen-和-if"><a class="anchor" href="#truewhen-和-if"></a>18.6. when 和 if</h3>
<div class="paragraph">
<p><code>when</code> 块类似于 <code>if</code> 块，并且其中一个或两个都可以在外部块中使用，它们也都具有“语句修饰符”形式。但是如何处理相同的外部块中的代码是有区别的：当执行 <code>when</code> 块时，控制被传递到封闭块并忽略后面的语句; 但是当执行 <code>if</code> 块时，执行以下语句。 （注意，还有其他方法可以修改其他部分中讨论的每个的默认行为。）以下示例应说明 <code>if</code> 或 <code>when</code> 块的默认行为，假设 <code>if</code> 或 <code>when</code> 块中不包含特殊退出或其他副作用语句：</p>
</div>
<div class="listingblock">
<div class="title">block</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">{
    if X {...} # if X is true in boolean context, block is executed
    # following statements are executed regardless
}
{
    when X {...} # if X is true in boolean context, block is executed
                 # and control passes to the outer block
    # following statements are NOT executed
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果上面的 <code>if</code> 和 <code>when</code> 块出现在文件范围内，则在每种情况下都会执行以下语句。</p>
</div>
<div class="paragraph">
<p>有一个 <code>when</code> 有而 <code>if</code> 没有的功能：<code>when</code> 的布尔上下文测试默认为 <code>$_ ~~</code> 而 <code>if</code> 不是。这影响人们怎么在不带 <code>$_</code> 值的 <code>when</code> 块中使用 <code>X</code>
（在那种情况下， 它是 <code>Any</code>，并且 <code>Any</code> 和 <code>True</code> 智能匹配：<code>Any ~~ True</code> 产生 <code>True</code> ）。请看下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">{
    my $a = 1;
    my $b = True;
    when $a    { say 'a' }; # no output
    when so $a { say 'a' }  # a (in "so $a" 'so' coerces $a to Boolean context True
                            # which matches with Any)
    when $b    { say 'b' }; # no output (this statement won't be run)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，<code>when</code> 的语句修饰符形式不影响如下语句在另一个块内部或外部的执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say "foo" when X; # if X is true statement is executed
                  # following statements are not affected</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true签名-2"><a class="anchor" href="#true签名-2"></a>18.7. 签名</h3>
<div class="paragraph">
<p>块的<strong>默认签名</strong>是一个名为 <code>$_</code> 的位置参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my &amp;block =  { 'oi' };
&amp;block.signature.say; # (;; $_? is raw)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my class Employee {
   has Str $.name;
   has Rat $.wage;
}

my $boss     = Employee.new( name =&gt; "Frank Myers"     , wage =&gt; 6755.85 );
my $driver   = Employee.new( name =&gt; "Aaron Fast"      , wage =&gt; 2530.40 );
my $worker   = Employee.new( name =&gt; "John Dude"       , wage =&gt; 2200.00 );
my $salesman = Employee.new( name =&gt; "Frank Mileeater" , wage =&gt; 4590.12 );

my @team = $boss, $driver, $worker, $salesman;

say @team.sort({.wage} )».name;
.name.say for @team.sort: {.wage};
say "The driver is {.name}" given $driver;</code></pre>
</div>
</div>
<div class="paragraph">
<p>块里面会默认有一个 <code>$_</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $tiles := (&lt; T S R E A N D &gt;).Bag;
my $total := $tiles.total;

my @results = lazy '/usr/share/dict/SOWPODS'.IO.lines.grep: {
    .chars ≤ $total &amp;&amp;
    .substr(0, 1) ∈ $tiles &amp;&amp;
    .comb.Bag ⊆ $tiles
}

for @results -&gt; $word {
    say $word;
}

say "\n" ~ "Found {@results.elems} words in {now - INIT now} seconds";</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true模式匹配"><a class="anchor" href="#true模式匹配"></a>19. 模式匹配</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">given/when and scalar</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $name = "twostraws";

given $name {
  when "bilbo"      { say "Hello, Bilbo Baggins!"}
  when "twostraws"  { say "Hello, Paul Hudson!"  }
  default           { say "身份验证失败"           }
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="true同时检查名字和密码"><a class="anchor" href="#true同时检查名字和密码"></a>19.1. 同时检查名字和密码</h3>
<div class="listingblock">
<div class="title">given/when and tuple</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $name     = "twostraws";
my $password = "fr0st1es";

given ($name, $password) {
  when ("bilbo", "bagg1n5")      { say "Hello, Bilbo Baggins!" }
  when ("twostraws", "fr0st1es") { say "Hello, Paul Hudson!"   }
  default                        { say "你是谁?"                }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true使用单个元组"><a class="anchor" href="#true使用单个元组"></a>19.2. 使用单个元组</h3>
<div class="listingblock">
<div class="title">given/when and tuple</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $authentication = ("twostraws", "fr0st1es");

given $authentication {
  when ("bilbo", "bagg1n5")      { say "Hello, Bilbo Baggins!" }
  when ("twostraws", "fr0st1es") { say "Hello, Paul Hudson!"   }
  default                        { say "你是谁?"                }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true部分匹配"><a class="anchor" href="#true部分匹配"></a>19.3. 部分匹配</h3>
<div class="paragraph">
<p>你只关心某些感兴趣的值，不关心其它值，使用 <code>*</code> 号或 <code>$</code> 来代表 "any value is fine"</p>
</div>
<div class="listingblock">
<div class="title">given/when and */$</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $authentication = ("twostraws", "fr0st1es", "127.0.0.1");
given $authentication {
  when ("bilbo", "bagg1n5", *)      { say "Hello, Bilbo Baggins!"}
  when ("twostraws", "fr0st1es", $) { say "Hello, Paul Hudson!"  }
  default                           { say "Who are you?"         }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true只匹配元组的一部分"><a class="anchor" href="#true只匹配元组的一部分"></a>19.4. 只匹配元组的一部分</h3>
<div class="paragraph">
<p>但仍然想知道其它部分是什么</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $authentication = ("twostraws", "fr0st1es");
given $authentication {
  when ("bilbo", *)     { say "Hello, Bilbo Baggins!" }
  when ("twostraws", *) { say "Hello, Paul Hudson: your password was $_!" }
  default               { say "Who are you?"         }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true匹配计算型元组"><a class="anchor" href="#true匹配计算型元组"></a>19.5. 匹配计算型元组</h3>
<div class="listingblock">
<div class="title">given/when and computational tuple</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub fizzbuzz(Int $number) returns Str {
    given ($number % 3 == 0, $number % 5 == 0) {
      when (True, False)  { return "Fizz"     }
      when (False, True)  { return "Buzz"     }
      when (True, True)   { return "FizzBuzz" }
      when (False, False) { return $number.Str}
    }
}

say fizzbuzz(15);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true遍历元组"><a class="anchor" href="#true遍历元组"></a>19.6. 遍历元组</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $twostraws = ("twostraws", "fr0st1es");
my $bilbo = ("bilbo", "bagg1n5");
my $taylor = ("taylor", "fr0st1es");
my @users = $twostraws, $bilbo, $taylor;

for @users -&gt; $user {
    say $user[0];
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true使用-when-匹配元组中的指定值"><a class="anchor" href="#true使用-when-匹配元组中的指定值"></a>19.7. 使用 when 匹配元组中的指定值</h3>
<div class="listingblock">
<div class="title">when/for</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $twostraws = ("twostraws", "fr0st1es");
my $bilbo = ("bilbo", "bagg1n5");
my $taylor = ("taylor", "fr0st1es");
my @users = $twostraws, $bilbo, $taylor;

say "User twostraws has the password fr0st1es" when ("twostraws", "fr0st1es") for @users;

# 打印秘密为指定值的用户
say "User $_[0] has password \"fr0st1es\"" when (*, "fr0st1es") for @users;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true匹配范围"><a class="anchor" href="#true匹配范围"></a>19.8. 匹配范围</h3>
<div class="listingblock">
<div class="title">given/when and range</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $age = 36;

given $age {
  when 0 ..^ 18   { say "你有活力有时间，但是没钱"  }
  when 18 ..^ 70  { say "你有活力有钱，但是没时间"  }
  default         { say "你有时间和金钱，但是没活力"}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewhen-可以配合智能匹配操作符-单独使用"><a class="anchor" href="#truewhen-可以配合智能匹配操作符-单独使用"></a>19.9. when 可以配合智能匹配操作符 ~~ 单独使用</h3>
<div class="listingblock">
<div class="title">when and smartmatch</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $age = 36;
when $age ~~ 0 ..^ 18  { say "你有活力有时间，但是没钱"  }
when $age ~~ 18 ..^ 70 { say "你有活力有钱，但是没时间"  }
default                { say "你有时间和金钱，但是没活力"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true使用-contains-方法"><a class="anchor" href="#true使用-contains-方法"></a>19.10. 使用 contains 方法</h3>
<div class="listingblock">
<div class="title">when/contains</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $age = 36;
when (0 ..^ 18).contains($age)  { say "你有活力有时间，但是没钱"  }
when (18 ..^ 70).contains($age) { say "你有活力有钱，但是没时间"  }
default                         { say "你有时间和金钱，但是没活力"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true匹配元组中的范围"><a class="anchor" href="#true匹配元组中的范围"></a>19.11. 匹配元组中的范围</h3>
<div class="listingblock">
<div class="title">given/when and range</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $user = ("twostraws", "fr0st1es", 36);
given $user {
  my $name = $user[0];
  when ($name, *, 0 ..^ 18)  { say "$name 有活力有时间，但是没钱"  }
  when ($name, *, 18 ..^ 70) { say "$name 有活力有钱，但是没时间"  }
  when ($name, *, *)         { say "$name 有时间和金钱,但是没活力" }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true枚举"><a class="anchor" href="#true枚举"></a>19.12. 枚举</h3>
<div class="listingblock">
<div class="title">given/when and enum</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">enum WeatherType &lt;Cloudy Sunny Windy&gt;;
my $today = WeatherType::Cloudy;

given $today {
  when WeatherType::Cloudy { say "多云" }
  when WeatherType::Sunny  { say "晴天" }
  when WeatherType::Windy  { say "有风" }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true使用-if-语句"><a class="anchor" href="#true使用-if-语句"></a>19.13. 使用 if 语句</h3>
<div class="listingblock">
<div class="title">if and enum</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">if $today ~~ WeatherType::Cloudy { say "多云" }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true关联值"><a class="anchor" href="#true关联值"></a>19.14. 关联值</h3>
<div class="listingblock">
<div class="title">given/when and enum with associated value</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">enum WeatherType  (
    Cloudy =&gt; 100,
    Sunny  =&gt; 50,
    Windy  =&gt; 30
);

my $today = WeatherType::Windy;
given $today {
  when WeatherType::Cloudy { say 20*Cloudy }
  when WeatherType::Sunny  { say 10*Sunny  }
  when WeatherType::Windy  { say 12*Windy  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewhen-从句"><a class="anchor" href="#truewhen-从句"></a>19.15. when 从句</h3>
<div class="listingblock">
<div class="title">when/for clause</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @numbers = 1..10;
.say when $_ % 2 == 1 for @numbers;

my @celebrities = "Michael Jackson", "Taylor Swift", "MichaelCaine", "Adele Adkins", "Michael Jordan";
.say when /^Michael/ for @celebrities;     # 使用正则表达式
.say when $_.chars &gt; 12 for @celebrities;  # 调用方法
.say when /^Michael/ and $_.chars &gt;12 for @celebrities; # 复合条件</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true解构"><a class="anchor" href="#true解构"></a>20. 解构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true解构和赋值"><a class="anchor" href="#true解构和赋值"></a>20.1. 解构和赋值</h3>
<div class="paragraph">
<p>解构和赋值可以结合使用。</p>
</div>
<div class="listingblock">
<div class="title">deconstruction and assignment</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my (Str $a, Str $b, Int $c) = &lt;a b&gt;;
say [$a, $b, $c].perl;
# OUTPUT«["a", "b", Int]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要跳过列表中的元素, 使用匿名状态变量 <code>$</code>。</p>
</div>
<div class="listingblock">
<div class="title">skip variable with <code>$</code></div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my ($,$a,$,%h) = ('a', 'b', [1,2,3], {:1th});
say [$a, %h].perl;
# OUTPUT«["b", {:th(1)}]␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true使用签名解构参数"><a class="anchor" href="#true使用签名解构参数"></a>20.2. 使用签名解构参数</h3>
<div class="listingblock">
<div class="title">pass hash to routine</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub myfunc(%h) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我可以使用一个散列来调用该函数:</p>
</div>
<div class="listingblock">
<div class="title">call myfunc with hash</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %h = a =&gt; 1, b =&gt; 'this', c =&gt; 2.2;
myfunc(%h);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我想验证某些特定的键是否符合某种类型：</p>
</div>
<div class="listingblock">
<div class="title">parameters constraint with where clause</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %h = a =&gt; 1, b =&gt; 'this', c =&gt; 2.2;

sub myfunc(
    %h where
    .&lt;a&gt; ~~ Int &amp;&amp;
    .&lt;b&gt; ~~ Str &amp;&amp;
    .&lt;c&gt; ~~ Rat
) {
    say %h.perl;
}

myfunc(%h);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我还想把散列的各个键赋值给其他变量：</p>
</div>
<div class="listingblock">
<div class="title">parameters constraint with where clause</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub myfunc(
    %h where
    .&lt;a&gt; ~~ Int &amp;&amp;
    .&lt;b&gt; ~~ Str &amp;&amp;
    .&lt;c&gt; ~~ Rat
) {
    my $a = %h&lt;a&gt;;
    my %b = %h&lt;b&gt;;
    my %c = %h&lt;c&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样很烦, 因为把散列的值赋值给变量, 这样的语句可能要重复很多次, 而且你也发现了这会重复引用那个散列, 很多次!</p>
</div>
<div class="paragraph">
<p>参数后面可以跟着用圆括号包围的子签名, 这就会解构所给定的参数.</p>
</div>
<div class="listingblock">
<div class="title">hash deconstruction</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub myfunc(%h (Int :$a, Str :$b, Rat :$c)) {...}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true列表解构"><a class="anchor" href="#true列表解构"></a>20.3. 列表解构</h3>
<div class="paragraph">
<p>列表的解构正好是列表的元素:</p>
</div>
<div class="listingblock">
<div class="title">first element of array using destructuring</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub first( @array ($first, *@rest) ) { $first }
sub first(     *@ [$first, *@]     ) { $first }
sub first(        [$first, *@]     ) { $first }</code></pre>
</div>
</div>
<div class="paragraph">
<p>很神奇吧, 你不用在函数体里面写出 <code>first</code> 函数的逻辑, 你只使用子签名, 就自动获得了获取列表首元素的逻辑。</p>
</div>
<div class="listingblock">
<div class="title">tail elements of array using destructuring</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub tail( @array ($first, *@tail) ) { @tail }
sub tail(     *@ [$,      *@tail] ) { @tail }
sub tail(        [$,      *@tail] ) { @tail }</code></pre>
</div>
</div>
<div class="paragraph">
<p>外部参数是可以是匿名的 (<code>@</code>)。匿名参数可以省略。</p>
</div>
</div>
<div class="sect2">
<h3 id="true散列解构-2"><a class="anchor" href="#true散列解构-2"></a>20.4. 散列解构</h3>
<div class="paragraph">
<p>散列的解构是它的 pairs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi key-type ($ (Numeric :$key, *%)) { "Number" }
multi key-type ($ (Str     :$key, *%)) { "String" }
for (42 =&gt; 'a', 'b' =&gt; 42) -&gt; $pair {
    say key-type $pair;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">Number
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 <code>&#8658;</code> 构造了一个 <a href="http://doc.raku.org/type/Pair">Pair</a>，它有一个 <code>key</code> 和一个 <code>value</code> 属性。子签名中的 <code>:$key</code> 命名参数提取属性 <code>key</code>。 <code>*%</code> 中的 <code>%</code> 是匿名的, <code>*%</code> 接收所有剩余参数到一个匿名散列中, 不予使用。</p>
</div>
<div class="listingblock">
<div class="title">anonymous hash deconstruction</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub all-dimensions(% (:length(:$x), :width(:$y), :depth(:$z))) {
    $x andthen $y andthen $z andthen True
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尖号块儿循环也能解构散列:</p>
</div>
<div class="listingblock">
<div class="title">hash deconstruction with pointy block</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %hhgttu = (:40life, :41universe, :42everything);
for %hhgttu -&gt; (:$key, :$value) {
  say "$key → $value";
}
# OUTPUT: «universe → 41␤life → 40␤everything → 42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常, 对象是基于对象的属性来解构的. 惯用法就是在 for 循环中解包一个 <a href="https://docs.raku.org/type/Pair">Pair</a> 的键和值:</p>
</div>
<div class="listingblock">
<div class="title">pairs deconstruction with pointy block</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for &lt;Peter Paul Merry&gt;.pairs -&gt; (:key($index), :value($guest)) { }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">hash deconstruction with pointy block</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="pelr6" class="language-pelr6 hljs">subset Seconds of Numeric;

my regex number { \d+ [ '.' \d+ ]? } # float
my regex suffix { &lt;:alpha&gt; } # 只匹配字母

# 每天, 每小时, 每分钟, 每秒所对应的秒数
my %unit-multipliers = 'd' =&gt; 60*60*24, 'h' =&gt; 60*60, 'm' =&gt; 60, 's' =&gt; 1;

sub MAIN(*@timicles where .all ~~ /&lt;number&gt; &lt;[dhms]&gt;/) {
    my Seconds $to-wait = @timicles»\
        .match(/&lt;number&gt; &lt;suffix&gt;+/)».hash\
        .map(-&gt; %( Rat(Any) :$number, Str(Any) :$suffix) { %unit-multipliers{$suffix} * $number } )\
        .sum;
    say $to-wait ~ "s";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">timicles.pl6</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">raku timicles.pl6 1d 2h 3m 5s</code></pre>
</div>
</div>
<div class="paragraph">
<p>对象解包为它们的属性只是默认行为. 要使对象以另外的方式解构, 要更改它的 <a href="https://docs.raku.org/routine/Capture">Capture</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="true解构-json"><a class="anchor" href="#true解构-json"></a>20.5. 解构 JSON</h3>
<div class="paragraph">
<p>相当不错，但如果你有<strong>更</strong>复杂的东西呢？</p>
</div>
<div class="paragraph">
<p>假如说一块儿有嵌套结构的 JSON，某些部分可能缺失了, 它们需要默认值, 等等。</p>
</div>
<div class="listingblock">
<div class="title">parse json to hash object</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">use JSON::Fast;
my $item = from-json(q:to/END/);
    {
        "book" : {
            "title"  : "A Christmas Carol",
            "author" : "Charles Dickens"
        },
        "count" : 12,
        "tags" : [ "christmas", "santa"]
    }
    END</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <a href="https://github.com/timo/json_fast">JSON::Fast</a> 的 <code>from-json()</code> 将其解析为 perl 中的数据结构。 你可以在函数签名中描述整个 JSON 结构，以便接收以下内容：</p>
</div>
<div class="listingblock">
<div class="title">anonymous hash deconstruction</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub myfunc(% (:%book (Str:D :$title, Str:D :$author), Int :$count,
              :@tags ($first-tag, *@other-tags)) )
{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在函数体中，我可以将这些部分引用为 <code>$title</code>，<code>$author</code>，<code>$count</code> 和 <code>@tags</code>。 为了方便起见，我还将标签分成了 <code>$first-tag</code> 和 <code>@other-tags</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="true在块儿中使用签名"><a class="anchor" href="#true在块儿中使用签名"></a>20.6. 在块儿中使用签名</h3>
<div class="paragraph">
<p>当然，签名对于子程序来说是幻想的，但是你也可以在块儿(Block)中使用签名和解构。 假设你有一个上面的 JSON 条目的数组，并希望通过一个 <code>for</code> 循环遍历它们？ 只需在 <code>for</code> 的尖号块中使用解构签名即可：</p>
</div>
<div class="listingblock">
<div class="title">hash deconstruction with pointy block</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for @itemlist -&gt; % (:%book (Str:D :$title, Str:D :$author), Int :$count,
                    :@tags ($first-tag, *@other-tags))
{
    say "$title, $author, $count, @tags[], $first-tag, @other-tags[]"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在这种情况下，我甚至不需要散列本身，所以我省略了散列的名称，仅使用 <code>％</code> 作为匿名散列（关联）。</p>
</div>
</div>
<div class="sect2">
<h3 id="true解构对象"><a class="anchor" href="#true解构对象"></a>20.7. 解构对象</h3>
<div class="paragraph">
<p>你有没有试过遍历一组对象，你所做的第一件事是调用一些访问器来获取一些属性？ 当然，你可以使用 <code>.attribute</code> 和 主题化的迭代器，但是使用子签名，你可以做更多。</p>
</div>
<div class="listingblock">
<div class="title">object deconstruction</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Book {
    has $.title;
    has $.author;
    has $.count;
    has @.tags;
}

my @booklist =
    Book.new(title =&gt; 'A Christmas Carol',
             author =&gt; 'Charles Dickens',
             count =&gt; 12,
             tags =&gt; &lt;ghost christmas&gt;),

    Book.new(title =&gt; 'A Visit from St. Nicholas',
             author =&gt; 'Clement Clarke Moore',
             count =&gt; 4,
             tags =&gt; &lt;santa christmas&gt;);

for @booklist -&gt; Book $b (:$title,:$author, :$count, :@tags) {
    say "$title, $author, $count, @tags[]";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再看一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class body { has ( $.head, @.arms, @.legs ) } # Declare a class (object structure).
class person { has ( $.mom, $.body, $.age ) } # And another that includes first.

multi person's-age-and-legs                   # Declare a function that matches ...
  ( person                                    # ... a person ...
    ( :$age where * &gt; 40,                     # ... whose age is over 40 ...
      :$body ( :@legs, *% ),                  # ... noting their body's legs ...
      *% ) )                                  # ... and ignoring other attributes.
  { say "$age {+@legs}" }                     # Display age and number of legs.

my $age = 42;                                 # Let's demo handy :$var syntax below.
person's-age-and-legs                         # Call function declared above ...
  person                                      # ... passing a person.
    .new:                                     # Explicitly construct ...
      :$age,                                  # ... a middle aged ...
      body =&gt; body.new:
        :head,
        :2arms,
        legs =&gt; &lt;left middle right&gt;           # ... three legged person.
# Displays "42 3"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想检查类型或定义，或设置默认值，您都可以在签名中正确地执行。 如果您不喜欢对象属性的名称，则可以使用别名来重命名它们, 你开心就行。</p>
</div>
<div class="paragraph">
<p>我发现解构参数在与数据库查询结果和 JSON 交互中非常有用。 您可以使用任何其他签名特性，包括指定类型，定义，可选性，默认值，使用别名重命名，使用子集约束或“where”从句，slurpies 等。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true模块"><a class="anchor" href="#true模块"></a>21. 模块</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true模块结构"><a class="anchor" href="#true模块结构"></a>21.1. 模块结构</h3>

</div>
<div class="sect2">
<h3 id="true模块创建"><a class="anchor" href="#true模块创建"></a>21.2. 模块创建</h3>

</div>
<div class="sect2">
<h3 id="true模块调试"><a class="anchor" href="#true模块调试"></a>21.3. 模块调试</h3>

</div>
<div class="sect2">
<h3 id="true模块打包"><a class="anchor" href="#true模块打包"></a>21.4. 模块打包</h3>

</div>
<div class="sect2">
<h3 id="true导出和选择性导出"><a class="anchor" href="#true导出和选择性导出"></a>21.5. 导出和选择性导出</h3>
<div class="sect3">
<h4 id="trueis-export"><a class="anchor" href="#trueis-export"></a>21.5.1. is export</h4>
<div class="paragraph">
<p>packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 <code>is export</code> 特性来导出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">unit module MyModule;
our      $var      is export = 3;
sub      foo       is export { ... };
constant $FOO      is export = "foobar";
enum     FooBar    is export &lt;one two three&gt;;

# 像类那样的包也可被导出
class MyClass is export {};

# 如果 subpackage 在当前包的名字空间里
# 则它不需要显式导出
class MyModule::MyClass {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像所有的 traits 一样, 如果应用到子例程(routine)上, "is export" 应该出现在参数列表的后面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo (Str $string) is export {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以给 <code>is export</code> 传递命名参数以组织要导出的符号, 然后导入程序 (importer) 可以剔除和选择导入哪一个。有 3 个预先定义好的标签： <code>ALL</code>, <code>DEFAULT</code>, <code>MANDATORY</code>（强制的）。</p>
</div>
<div class="listingblock">
<div class="title">lib/MyModule.pm</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">unit module MyModule;
sub bag        is export              { ... }
sub pants      is export(:MANDATORY)  { ... }
sub sunglasses is export(:day)        { ... }
sub torch      is export(:night)      { ... }
sub underpants is export(:ALL)        { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">main.pl</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">use lib 'lib';
use MyModule;           #bag, pants
use MyModule :DEFAULT;  #the same
use MyModule :day;      #pants, sunglasses
use MyModule :night;    #pants, torch
use MyModule :ALL;      #bag, pants, sunglasses, torch, underpants</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueunitexport"><a class="anchor" href="#trueunitexport"></a>21.5.2. UNIT::EXPORT::*</h4>
<div class="paragraph">
<p>表象之下, 其实 <code>is export</code> 是把符号添加到 <code>EXPORT</code> 命名空间中的 <code>UNIT</code> 作用域包中。例如, <code>is export(:FOO)</code> 会把目标添加到 <code>UNIT::EXPORT::FOO</code> 包中。这正是 Raku 决定导入什么所做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">unit module MyModule;

sub foo is export         { ... }
sub bar is export(:other) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">unit module MyModule;

my package EXPORT::DEFAULT {
  our sub foo { ... }
}

my package EXPORT::other {
  our sub bar { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>多数时候, <code>is export</code> 足够用了, 但是当你想动态生成要导出的符号时, <code>EXPORT</code> 包就很有用了。例如：</p>
</div>
<div class="listingblock">
<div class="title">lib/MyModule.pm</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">unit module MuModule;

my package EXPORT::DEFAULT {
  for &lt;zero one two three four&gt;.kv -&gt; $number, $name {
      for &lt;sqrt log&gt; -&gt; $func {
          OUR::{'&amp;' ~ $func ~ '-of-' ~ $name } := sub { $number."$func()" };
      }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">main.pl</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">use MyModule;
say sqrt-of-four; #-&gt; 2
say log-of-zero;  #-&gt; -Inf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueexport"><a class="anchor" href="#trueexport"></a>21.5.3. EXPORT</h4>
<div class="paragraph">
<p>你可以用一个 <code>EXPORT</code> 子例程导出任意符号。 <code>EXPORT</code> 必须返回一个 <code>Map</code>, 在 map 里面键是符号名, 键值是想要的值。符号名应该包含(如果有的话)关联类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class MyModule::Class { ... }

sub EXPORT {
  {
      '$var'      =&gt; 'one',
      '@array'    =&gt; &lt;one two three&gt;,
      '%hash'     =&gt; { one =&gt; 'two', three =&gt; 'four'},
      '&amp;doit'     =&gt; sub { ... },
      'ShortName' =&gt; MyModule::class
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">main.pl</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">use lib 'lib';
use MyModule;
say $var;
say @array;
say %hash;
doit();
say ShortName.new;  #-&gt; MyModule::Class.new</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, <code>EXPORT</code> 不能声明在包内, 因为目前的 rakudo(2015.09) 好像把 EXPORT 当作 compunit 的一部分而非包的一部分。</p>
</div>
<div class="paragraph">
<p>虽然 <code>UNIT::EXPORT</code> 包处理传递给 <code>use</code> 的命名参数, 而 <code>EXPORT</code> sub 处理位置参数。如果你把位置参数传递给 <code>use</code>, 那么这些参数会被传递给 <code>EXPORT</code>. 如果传递了位置参数, 那么 module 就不再需要导出默认符号了。你仍然可以伴随着你的位置参数, 通过显式地给 use 传递 <code>:DEFAULT</code> 参数来导入它们。</p>
</div>
<div class="listingblock">
<div class="title">lib/MyModule</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class MyModule::Class {}

sub EXPORT($short_name?) {
    {
      do $short_name =&gt; MyModule::Class if $short_name
    }
}

sub always is export(:MANDATORY) { say "works" }

#import with :ALL or :DEFAULT to get
sub shy is export { say "you found me!" }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">main.pl</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">use lib 'lib';
use MyModule 'foo';
say foo.new(); # MyModule::Class.new
always();      # OK   - is imported
shy();         # FAIL - won't be imported</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true发布模块"><a class="anchor" href="#true发布模块"></a>21.6. 发布模块</h3>
<div class="paragraph">
<p>如果你已经写了一个 Raku模块, 你想把它分享到社区, 我们会很高兴地把它放到 Raku 模块文件夹清单中。<a href="http://modules.raku.org/">Raku modules directory</a></p>
</div>
<div class="paragraph">
<p>现在, 你需要使用 git 对你的模块进行版本控制。</p>
</div>
<div class="paragraph">
<p>这需要你有一个 Github 帐号, 以使你的模块能被从它的 Github 仓库中分享出去。</p>
</div>
<div class="paragraph">
<p>要分享你的模块, 按照下面说的做：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个以你的模块命名的工程文件夹。 例如, 如果你的模块是 <code>Vortex::TotalPerspective</code> , 那么就创建一个叫做 <code>Vortex::TotalPerspective</code> 的工程文件夹。这个工程目录的名字也会被用作 Github 仓库的名字。</p>
</li>
<li>
<p>让你的工程目录看起来像这样：</p>
<div class="literalblock">
<div class="content">
<pre>Vortex-TotalPerspective/
|-- lib
|   `-- Vortex
|       `-- TotalPerspective.pm
|-- LICENSE
|-- META.info
|-- README.md
`-- t
    `-- basic.t</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你的工程包含能帮助主模块完成工作的其它模块, 它们应该被放到你的 lib 目录中像这样组织：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>lib
`-- Vortex
    |-- TotalPerspective.pm
    `-- TotalPerspective
        |-- FairyCake.pm
        `-- Gargravarr.pm</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>README.md</code> 文件是一个 markdown 格式的文件, 它稍后会被 Github 自动渲染成 HTML</p>
</li>
<li>
<p>关于 LICENSE 文件, 如果你没有其它选择, 就是用和 Rakudo Raku 一样的 LICENSE 把。仅仅把它的原始 <a href="https://github.com/rakudo/rakudo/blob/nom/LICENSE">license</a> 复制/粘贴进你自己的 LICENSE 文件中。</p>
</li>
<li>
<p>如果你还没有任何测试, 现在你可以忽略 <code>t</code> 目录 和 <code>basic.t</code> 文件。关于如何写测试, 你可以看看其它模块是怎么使用 <code>Test</code> 的。它和 Perl'5 的 <code>Test::More</code> 很类似。</p>
</li>
<li>
<p>如果要文档化你的模块, 在你的模块中使用 <a href="http://design.raku.org/S26.html">Raku Pod</a> 标记。欢迎给模块写文档, 并且为了浏览的方便, 一旦 Raku module directory(或其它网站) 开始把 Pod 文档渲染成 HTML, 写文档尤为重要。</p>
</li>
<li>
<p>让你的 <code>META.info</code> 文件看起来像这样:</p>
<div class="literalblock">
<div class="content">
<pre>{
       "name"        : "Vortex::TotalPerspective",
       "version"     : "0.1.0",
       "description" : "Wonderful simulation to get some perspective.",
       "author"      : "Your Name",
       "provides"    : {
           "Vortex::TotalPerspective" : "lib/Vortex/TotalPerspective.pm"
       },
       "depends"     : [ ],
       "source-url"  : "git://github.com/you/Vortex-TotalPerspective.git"
   }</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>关于选择版本号的方案, 或许使用 "major.minor.patch" （查看  the spec on versioning 获取详细信息 ）。如果版本号现在对你或你的用户来说不重要, 你可以给版本那儿放上一颗星(<code>*</code>)。</p>
</div>
<div class="paragraph">
<p>在 <code>provides</code> 一节, 包含进你的发布中提供的所有命名空间。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>把你的工程放在 git 版本控制之下, 如果你还未这样做。</p>
</li>
<li>
<p>一旦你对你的工程满意了, 在 Github 上为它创建一个仓库。必要的话,  查看 <a href="https://help.github.com/">Github&#8217;s help docs</a>。 你的 Github 仓库的名字应该和你工程目录的名字一样。创建完 Githhub 仓库后, Github 会为你展示怎么配置你的本地仓库以获悉你的 Github 仓库。</p>
</li>
<li>
<p>把你的工程推送到 Github</p>
</li>
<li>
<p>在 IRC 频道找个人帮你展示怎么把你的模块添加到 <a href="https://github.com/raku/ecosystem">ecosystem</a>, 或者让他们是否能替你添加。</p>
</li>
<li>
<p>pull 请求被接收之后, 等个把小时。如果你的模块没有出现在  <a href="http://modules.raku.org/" class="bare">http://modules.raku.org/</a> , 请到 <a href="http://modules.raku.org/log/update.log" class="bare">http://modules.raku.org/log/update.log</a> 翻看log 日志文件, 以查找是否有错误。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true排序"><a class="anchor" href="#true排序"></a>22. 排序</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true数组排序"><a class="anchor" href="#true数组排序"></a>22.1. 数组排序</h3>

</div>
<div class="sect2">
<h3 id="true散列排序"><a class="anchor" href="#true散列排序"></a>22.2. 散列排序</h3>
<div class="paragraph">
<p>使用 <code>sort(-*.value)</code> 根据散列值进行降序排列。</p>
</div>
<div class="listingblock">
<div class="title">descending sort based on the value of hash</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %hash = 'Perl'=&gt;80,
         'Python'=&gt;75,
           'Rust'=&gt;95,
            'Go'=&gt;100,
            "Php"=&gt;88,
           "Java"=&gt;85;

for %hash.sort(-*.value) -&gt; (:$key, :$value) {
    say $key, "\t", $value;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&#8594; () { }</code> 结构用于解构签名, 它实际上等价于：</p>
</div>
<div class="listingblock">
<div class="title">descending sort based on the value of hash</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for %hash.sort(-*.value) -&gt; (:key($key), :value($value)) {
    say $key, "\t", $value;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for %hash.sort(-*.value).kv -&gt; $key, $value {
    say $key, "\t", $value;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true对象排序"><a class="anchor" href="#true对象排序"></a>22.3. 对象排序</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># Sort an array of composite structures by a key. For example, if you define a composite structure that presents a name-value pair (in pseudocode):
# Define structure pair such that:
   # name as a string
   # value as a string


# and an array of such pairs:
# x: array of pairs


# then define a sort routine that sorts the array x by the key name.

# This task can always be accomplished with Sorting Using a Custom Comparator. If your language is not listed here, please see the other article.

# Works with: Rakudo Star version 2010.08

my class Employee {
   has Str $.name;
   has Rat $.wage;
}

my $boss     = Employee.new( name =&gt; "Frank Myers"     , wage =&gt; 6755.85 );
my $driver   = Employee.new( name =&gt; "Aaron Fast"      , wage =&gt; 2530.40 );
my $worker   = Employee.new( name =&gt; "John Dude"       , wage =&gt; 2200.00 );
my $salesman = Employee.new( name =&gt; "Frank Mileeater" , wage =&gt; 4590.12 );

my @team = $boss, $driver, $worker, $salesman;

my @orderedByName = @team.sort( *.name )».name;
my @orderedByWage = @team.sort( *.wage )».name;

say "Team ordered by name (ascending order):";
say @orderedByName.join('  ');
say "Team ordered by wage (ascending order):";
say @orderedByWage.join('  ');

# this produces the following output:
# Team ordered by name (ascending order):
# Aaron Fast   Frank Mileeater   Frank Myers   John Dude
# Team ordered by wage (ascending order):
# John Dude   Aaron Fast   Frank Mileeater   Frank Myers


# Note that when the sort receives a unary function, it automatically generates an appropriate comparison function based on the type of the data.

class Student {
    has Str $.name;
    has Int $.grade is rw;
}

my $stu1 = Student.new(name =&gt; "zhangwuji", grade =&gt; 124);
my $stu2 = Student.new(name =&gt; "yangguo",   grade =&gt; 128);
my $stu3 = Student.new(name =&gt; "zhaomin",   grade =&gt; 145);
my $stu4 = Student.new(name =&gt; "sunyizhe",  grade =&gt; 145);
my $stu5 = Student.new(name =&gt; "zhouziruo", grade =&gt; 128);
my $stu6 = Student.new(name =&gt; "qiaofeng",  grade =&gt; 124);

my @students = $stu1, $stu2,$stu3,$stu4,$stu5,$stu6;

# classify 返回一个散列
for @students.classify( *.grade ).sort -&gt; $group {
    say "These students got grade $group.key():";
    say .name for $group.value.list;
}

# sort
my @c = @students.sort: -&gt; $a, $b {$a.grade &lt;=&gt; $b.grade};
say @c.perl;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># 1 if $a is higher, -1 if $b is higher, 0 if equal
$a &lt;=&gt; $b;

# 根据分数排序 students
@students.sort: -&gt; $a, $b { $a.grade &lt;=&gt; $b.grade };

# same thing
@students.sort: { $^a.grade &lt;=&gt; $^b.grade };

# same thing
@students.sort: { .grade };

# same thing
@students.sort: *.grade;

# leg gives -1, 0 or 1 according to lexicographic ordering
# 'leg' is for Str, 'cmp' is now for type-agnostic sort
$a leg $b;

# sort students by name (Unicode order)
@students.sort: { $^a.name leg $^b.name };

# same thing
@students.sort: *.name;

# don't worry, things are properly cached; no re-evaluations
@items.sort: *.expensive-calculation();

# ...which means this works (and is a fair shuffle)
@deck.sort: { rand }

# ...but this is cuter :)
@deck.pick(*);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true列表排序"><a class="anchor" href="#true列表排序"></a>22.4. 列表排序</h3>
<div class="paragraph">
<p>给定一个列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">list = [ {'date': '2010-04-01','people': 1047, 'hits': 4522},
         {'date': '2010-04-03', 'people': 617, 'hits': 2582},
         {'date': '2010-04-02', 'people': 736, 'hits': 3277}
       ]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># 根据日期进行排序

# 降序
my @sorted_des = @list.sort: { $^b.split('/')[2] leg $^a.split('/')[2] }
say .key, "\n", .values for @sorted_des.classy(*.substr(7,7)).sort( { .key } )

# 如果对想对生成的散列再做一下加工（计算每个月有多少天）
# 就对生成的散列使用 map, 利用散列的键和值重新做一个映射
say .key, " ", ~.values for @sorted_des.classy(*.substr(7,7)).map( {   .key =&gt; .value.elems  } ).sort( { .key } )
say .key, " ", ~.values for @sorted_des.classy(*.substr(7,7)).map( { ; .key =&gt; .value.elems  } ).sort( { .key } )
say .key, " ", ~.values for @sorted_des.classy(*.substr(7,7)).map( {   .key =&gt; .value.elems; } ).sort( { .key } )


# 升序
# @list.sort: { .split('/')[2] };
# @list.sort: { $^a.split('/')[2] leg $^b.split('/')[2] }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $a = ('a' .. 'z').roll(10000000);
say .key, ' =&gt; ', .value for $a.cache.classify(*.Str).map({.key =&gt; .value.elems}).sort({-.value});
say now - INIT now;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有多列数据, 序号, 学校, 课程 … 年份这几列。要如果学校和课程相同就根据年份倒序排列。</p>
</div>
<div class="paragraph">
<p>先按学校排序, 再按课程排序, 然后按年份倒序排序。</p>
</div>
<div class="paragraph">
<p>我定义一个类来进行多列数据的排序, 很方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Course {
  has Int $.numb;
  has Str $.univ;
  has Str $.dis;
  has Int $.paper;
  has Int $.cited;
  has Int $.year;
}

my @headers = &lt;numb univ dis paper cited year&gt;;
my @courses;

for $=finish.lines -&gt; $line {
  next if $line ~~ /^num/;
  my @words  = $line.words;
  @words[0, 3,4,5] = @words[0,3,4,5]».Int;
  my %h =  @headers Z=&gt; @words;
  my $course = Course.new(|%h);
  @courses.push($course);
}

my @sorted  = @courses.sort(*.univ).sort(*.dis).sort(-*.year);
for @sorted  {
  say join " ", .numb, .univ, .dis, .paper, .cited, .year;
}

=finish
num univ    dis paper   cited   year
1   Beijing Physics 193 4555    2005
2   Beijing Physics 197 2799    2006
3   Beijing Physics 240 2664    2007
4   Beijing Physics 200 3191    2008
5   Beijing Physics 268 2668    2009
6   Beijing Physics 249 2300    2010
7   Beijing Physics 262 2080    2011
8   Beijing Physics 230 2371    2012
9   Beijing Physics 309 1367    2013
10  Beijing Physics 284 615 2014
11  Beijing Chemistry   143 1650    2005
12  Beijing Chemistry   149 2379    2006
13  Beijing Chemistry   190 2566    2007
14  Beijing Chemistry   147 1888    2008
15  Beijing Chemistry   184 2146    2009
16  Beijing Chemistry   214 2568    2010
17  Beijing Chemistry   238 2874    2011
18  Beijing Chemistry   265 2097    2012
19  Beijing Chemistry   251 1303    2013
20  Beijing Chemistry   241 656 2014</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">20 Beijing Chemistry 241 656 2014
10 Beijing Physics 284 615 2014
19 Beijing Chemistry 251 1303 2013
9 Beijing Physics 309 1367 2013
18 Beijing Chemistry 265 2097 2012
8 Beijing Physics 230 2371 2012
17 Beijing Chemistry 238 2874 2011
7 Beijing Physics 262 2080 2011
16 Beijing Chemistry 214 2568 2010
6 Beijing Physics 249 2300 2010
15 Beijing Chemistry 184 2146 2009
5 Beijing Physics 268 2668 2009
14 Beijing Chemistry 147 1888 2008
4 Beijing Physics 200 3191 2008
13 Beijing Chemistry 190 2566 2007
3 Beijing Physics 240 2664 2007
12 Beijing Chemistry 149 2379 2006
2 Beijing Physics 197 2799 2006
11 Beijing Chemistry 143 1650 2005
1 Beijing Physics 193 4555 2005</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true排序列表的列表"><a class="anchor" href="#true排序列表的列表"></a>22.5. 排序列表的列表</h3>
<div class="paragraph">
<p>我需要对数组的数组进行排序， <code>.sort</code> 方法能不能按照内层数组的不同索引来排序呢？</p>
</div>
<div class="paragraph">
<p>要排序的数组在一个更大的数组的外面：（birthday 是 'mmddyy' 格式的：）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @allRecords = [ [birthday1 firstName1 lastName1 [data1]
                   [birthday2 firstName2 lastName2 [data2]
                   ...
                   [birthdayN firstNameN lastNameN [dataN] ];

@allRecords.sort by itself sorts by birthdays.</code></pre>
</div>
</div>
<div class="paragraph">
<p>有什么好方法能按照 firstName 或 lastName 或按照内层数组里面的数据来排序呢？</p>
</div>
<div class="paragraph">
<p><code>sort</code> 方法接受一个link: <a href="https://docs.raku.org/routine/sort#(List)_routine_sort">可选的 sub 参数</a>。如果元数是 1， 那么它使用返回值作为比较操作数；如果元数为 2， 那么你可以在两个元素之间手动作比较，两个元素的比较会返回 <code>Less</code>, <code>Same</code>, <code>More</code>。</p>
</div>
<div class="paragraph">
<p>拿你上面的例子来说，我们可以像这样按照 first name 进行排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@allRecords.sort(*.[1])</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>*.[1]</code> 和 <code>*[1]</code> 没有任何区别, 只是前者更易读。</p>
</div>
<div class="paragraph">
<p>我们可以先按照 last name 再按照 first name 进行排序，然后按照 birthday 来做单独的比较，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@allRecords.sort(-&gt; $a,$b {
    $a[2] cmp $b[2] || $a[1] cmp $b[1] || $a[0] cmp $b[0]
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者再次通过转换操作数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@allRecords.sort(*.[2...0]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以按照 lastname，firstname， birthday 这样的顺序排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">@a.sort: *[2...0]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true签名-3"><a class="anchor" href="#true签名-3"></a>23. 签名</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://doc.raku.org/type/Signature">签名</a>也是对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; sub a($a, $b) {};
&gt; &amp;a.signature.perl.say
:($a, $b)
&gt; my $b = -&gt; $a, $b {};
&gt; $b.signature.perl.say
:($a, $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名是一个对象, 就像 Raku 中的任何其它东西一样。 任何 <strong>Callable</strong> 类型中都有签名, 并且它能使用 <code>.signature</code> 方法获取到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Signature { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名是代码对象参数列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。</p>
</div>
<div class="paragraph">
<p>传递参数给签名把包含在 <strong>Capture</strong> 中的参数绑定到了签名上。</p>
</div>
<div class="sect2">
<h3 id="true签名字面量"><a class="anchor" href="#true签名字面量"></a>23.1. 签名字面量</h3>
<div class="paragraph">
<p>签名出现在子例程和方法名后面的圆括号中, 还出现在 blocks 里面的 <code>&#8594;</code> 或 <code>&lt;&#8594;</code> 后面, 或者作为变量声明符(例如 <code>my</code> )的输入, 或者以冒号开头作为单独的项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f($x) { }
#    ^^^^ sub f 的签名

method x() { }
#       ^^ 方法 x 的签名

my $s = sub (*@a) { }
#           ^^^^^ 匿名函数的签名

for @list -&gt; $x { }
#            ^^    block 的签名

my ($a, @b) = 5, (6,7,8);
#  ^^^^^^^^ 变量声明符的签名

my $sig = :($a, $b);
#          ^^^^^^^^ 独立的签名对象</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名字面量可以用于定义回调或闭包的签名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(&amp;c:(Int)){}
sub will-work(Int){}
sub won't-work(Str){}
f(&amp;will-work);
f(&amp;won't-work); # fails at runtime
f(-&gt; Int { 'this works too' } );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true参数分隔符"><a class="anchor" href="#true参数分隔符"></a>23.2. 参数分隔符</h3>
<div class="paragraph">
<p>签名由逗号分割的零个或多个参数组成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($a, @b, %c)
sub add ($a, $b) { $a + $b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为一个例外, 签名中的第一个参数后面可以跟着一个冒号而非逗号来标记方法的调用者。调用者是用于调用方法的东西, 它通常通过在签名中指定它来绑定给 <strong>self</strong>, 你可以更改所绑定的变量的名字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($a: @b, %c)  # 第一个参数是调用者

class Foo {
    method whoami ($me:) {
        "Well I'm class $me.^name(), of course!"
    }
}

say Foo.whoami; # Well I'm class Foo, of course!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true类型约束"><a class="anchor" href="#true类型约束"></a>23.3. 类型约束</h3>
<div class="paragraph">
<p>参数可以可选地拥有一个类型约束(默认为 <code>Any</code>)。这些能用于限制函数允许的输入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:(Int $a, Str $b)
sub divisors (Int $n) { $_ if $n %% $_ for 1..$n }
divisors 2.5; # !!! Calling 'divisors' will never work with argument types (Rat)</code></pre>
</div>
</div>
<div class="paragraph">
<p>匿名的参数也行, 如果参数只需要它的类型约束的话。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($, @, %a)         # 两个匿名参数和一个 "正常的(有名字的)"参数
:(Int, Positional)  # 只有类型也行(两个参数)
sub baz (Str) {"Got a String"}
baz("hello");</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型约束也可以是类型捕获(<a href="http://doc.raku.org/type/Signature#Type_Captures">type captures</a>)。</p>
</div>
<div class="paragraph">
<p>除了这些名义上的类型之外, 额外的约束可以以代码块的形式加到参数上, 代码块必须返回一个真值以通过类型检测。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(Real $x where { $x &gt; 0 }, Real $y where { $y &gt;= $x }) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上, where 后面不需要是一个代码块, <code>where</code>-block 右侧的任何东西都会被用于和参数智能匹配。所以你也可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi factorial(Int $ where 0) { 1 }
multi factorial(Int $x) { $x * factorial($x - 1) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个还能简化为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi factorial(0) { 1 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以直接把字面量用作类型而值约束到匿名参数上。</p>
</div>
<div class="sect3">
<h4 id="true约束定义值和未定义值"><a class="anchor" href="#true约束定义值和未定义值"></a>23.3.1. 约束定义值和未定义值</h4>
<div class="paragraph">
<p>通常, 类型约束只检查传递的值是否是正确的<strong>类型</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub limit-lines (Str $s, Int $limit) {
    my @lines = $s.lines;
    @lines[0 ..^ min @lines.elems, $limit].join("\n")
}
say (limit-lines "a \n b \n c \n d \n", 3).perl; # "a \n b \n c "
say limit-lines Str,      3;  # Uh-oh. Dies with "Cannot call 'lines';"
say limit-lines "a \n b", Int # Always returns the max number of lines</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的情况, 我们其实只想处理定义了的字符串。要这样做, 我们使用 <code>:D</code> 类型约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub limit-lines (Str:D $s, Int $limit) {
    ...
}

say limit-lines Str, 3;
# Dies with "参数 '$s' 需要一个实例, 但是函数 limit-lines 中却传递了一个类型对象。</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果传递一个诸如 <strong>Str</strong> 这样的类型对象进去, 那么就会报错。这样的失败方式比以前更好了, 因为失败的原因更清晰了。</p>
</div>
<div class="paragraph">
<p>也有可能未定义的类型是子例程唯一有意义的接收值。这可以使用 <code>:U</code> 类型约束来约束它。例如, 我们可以把 <code>&amp;limit-lines</code> 转换成 multi 函数以使用 <code>:U</code> 约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi  limit-lines (Str $s, Int:D $limit) {
    my @lines = $s.lines;
    @lines[0 ..^ min @lines.elems, $limit].join("\n");
}

multi limit-lines (Str $s, Int:U $) {$s} # 如果传递给我一个未定义的类型对象, 就返回整个字符串

say limit-lines "a \n b \n c", Int;      # "a \n b \n c"</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了显式地标示常规的行为,  可以使用 <code>:_</code>,  但这不是必须的。 <code>:(Num:_ $)</code> 和 <code>Num $</code> 相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="true约束返回类型"><a class="anchor" href="#true约束返回类型"></a>23.3.2. 约束返回类型</h4>
<div class="paragraph">
<p><code>--&gt;</code> 标记后面跟着一个类型会强制在子例程执行成功时进行类型检测。返回类型箭头必须放在参数列表的后面。跟在签名声明后面的 <code>returns</code> 关键字有同样的功能。<code>Nil</code> 在类型检测中被认为是定义了的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo(--&gt; Int) { 1 };
sub foo() returns Int { 1 };        # 同上
sub does-not-work(--&gt; Int) { " " }; # throws X::TypeCheck::Return</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果类型约束是一个常量表达式, 那么它被用于子例程的<strong>返回值</strong>。那个子例程中的任何<strong>return</strong>语句必须是不含参数的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo(--&gt; 123) { return }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Nil</code> 和 <code>Failure</code> 总是被允许作为返回<strong>类型</strong>, 不管类型约束是什么。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub foo(--&gt; Int) { Nil };
say foo.perl; # Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>不支持类型捕获和强制类型。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true吞噬参数或长度可变参数"><a class="anchor" href="#true吞噬参数或长度可变参数"></a>23.4. 吞噬参数(或长度可变参数)</h3>
<div class="paragraph">
<p>数组或散列参数可以通过前置一个星号(s)被标记为吞噬参数, 这意味着它可以被绑定给任意数量的参数(0 个或 多个)。</p>
</div>
<div class="paragraph">
<p>它们被叫做吞噬参数, 因为它们吞完函数中的任何剩余参数, 就像有些人吞吃面条那样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($a, @b)  # 正好两个参数, 而第二个参数必须是 Positional 的
:($a, *@b) # 至少一个参数, @b 吞噬完任何剩余的参数
:(*%h)     # 没有位置参数, 除了任意数量的具名参数</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub one-arg (@)  { };
sub slury   (*@) { };

one-arg(5, 6, 7);  # !!! 参数个数太多
one-arg (5, 6, 7); # ok, 和 one-arg((5,6,7))相同, 传递的是一个数组

slurp (5, 6, 7);   # ok
one-arg 5, 6, 7;   # 调用 one-arg(Int, Int, Int) 绝对不会工作, 使用声明的签名 (@), 参数个数太多
slurp 5, 6, 7;     # ok

one-arg (5);       # Calling one-arg(Int) will never work with declared signature (@)
one-arg (5,);      # ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>one-arg 函数需要的参数是<strong>一个</strong>列表(或数组), 而不是多个参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; (5).WHAT.say
(Int)
&gt; (5,).WHAT.say
(List)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub named-names (*%named-args) { %named-args.keys };
say named-names :foo(42) :bar&lt;hahaha&gt;  # =&gt; foo bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意位置参数不允许出现在吞噬参数的后面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:(*@args, $last) # !!! 不能把必要参数放在可变长度参数的后面</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有一个星号的吞噬参数会通过消融一层或多层裸的可迭代对象来展平参数。 带有两个星号的吞噬参数不会展平参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub a (*@a)  { @a.join("|").say };
sub b (**@b) { @b.join("|").say };

a(1,[1,2],([3,4],5));    #  1|1|2|3|4|5
b(1,[1,2],([3,4],5));    # 1|1 2|3 4 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常, 吞噬参数会创建一个数组, 为每个 argument 创建一个标量容器, 并且把每个参数的值赋值给那些标量。如果在该过程中原参数也有一个中间的标量分量, 那么它在调用函数中是访问不到的。</p>
</div>
<div class="paragraph">
<p>吞噬参数在和某些 <a href="http://doc.raku.org/type/Signature#Parameter_Traits_and_Modifiers">traits and modifiers</a> 组合使用时会有特殊行为, 像下面描述的那样。</p>
</div>
</div>
<div class="sect2">
<h3 id="true类型捕获"><a class="anchor" href="#true类型捕获"></a>23.5. 类型捕获</h3>
<div class="paragraph">
<p>类型捕获允许把类型约束的说明推迟到函数被调用时。它们允许签名和函数体中的类型都可以引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(::T $p1, T $p2, ::C) {
    # $p1 和 $p2 的类型都为 T, 但是我们还不知道具体类型是什么
    # C 将会保存一个源于类型对象或值的类型
    my C $closure = $p1 / $p2;
    return sub (T $p1) {
        $closure * $p1;
    }
}

# 第一个参数是 Int 类型, 所以第二个参数也是
# 我们从调用用于 &amp;f 中的操作符导出第三个类型
my &amp;s = f(10,2, Int.new / Int.new);
say s(2);  # 10 / 2 * 2  == 10</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true位置参数-vs-命名参数"><a class="anchor" href="#true位置参数-vs-命名参数"></a>23.6. 位置参数 vs. 命名参数</h3>
<div class="paragraph">
<p>参数可以是跟位置有关的或者是具名的。所有的参数都是 positional 的, 除了吞噬型散列参数和有前置冒号标记的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($a)   # 位置参数
:(:$a)  # 名字为 a 的具名参数
:(*@a)  # 吞噬型位置参数
:(*%h)  # 吞噬型具名参数</code></pre>
</div>
</div>
<div class="paragraph">
<p>在调用者这边, 位置参数的传递顺序和它们声明顺序相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub pos($x, $y) { "x = $x y = $y" };
pos(4, 5); #  x = 4 y = 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于具名实参和具名形参, 只用名字用于将实参映射到形参上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub named(:$x, :$y) { "x=$x y=$y" }
named( y =&gt; 5, x =&gt; 4);</code></pre>
</div>
</div>
<div class="paragraph">
<p>具名参数也可以和变量的名字不同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub named(:official($private)) { "公务" if $private }
named :official;</code></pre>
</div>
</div>
<div class="paragraph">
<p>别名也是那样做的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub paint( :color(:colour($c)) ) { } # 'color' 和 'colour' 都可以
sub paint( :color(:$colour) )    { } # same API for the caller</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有具名参数的函数可以被动态地调用, 使用 <code>|</code> 非关联化一个 Pair 来把它转换为一个具名参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi f(:$named) { note &amp;?ROUTINE.signature };
multi f(:$also-named) { note &amp;?ROUTINE.signature };

for 'named', 'also-named' -&gt; $n {
    f(|($n =&gt; rand))      # «(:$named)␤(:$also-named)␤»
}

my $pair = :named(1);
f |$pair; # «(:$named)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的语法也可以用于将散列转换为具名参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my %pairs = also-named =&gt; 4;
f |%pairs;        # (:$also-named)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true可选参数和强制参数"><a class="anchor" href="#true可选参数和强制参数"></a>23.7. 可选参数和强制参数</h3>
<div class="paragraph">
<p>Positional 参数默认是强制的,  也可以用默认值或结尾的问号使参数成为可选的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:(Str $id)         # 必要参数 required parameter
:($base = 10)      # 可选参数, 默认为 10
:(Int $x?)         # 可选参数, 默认为 Int 类型的对象</code></pre>
</div>
</div>
<div class="paragraph">
<p>具名参数默认是可选的, 可以通过在参数末尾加上一个感叹号使它变成强制参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:(:%config)        # 可选参数
:(:$debug = False) # 可选参数, 默认为 False
:(:$name!)         # 名为 name 的强制具名参数</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认值可以依靠之前的参数, 并且每次调用都会被重新计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($goal, $accuracy = $goal / 100);
:(:$excludes = ['.', '..']); # a new Array for every call</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true解构参数"><a class="anchor" href="#true解构参数"></a>23.8. 解构参数</h3>
<div class="paragraph">
<p>参数后面可以跟着一个由括号括起来的 <code>sub-signature</code>, 子签名会解构给定的参数。解构的列表就是它的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub first (@array ($first, *@rest)) { $first }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub first ([$first, *@]) { $first }</code></pre>
</div>
</div>
<div class="paragraph">
<p>而散列的解构是它的键值对儿:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub all-dimensions (% (:length(:$x), :width(:$y), :depth(:$z))) {
    sx andthen $y andthen $z andthen True
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>andthen</code> 返回第一个未定义的值, 否则返回最后一个元素。短路操作符。<code>andthen</code> 左侧的结果被绑定给 <code>$_</code> 用于右侧, 或者作为参数传递, 如果右侧是一个 <code>block</code> 或 <code>pointy block</code> 的话。</p>
</div>
<div class="paragraph">
<p>一般地, 对象根据它的属性结构。通用的惯用法是在 <strong>for</strong> 循环中解包一个 `Pair`的键和值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">for @guest-list.pairs -&gt; (:key($index), :value($guest)) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 这种把对象解包为它们的属性只是默认行为。为了让对象按照不同的方解构, 改变它们的 <code>Capture</code> 方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="true捕获参数"><a class="anchor" href="#true捕获参数"></a>23.9. 捕获参数</h3>
<div class="paragraph">
<p>在参数前前置一个垂直的 <code>|</code> 会让参数变为 <code>Capture</code>, 并使用完所有剩下的位置参数和具名参数。</p>
</div>
<div class="paragraph">
<p>这常用在 <code>proto</code> 定义中( 像 <code>proto foo (|) {*}</code> ) 来标示子例程的 <code>multi</code> 定义可以拥有任何类型约束。</p>
</div>
</div>
<div class="sect2">
<h3 id="true参数特性和修饰符"><a class="anchor" href="#true参数特性和修饰符"></a>23.10. 参数特性和修饰符</h3>
<div class="paragraph">
<p>默认地, 形式参数被绑定到它们的实参上并且被标记为只读。你可以使用 traits 特性更改参数的只读特性。</p>
</div>
<div class="paragraph">
<p><code>is copy</code> 特性让参数被复制, 并允许在子例程内部修改参数的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub count-up ($x is copy) {
    $x = Inf if $x ~~ Whatever;
    .say for 1..$x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>is rw</code> 特性让参数只绑定到变量上(或其它可写的容器)。 赋值给参数会改变调用一侧的变量的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub swap($x is rw, $y is rw) {
    ($x, $y) = ($y, $x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于吞噬参数, <code>is rw</code> 由语言设计者保留做将来之用</p>
</div>
</div>
<div class="sect2">
<h3 id="true签名方法"><a class="anchor" href="#true签名方法"></a>23.11. 签名方法</h3>
<div class="sect3">
<h4 id="trueparams-方法"><a class="anchor" href="#trueparams-方法"></a>23.11.1. params 方法</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">method params(Signature:D:) returns Positional</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回 `Parameter`对象列表以组成签名。</p>
</div>
</div>
<div class="sect3">
<h4 id="truearity-方法"><a class="anchor" href="#truearity-方法"></a>23.11.2. arity 方法</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">method arity(Signature:D:) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回所必须的最小数量的满足签名的位置参数</p>
</div>
</div>
<div class="sect3">
<h4 id="truecount-方法"><a class="anchor" href="#truecount-方法"></a>23.11.3. count 方法</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">method count(Signature:D:) returns Real:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回能被绑定给签名的最大数量的位置参数。如果有吞噬位置参数则返回 <code>Inf</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="truereturns-方法"><a class="anchor" href="#truereturns-方法"></a>23.11.4. returns 方法</h4>
<div class="paragraph">
<p>签名返回的任意约束是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($a, $b --&gt; Int).returns # Int</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueaccepts-方法"><a class="anchor" href="#trueaccepts-方法"></a>23.11.5. ACCEPTS 方法</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">multi method ACCEPTS(Signature:D: Capture $topic)
multi method ACCEPTS(Signature:D: @topic)
multi method ACCEPTS(Signature:D: %topic)
multi method ACCEPTS(Signature:D: Signature $topic)</code></pre>
</div>
</div>
<div class="paragraph">
<p>前三个方法会看参能否绑定给 capture, 例如, 如果带有那个 Signature 的函数能使用 <code>$topic</code> 调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(1,2, :foo) ~~ :($a, $b, :foo($bar)) # true
&lt;a b c d&gt; ~~ :(Int $a)               # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个会为真如果 <code>$topic</code> 能接收的任何东西也能被 <code>Signature</code> 接收。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">:($a, $b) ~~ :($foo, $bar, $baz?)   # True
:(Int $n) ~~ :(Str)                 # False</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true命令行工具"><a class="anchor" href="#true命令行工具"></a>24. 命令行工具</h2>
<div class="sectionbody">
<div class="paragraph">
<p>maybe will coming soon at 2021</p>
</div>
<div class="sect2">
<h3 id="truemain"><a class="anchor" href="#truemain"></a>24.1. MAIN</h3>

</div>
<div class="sect2">
<h3 id="truezef"><a class="anchor" href="#truezef"></a>24.2. zef</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="truesubset"><a class="anchor" href="#truesubset"></a>25. Subset</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>限制字符串长度</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">   subset NonEmptyString
       of Str
       where *.chars &gt; 0; # 可以把约束条件写到多行

   sub firstName(NonEmptyString $name) {
       say "your name is $name";
   }

   firstName('Larry');
   firstName('');</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">your name is Larry
Constraint type check failed for parameter '$name'
  in sub firstName at subset.p6:5
  in block &lt;unit&gt; at subset.p6:10</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>限制值域</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">subset PointLimit of Int where -10 &lt;= * &lt;= 10;
sub test(PointLimit $number) {
    say $number;
}
test(-5); # -5

subset SmallInt of Int where -10 .. 10;
sub small(SmallInt $number) {
    say $number;
}
small(8);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>检测密码是否合法</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># 安全的密码
# 至少 8 位
# 包含大写字母、小写字母
# subset 不能使用 set(*.comb)  形式？

subset Password
    of Str
    where *.chars &gt;=8 &amp;&amp;
        any('A'..'Z','a'..'z') ∈ *.comb.Set;

sub passwordCheck(Password $password) {
    say "Password is Valid";
}

passwordCheck("abcdABCD");</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>检测密码是否有效并提醒</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">subset Length8    of Str where *.chars &lt; 8;
subset UpCase     of Str where none('A'..'Z') ∈ *.comb.Set;
subset LowerCase  of Str where none('a'..'z') ∈ *.comb.Set;
subset IntNumber  of Str where none('0'..'9') ∈ *.comb.Set;

my $guess = prompt('Enter your password:');

given $guess {
    when Length8   { say '密码长度必须为 8 位 以上'; proceed }
    when  UpCase   { say '密码必须包括大写字母';     proceed }
    when LowerCase { say '密码必须包含小写字母';     proceed }
    when IntNumber { say '密码必须包含数字';                 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/when 里面增加一个处理。
proceed 相当于 continue， 不像 C 里面的 falling through， Raku 里面的 proceed 在继续执行 when 语句时会计算 when 后面的条件。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>检测年龄</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Person {
    has Int $.age;
    has Str $.name;
}

subset Child  of Person where *.age &lt; 18;
subset Adult  of Person where -&gt; $person { 18 &lt;= $person.age &lt; 60 };
subset Senior of Person where *.age &gt;= 60;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true最佳特性"><a class="anchor" href="#true最佳特性"></a>26. 最佳特性</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truewhatever-star-3"><a class="anchor" href="#truewhatever-star-3"></a>26.1. Whatever Star</h3>
<div class="paragraph">
<p>Whatever star 的名字来自于通配符。在 Raku 中，Whatever  star 会创建一个隐式块，可以用来代替任何需要 <code>Callable</code> 的东西。这个过程被称为 <strong>whatever</strong>-柯里化。以下是文档：<a href="https://docs.raku.org/type/WhateverCode">WhateverCode</a>。</p>
</div>
<div class="paragraph">
<p>由于各种原因，这很有用。这是一个我觉得相对简洁的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1,1,*+* ...^ * &gt;= 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不会深入研究这个，但是这是一个表示每个斐波纳契数小于100的列表。<code>&#8230;&#8203;^</code> 是序列运算符，它的左侧列表以生成器函数和结束条件结束在右侧。一旦生成器函数smart生成的数字与结束条件匹配，列表就完成了。您还可以传递 <code>&#8230;&#8203;^</code> 右侧的任何星形来创建无限的懒惰列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="true隐式链接"><a class="anchor" href="#true隐式链接"></a>26.2. 隐式链接</h3>
<div class="paragraph">
<p>Raku 中有一个名为 <code>$_</code> 的特殊变量。它具有类型（<code>Any</code>），并且基本上具有当下有意义的任何值。在 for 循环中，它成为循环参数，在代码块中，它成为隐式参数。它可以使用给定的构造显式设置（稍后会详细介绍）。 Raku 语法的一个特殊功能就是。如果没有传入左操作数，operator implicity 会调用 <code>$_</code> 上的函数。除了隐式返回语句之外，这还鼓励了一种相当优雅的方法链接形式 - 类似于 Ruby 的 <a href="https://ruby-doc.org/core-2.6.2/Object.html#method-i-tap">tap</a> 或 <a href="https://wiki.haskell.org/Pointfree">pointfree 样式的 Haskell</a>。</p>
</div>
<div class="paragraph">
<p>这是一个人为的例子：给定一个列表列表，将列表过滤到只有偶数元素并打印新列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; (1..2 X 1..2).map: { .grep(* %% 2).say }
()
(2)
(2)
(2 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{ .grep(* %% 2).say }</code> 是一个接收隐式参数(作为 <code>$_</code> 传入)的 block, 过滤掉不能被 2 整除的元素.我们可以使用此块作为独立的 callable 用来查看此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; { .grep(* %% 2).say }(1..10)
(2 4 6 8 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我看来，这种隐式链接的想法开启了编写优雅，面向过程的代码的机会。</p>
</div>
</div>
<div class="sect2">
<h3 id="true可重新定义的运算符"><a class="anchor" href="#true可重新定义的运算符"></a>26.3. 可重新定义的运算符</h3>
<div class="paragraph">
<p>n 的阶乘定义为 <code>n*(n-1)*(n-2)…*1</code>, 零的阶乘为1.</p>
</div>
<div class="paragraph">
<p>定义一个函数返回一个数字的阶乘。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用自定义后缀操作符</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub postfix:&lt;!&gt;($n where $n &gt; 0) {
    [*] 2..$n
}
say 5!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true元方法"><a class="anchor" href="#true元方法"></a>26.4. 元方法</h3>
<div class="sect3">
<h4 id="truewho-what-where-which-why-和-how"><a class="anchor" href="#truewho-what-where-which-why-和-how"></a>26.4.1. WHO, WHAT, WHERE, WHICH, WHY 和 HOW</h4>
<div class="paragraph">
<p>我喜欢 Raku 如何命名。它很可爱又愚蠢，令人难忘，描述性绝不让我感到困惑。</p>
</div>
<div class="paragraph">
<p><code>WHO</code>，<code>WHAT</code>，<code>WHERE</code>，<code>WHICH</code>，<code>WHY</code> 和 <code>HOW</code> 是默认情况下在每个对象上定义的方法。它们促进了 Raku 中可能存在的大部分反射和动态。它们都是 <a href="https://docs.raku.org/language/mop#Metamethods">MOP</a>的一部分，即 Raku 的元对象协议。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WHO</code> 返回定义该对象的包。</p>
</li>
<li>
<p><code>WHAT</code> 返回对象的类型。</p>
</li>
<li>
<p><code>WHERE</code> 返回对象的地址。</p>
</li>
<li>
<p><code>WHICH</code> 返回对象的唯一标识符。</p>
</li>
<li>
<p><code>WHY</code> 返回有关该对象的文档。</p>
</li>
<li>
<p><code>HOW</code> 很重要要：它返回元类对象，开发人员狡猾地命名其为高阶工作对象。它为 Raku 允许的所有运行时动态提供了一个接口。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在对象的 <code>HOW</code> 对象上调用方法有特殊的语法，这个语法是 <code>.^</code>。</p>
</div>
<div class="paragraph">
<p>以下是一些有趣的事情，你可以用 <code>HOW</code> 对象来做。使用 <code>my $x = "Hello, world!"</code> 我们可以自省它来找到它的名字，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; $x.^name
Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>找到你可以在它身上调用的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; $x.^methods
(BUILD Capture Int Num chomp starts-with ends-with substr-eq contains indices index rindex pred succ comb match subst-mutate subst lines parse-base samecase samemark samespace word-by-word trim-leading trim-trailing trim words WORDS_AUTODEREF encode NFC NFD NFKC NFKD unival univals wordcase trans parse-names uniparse indent codes chars uc lc tc fc tclc flip ord WHY WHICH Bool Str Stringy DUMP ACCEPTS chop Numeric gist perl ords split substr substr-rw BUILDALL)</code></pre>
</div>
</div>
<div class="paragraph">
<p>和它的方法解析顺序(遍历哪些类来调用此对象上的方法)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; $x.^mro
((Str) (Cool) (Any) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及更多。你甚至可以内省一个 <code>HOW</code> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">&gt; $x.HOW.^methods
(archetypes new new_type add_fallback compose roles role_typecheck_list is_composed setup_junction_fallback find_method_fallback has_fallbacks set_name set_shortname name shortname WHY set_why ver auth api set_ver set_auth set_api add_stash add_attribute compose_attributes set_rw rw get_attribute_for_usage attributes add_method methods method_table submethod_table declares_method lookup cache cache_get cache_add add_private_method private_method_table find_private_method set_autogen_proto add_multi_method multi_methods_to_incorporate incorporate_multi_candidates add_meta_method meta_method_table compose_meta_methods add_role roles_to_compose exclude_parent add_parent parents hides hidden set_hidden set_default_parent_type has_default_parent_type get_default_parent_type compute_mro c3_merge mro mro_unhidden find_method find_method_qualified can publish_method_cache isa does type_check publish_type_cache add_trustee trusts is_trusted create_BUILDPLAN BUILDPLAN BUILDALLPLAN set_is_mixin is_mixin set_mixin_attribute mixin_attribute flush_cache setup_mixin_cache mixin generate_mixin mixin_base is_array_type array_type set_array_type get_boolification_mode set_boolification_mode publish_boolification_spec compose_repr repr_composed set_default_invoke_handler set_invocation_attr set_invocation_handler has_invocation_attr invocation_attr_class ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过将所有这些元方法封装到一个对象中，Raku 在您应该使用的方法和可以使用的方法之间进行了明显的描述。有能力做你想做的事是一件好事 - 但应谨慎使用。其他语言（看着你，Ruby）没有做出这种区分，因此经常将这些不安全的函数暴露为每个对象的一阶方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truetraits-2"><a class="anchor" href="#truetraits-2"></a>26.5. traits</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">class Okay {
	has $.value is required;
}

class UhOh is rw is Okay { }

sub nasty_function($klass) {
	$klass.value = 0;
}

my $okay = Okay.new: value =&gt; 10;
my $uhoh = UhOh.new: value =&gt; 10;

nasty_function($okay); # This doesn't work!
# Cannot modify an immutable Int (10)
#  in sub nasty_function at test.p6 line 8
#  in block &lt;unit&gt; at test.p6 line 14
nasty_function($uhoh); # After this, $uhoh.value now equals 0.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true智能匹配"><a class="anchor" href="#true智能匹配"></a>26.6. 智能匹配</h3>
<div class="paragraph">
<p>这是本质上是 Perl5 的一个功能，我无法想象它是用另一种语言实现的。 Smartmatch 是“这就是你期望它做的事”的体现。</p>
</div>
<div class="paragraph">
<p>它是一个运算符 <code>~~</code>，它在右手边的参数上调用 <code>.ACCEPTS</code>，并在其左手边的参数上别名 <code>$_</code>。每个对象以某种方式，形状或形式实现 <code>.ACCEPTS</code>;它的唯一目的是做它应该做的事情。</p>
</div>
<div class="paragraph">
<p>听起来很模糊？确实是的。在 Raku 中，Smartmatch 以两种重要的方式使用：<code>given&#8230;&#8203;when</code>，和匹配类型签名。</p>
</div>
</div>
<div class="sect2">
<h3 id="truegivenwhen"><a class="anchor" href="#truegivenwhen"></a>26.7. given/when</h3>
<div class="paragraph">
<p>这是 Raku 的 case 语句形式，但称之为 case 语句并不公平。以下是如何使用它的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given $str {
	when /hello/ { say 'user typed in "hello"' }
	when /world/ { say 'user typed in "world"' }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>$str ~~ / hello /</code> 返回 True，则此块运行第一个块，如果 <code>$str ~~ / world /</code> 返回 True，则第二个块运行。在这种非常具体的情况下，这类似于 switch/case 块，但是匹配正则表达式。我们不仅限于正则表达式，我们可以混合搭配 smartmatch 接受的任何类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">given $str {
	when 10 { say 'user typed in the number 10' }
	when /hello/ { say 'user typed in "hello"' }
	when /world/ { say 'user typed in "world"' }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，我们首先匹配 <code>$str ~~ 10</code> 以查看是否将运行新的第一个块。将字符串与数字进行智能匹配定义为仅在字符串强制转换为数字时返回 True，以便仅当 <code>$str</code> 为“10”时才运行该块。</p>
</div>
<div class="paragraph">
<p>可以想象，这是一个非常强大且可扩展的运算符。还有很多事情在这里发生，我甚至都没有涉及：智能匹配布尔，匹配 callables 等。</p>
</div>
</div>
<div class="sect2">
<h3 id="true类型签名"><a class="anchor" href="#true类型签名"></a>26.8. 类型签名</h3>
<div class="paragraph">
<p>在 Raku 中，类型签名的处理方式与任何其他对象相同。可以使用 <code>.signature</code> 检查函数的类型签名，并且可以使用 <code>Capture</code> 对象上的 smartmatch 运算符 <code>~~</code> 执行运行时类型签名匹配。</p>
</div>
<div class="paragraph">
<p>看看这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">sub f(Int $x --&gt; Int) {
	$x + 1
}

say &amp;f.signature;                    # =&gt; (Int $x --&gt; Int)
say \(10.WHAT) ~~ &amp;f.signature;      # =&gt; True
say \('hello'.WHAT) ~~ &amp;f.signature; # =&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true元运算符"><a class="anchor" href="#true元运算符"></a>26.9. 元运算符</h3>
<div class="paragraph">
<p>元运算符是能操作运算符的运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">qw/fun handy scalable/ Z~ qw/♥ ♥ ♥/</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">(fun♥ handy♥ scalable♥)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">qw/fun handy scalable/ X~ qw/ly able/</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">(funly funable handyly handyable scalablely scalableable)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[+] qw/1 2 3/
[*] qw/1 2 3 4 5/
[~] qw/1 2 3 4 5/
[\+] qw/1 2 3/</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">6
120
12345
(1 3 6)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true空白格"><a class="anchor" href="#true空白格"></a>27. 空白格</h2>
<div class="sectionbody">
<div class="paragraph">
<p>空白要么是一个字符, 要么是一组空白字符，用于分隔单词。一个例子是空格字符 <code>« »</code>。</p>
</div>
<div class="sect2">
<h3 id="true关键字"><a class="anchor" href="#true关键字"></a>27.1. 关键字</h3>
<div class="paragraph">
<p>关键字后面必须有空白。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 关键字后面必须要有空白, 否则会被当成是方法调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">while ($x &lt; 5) { ... }
if $x &lt; 5 { ... }
my ($x, $y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>而大部分括号都可以省略</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">while $x &lt; 5 { ... }
if $x &lt; 5 { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true中缀运算符"><a class="anchor" href="#true中缀运算符"></a>27.2. 中缀运算符</h3>
<div class="paragraph">
<p>中缀运算符前面必须有空白。</p>
</div>
<div class="paragraph">
<p>中缀运算符, 例如 <code>&lt;</code>, 如果你想使用该运算符比较数值大小, 但是忘了在该中缀运算符前面加上空白, 那么编译器就会告诉你, <strong>Whitespace required before &lt; operator</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">3&lt;1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">===SORRY!=== Error while compiling:
Whitespace required before &lt; operator
at line 2
------&gt; &lt;BOL&gt;⏏&lt;EOL&gt;
    expecting any of:
        postfix</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true链式调用"><a class="anchor" href="#true链式调用"></a>27.3. 链式调用</h3>
<div class="paragraph">
<p>链式调用允许有空白。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @books = $xml
  .parse-file($file)           # some comment
  .findnodes("/library/book");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true名词和后缀运算符"><a class="anchor" href="#true名词和后缀运算符"></a>27.4. 名词和后缀运算符</h3>
<div class="paragraph">
<p>名词和后缀运算符之间不能有空白。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">%hash  {$key}  # WRONG
@array [$ix]   # WRONG
$subref ($arg) # WRONG</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true"><a class="anchor" href="#true"></a>27.5. [+]</h3>
<div class="paragraph">
<p>[+] 里面的中缀运算符前后都不允许有空白。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[+] 1,2,3 # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果改成 <code>[ +]</code> 或 <code>[ + ]</code> 或 <code>[ + ]</code> 都不行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">===SORRY!=== Error while compiling:
Prefix +  requires an argument, but no valid term found</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueunspace"><a class="anchor" href="#trueunspace"></a>27.6. unspace</h3>
<div class="paragraph">
<p>通过在空白处放置一个 <code>/</code>, 任何连续的空白(包括注释)都会在解释器面前隐身, 这就是所谓的空白隐身(unspace)。</p>
</div>
<div class="paragraph">
<p>使用 <code>unspace</code> 可以把后缀运算符贴线对齐:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">%hash\  {$key}
@array\ [$ix]
$subref\($arg)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的最后一种形式是一种退化了的 <code>unspace</code>, 即反斜线后面直接跟着后缀。注意, 反斜线前面不允许有空白, 所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$subref \($arg)</code></pre>
</div>
</div>
<div class="paragraph">
<p>是语法错误(two terms in a row)。其它后缀运算符也可以使用 <code>unspace</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">$number\  ++;
$number\  --;
1+3\      i;
$object\  .say();
$object\#`{ your ad here }.say</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unspace</code> 只是让空白在解释器面前隐身了, 但是它并不能使空白在词法分析程序面前隐身, 因为 <code>token</code> 中禁用了 <code>unspace</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="true正则中的空白"><a class="anchor" href="#true正则中的空白"></a>27.7. 正则中的空白</h3>
<div class="paragraph">
<p>我们知道, 在 Raku 里面, 正则表达式有 <strong>regex</strong>, <strong>token</strong> 和 <strong>rule</strong> 三种声明方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my regex named-regex { ... }
my token named-regex { ... }
my rule  named-regex { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>而 <code>token</code> 和 <code>rule</code> 是 <code>regex</code> 的变体。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">声明</th>
<th class="tableblock halign-left valign-top">空白</th>
<th class="tableblock halign-left valign-top">回溯</th>
<th class="tableblock halign-left valign-top">等价写法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">token</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ratchet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex :ratchet { &#8230;&#8203; }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rule</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:sigspace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ratchet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex :ratchet :sigspace { &#8230;&#8203; }</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>regex</code> 和 <code>token</code> 默认忽略空白, <code>rule</code> 默认不忽略空白。<code>:sigspace</code> 表示空白是有意义的, <code>:ratchet</code> 表示不回溯。因此, 要在 <code>regex</code> 或 <code>token</code> 中里面匹配空白, 你需要显式的写上 <code>\s</code>、<code>\h</code>、<code>\n</code> 等空白字符。</p>
</div>
</div>
<div class="sect2">
<h3 id="true原子与空白"><a class="anchor" href="#true原子与空白"></a>27.8. 原子与空白</h3>
<div class="paragraph">
<p>在 <code>rule</code> 中, 任何跟在原子(atom)后面的空白都会变成非捕获的 <code>&lt;ws&gt;</code> 调用, 即 <code>&lt;.ws&gt;</code>。因此,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">rule entry { &lt;key&gt; '=' 'value' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">token entry { &lt;key&gt; &lt;.ws&gt; '=' &lt;.ws&gt; &lt;value&gt; &lt;.ws&gt; } # 点号抑制了捕获</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truesigspace-修饰符"><a class="anchor" href="#truesigspace-修饰符"></a>27.9. :sigspace 修饰符</h3>
<div class="paragraph">
<p>在正则表达式中, <strong>:s</strong> 是 <strong>:sigspace</strong> 的简写, 该修饰符使普通 regex 中的空白变得有意义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $ingredients = 'eggs milk sugar ';
$ingredients ~~ m/:s eggs milk sugar /;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true字符类中的空白"><a class="anchor" href="#true字符类中的空白"></a>27.10. 字符类中的空白</h3>
<div class="paragraph">
<p>在字符类中, 空白字面量会被忽略:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ &lt;[ a .. z _ ]&gt;* /
/ &lt;[ . _ ]&gt;* /
/ &lt;[a..z] - [aeiou] + xdigit&gt; /  # 辅音或十六进制数</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-</code> 后面允许有空白:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">/ &lt;-[a..z_]&gt; &lt;-alpha&gt; /
/ &lt;- [a..z_]&gt; &lt;- alpha&gt; /</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truegrammar-中的空白"><a class="anchor" href="#truegrammar-中的空白"></a>27.11. grammar 中的空白</h3>
<div class="sect3">
<h4 id="true-忽略其左右两侧的空白"><a class="anchor" href="#true-忽略其左右两侧的空白"></a>27.11.1. <code>|</code> 忽略其左右两侧的空白</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">grammar Token::Rule::Difference {
    # 下面三者等价
    # rule TOP { [\w+]+ % ' ' | [\d+]+ % ' '   }
    # rule TOP { | [\w+]+ % ' ' | [\d+]+ % ' ' }
    rule TOP { | [\w+]+ % ' '
               | [\d+]+ % ' '
             }
}

# $=finish.lines 中的每一行末尾都没有换行符
for $=finish.lines -&gt; $line {
    print($line);
    say Token::Rule::Difference.parse($line)
}

=finish
token takes whitespace invisible unless with sigspace
rule is a token without sigspace
2015 12 25
2016 01 07</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">token takes whitespace invisible unless with sigspace｢token takes whitespace invisible unless with sigspace｣
rule is a token without sigspace｢rule is a token without sigspace｣
2015 12 25｢2015 12 25｣
2016 01 07｢2016 01 07｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>说明在 rule 中, <code>|</code> 左右两边的空格会被忽略, 这通常是为了使格式对齐, 看起来不乱。另外在 rule 中, 开头和末尾的空白也会被忽略。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true欧拉项目"><a class="anchor" href="#true欧拉项目"></a>28. <a href="https://projecteuler.net">欧拉项目</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>maybe will coming soon at 2021</p>
</div>
<div class="sect2">
<h3 id="true3-和-5-的倍数"><a class="anchor" href="#true3-和-5-的倍数"></a>28.1. 3 和 5 的倍数</h3>
<div class="paragraph">
<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
</div>
<div class="paragraph">
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[+] (gather .take if $_ % 3 == 0 || $_ % 5 == 0 for 1..^1000)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true偶数斐波那契数"><a class="anchor" href="#true偶数斐波那契数"></a>28.2. 偶数斐波那契数</h3>
<div class="paragraph">
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
</div>
<div class="paragraph">
<p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">[+] gather .take if $_ % 2 == 0 for 1,2,{$^a + $^b} ... * &gt; 40_000_000</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueeuler003"><a class="anchor" href="#trueeuler003"></a>28.3. Euler003</h3>

</div>
<div class="sect2">
<h3 id="trueeuler004"><a class="anchor" href="#trueeuler004"></a>28.4. Euler004</h3>

</div>
<div class="sect2">
<h3 id="trueeuler005"><a class="anchor" href="#trueeuler005"></a>28.5. Euler005</h3>

</div>
<div class="sect2">
<h3 id="trueeuler006"><a class="anchor" href="#trueeuler006"></a>28.6. Euler006</h3>

</div>
<div class="sect2">
<h3 id="trueeuler007"><a class="anchor" href="#trueeuler007"></a>28.7. Euler007</h3>

</div>
<div class="sect2">
<h3 id="trueeuler008"><a class="anchor" href="#trueeuler008"></a>28.8. Euler008</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="true运算符"><a class="anchor" href="#true运算符"></a>29. 运算符</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truezip"><a class="anchor" href="#truezip"></a>29.1. zip</h3>
<div class="paragraph">
<p>输出下面的文本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># OUTPUT
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @questions = ('name', ' quest',  'favorite color');
my @answers = ("lancelot", "the holy grail", "blue");
for zip(@questions, @answers) -&gt; ($question, $answer) {
    say "What is you $question?  It is $answer";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定一个列表，按照日期字符串进行排序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">list = [ {'date': '2010-04-01','people': 1047, 'hits': 4522},
         {'date': '2010-04-03', 'people': 617, 'hits': 2582},
         {'date': '2010-04-02', 'people': 736, 'hits': 3277}
       ]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true-2"><a class="anchor" href="#true-2"></a>29.2. «</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @days = Date.new('2019-04-01') .. Date.new('2019-04-10');
.say for "/raku/" «~« @days;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truefeed"><a class="anchor" href="#truefeed"></a>29.3. feed</h3>
<div class="sect3">
<h4 id="trueinfix"><a class="anchor" href="#trueinfix"></a>29.3.1. infix =&#8658;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># Traditional structure, read bottom-to-top
my @result =
    sort               # (4) Sort, result is &lt;Earth People&gt;
    grep { /&lt;[PE]&gt;/ }, # (3) Look for P or E
    map { .tc },       # (2) Capitalize the words
    &lt;people of earth&gt;; # (1) Start with the input

# Feed (left-to-right) with parentheses, read top-to-bottom
@result = (
    &lt;people of earth&gt;  # (1) Start with the input
    ==&gt; map({ .tc })   # (2) Capitalize the words
    ==&gt; grep /&lt;[PE]&gt;/  # (3) Look for P or E
    ==&gt; sort           # (4) Sort, result is &lt;Earth People&gt;
);

# For illustration, method chaining equivalent, read top-to-bottom
@result =
    &lt;people of earth&gt;  # (1) Start with the input
    .map({ .tc })      # (2) Capitalize the words
    .grep(/&lt;[PE]&gt;/)    # (3) Look for P or E
    .sort;             # (4) Sort, result is &lt;Earth People&gt;

# To assign without the need of parentheses use another feed operator
&lt;people of earth&gt;
    ==&gt; map({ .tc })
    ==&gt; grep /&lt;[PE]&gt;/
    ==&gt; sort()
    ==&gt; @result;

# It can be useful to capture a partial result, however, unlike
# the leftward feed operator, it does require parentheses or a semicolon
&lt;people of earth&gt;
    ==&gt; map({ .tc })
    ==&gt; my @caps; @caps # also could wrap in parentheses instead
    ==&gt; grep /&lt;[PE]&gt;/
    ==&gt; sort()
    ==&gt; @result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个流操作符能让你在例程之外构建方法链那样的模式并且方法的结果能在不相关的数据上调用。在方法链中, 你被限制于使用数据身上可用的方法或使用之前的方法调用的结果。使用流操作符, 那个限制没有了。写出来的代码比一系列用多个换行符打断的方法调用更加可读。</p>
</div>
<div class="paragraph">
<p>注: 在将来, 这个操作符会在它获得并行地运行列表操作的能力之后有所变化。它会强制左侧的操作数作为一个闭包(它能被克隆并运行在子线程中)变得可闭合。</p>
</div>
</div>
<div class="sect3">
<h4 id="trueinfix-2"><a class="anchor" href="#trueinfix-2"></a>29.3.2. infix &#8656;=</h4>
<div class="paragraph">
<p>这个向左的流操作符从右侧接收结果并把结果作为最后的一个参数传递给它前面的(左侧的)例程。这为一系列列表操作函数阐明了从右到左的数据流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs"># Traditional structure, read bottom-to-top
my @result =
    sort                   # (4) Sort, result is &lt;Earth People&gt;
    grep { /&lt;[PE]&gt;/ },     # (3) Look for P or E
    map { .tc },           # (2) Capitalize the words
    &lt;people of earth&gt;;     # (1) Start with the input

# Feed (right-to-left) with parentheses, read bottom-to-top
@result = (
    sort()                 # (4) Sort, result is &lt;Earth People&gt;
    &lt;== grep({ /&lt;[PE]&gt;/ }) # (3) Look for P or E
    &lt;== map({ .tc })       # (2) Capitalize the words
    &lt;== &lt;people of earth&gt;  # (1) Start with the input
);

# To assign without parentheses, use another feed operator
@result
    &lt;== sort()             # (4) Sort, result is &lt;Earth People&gt;
    &lt;== grep({ /&lt;[PE]&gt;/ }) # (3) Look for P or E
    &lt;== map({ .tc })       # (2) Capitalize the words
    &lt;== &lt;people of earth&gt;; # (1) Start with the input

# It can be useful to capture a partial result
@result
    &lt;== sort()
    &lt;== grep({ /&lt;[PE]&gt;/ })
    &lt;== my @caps # unlike ==&gt;, there is no need for additional statement
    &lt;== map({ .tc })
    &lt;== &lt;people of earth&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>和向右的流操作符不一样, 这个结果不能严格地映射为方法链。然而, 和上面传统的结构中每个参数使用一行分割相比, feed 操作符写出的代码比逗号更具描述性。向左的流操作符也允许你打断语句并捕获一个可能对调试来说极其方便的中间结果或者接收那个结果并在最终结果身上创建另外一个变种。</p>
</div>
<div class="paragraph">
<p>注意: 在将来, 这个操作符会在它获得并行地运行列表操作的能力之后有所变化。它会强制右侧的操作数作为一个闭包变得可闭合(它能被克隆并运行在子线程中)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true超运算符"><a class="anchor" href="#true超运算符"></a>29.4. 超运算符</h3>
<div class="paragraph">
<p>超运算符与子例程</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a = &lt;1 2 3 4&gt;;
sub by2($n){
    return 2*$n;
}

sub power2($n) {
    return $n ** 2;
}
my @b = @a«.&amp;by2«.&amp;power2;
say @b; # 4 16 36 64</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么是 <code>&amp;function</code> 呢：</p>
</div>
<div class="paragraph">
<p>the name of the by2 function is &amp;by2, just as the name of the foo scalar is $foo and the name of the foo array is @foo</p>
</div>
<div class="ulist">
<ul>
<li>
<p>生成 IP 地址范围</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">.say for "192.168.10." «~» (0..255).list</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>生成 OC 中的测试数组</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">.say for "@" «~» '"Perl' «~»  (1..5).list «~» '",'</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">@"Perl1",
@"Perl2",
@"Perl3",
@"Perl4",
@"Perl5",</code></pre>
</div>
</div>
<div class="paragraph">
<p>我想以AGCT4种字母为基础生成字符串。</p>
</div>
<div class="paragraph">
<p>比如希望长度为1，输出A,G,C,T。
如果长度为2，输出AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT。这样的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a=&lt;A G C T&gt;;
my $x=@a;  # 或者使用 $x =@('A','G','C','T')
for 1 ...^ * -&gt; $a {(([X~] $x xx $a)).join(',').say;last if $a==4;}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truez"><a class="anchor" href="#truez"></a>29.5. Z</h3>
<div class="paragraph">
<p><code>Z</code> 像一个拉链那样把列表插入进来， 只要第一个输入列表耗尽就停止：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).perl;  # ((1, "a", "+"), (2, "b", "-")).list</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Z</code> 操作符也作为元操作符存在， 此时内部的 parcels 被应用了元操作符的列表替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 100, 200 Z+ 42, 23;
say 1..3 Z~ &lt;a b c&gt; Z~ 'x' xx 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">142, 223
1ax 2bx 3cx</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truex"><a class="anchor" href="#truex"></a>29.6. X</h3>
<div class="paragraph">
<p><code>X</code> 从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1..3 X &lt;a b c&gt; X 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">((1 a 9) (1 b 9) (1 c 9) (2 a 9) (2 b 9) (2 c 9) (3 a 9) (3 b 9) (3 c 9))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>X</code> 操作符也可以作为元操作符， 此时内部的 parcels 被应用了元操作符的列表的值替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">1..3 X~ &lt;a b c&gt; X~ 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="txt" class="language-txt hljs">(1a9 1b9 1c9 2a9 2b9 2c9 3a9 3b9 3c9)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueinfix-3"><a class="anchor" href="#trueinfix-3"></a>29.7. infix &#8230;&#8203;</h3>
<div class="paragraph">
<p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
</div>
<div class="paragraph">
<p>它可以有一个初始元素和一个生成器在 &#8230;&#8203; 的左侧， 在右侧是一个端点。</p>
</div>
<div class="paragraph">
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
</div>
<div class="paragraph">
<p>默认的生成器是 <code>*.succ</code> 或 <code>*.pred</code> ， 取决于末端怎么比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 1 ... 4;        # 1 2 3 4
say 4 ... 1;        # 4 3 2 1
say 'a' ... 'e';    # a b c d e
say 'e' ... 'a';    # e d c b a</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>*</code> (Whatever) 末端生成一个无限序列，使用的是默认的生成器 <code>*.succ</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say (1 ... *)[^5];  # 1 2 3 4 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义生成器是在 <code>&#8230;&#8203;</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数， 生成了斐波纳契数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say (1, 1, -&gt; $a, $b { $a + $b } ... *)[^8];    # 1 1 2 3 5 8 13 21
# same but shorter
say (1, 1, *+* ... *)[^8];                      # 1 1 2 3 5 8 13 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然自定义生成器也能只接收一个参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 5, { $_ * 2 } ... 40;                       # 5 10 20 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成器的参数个数至少要和初始元素的个数一样多。</p>
</div>
<div class="paragraph">
<p>如果没有生成器，并且有不止一个初始元素，所有的初始元素都是数值，那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 2, 4, 6 ... 12;     # 2 4 6 8 10 12
say 1, 2, 4 ... 32;     # 1 2 4 8 16 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果末端不是 <code>*</code>， 它会和每个生成的元素进行智能匹配，当智能匹配成功的时候序列就被终止。对于 <code>&#8230;&#8203;</code> 操作符， 会包含最后一个元素， 对于 <code>&#8230;&#8203;^</code> 操作符，会排除最后的那个元素。</p>
</div>
<div class="paragraph">
<p>这允许你这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">say 1, 1, *+* ...^ *&gt;= 100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
</div>
<div class="paragraph">
<p><code>&#8230;&#8203;</code> 操作符还会把初始值看作”已生成的元素”，所以它们也会对末端进行检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my $end = 4;
say 1, 2, 4, 8, 16 ... $end;
# outputs 1 2 4</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true-3"><a class="anchor" href="#true-3"></a>29.8. &#8230;&#8203;</h3>
<div class="ulist">
<ul>
<li>
<p>计算哪些日子是周六：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">enum DoW &lt; Sunday Monday Tuesday Wednesday Thursday Friday Saturday &gt;;
say (Date.new("2019-01-01")..Date.new("2019-12-31")).grep( *.day-of-week == Saturday );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="true集合"><a class="anchor" href="#true集合"></a>30. 集合</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="true集合运算"><a class="anchor" href="#true集合运算"></a>30.1. 集合运算</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Table Set</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode 表示</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII 表示</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">属于</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(elem)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">不属于</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(elem)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(cont)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">不包含</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∌</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(cont)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">并集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(|)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set 或 Bag</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">交集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∩</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&amp;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set 或 Bag</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">差集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(-)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">子集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊆</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&#8656;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">非子集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&#8656;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">真子集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&lt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">非真子集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&lt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">超级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊇</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&gt;=)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">非超级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&gt;=)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">真超级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">非真超级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>找到两个文件中共有的行</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="raku" class="language-raku hljs">my @a := "filea".IO.lines;
my @b := "fileb".IO.lines;
.say for keys( @a ∩ @b );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-06-30 14:35:51 +0800
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>